<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>View工作流程[零]：从setContentView到measure - Pigrange&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta name="description" content="我不管你看不看得懂，反正只要我看得懂就行了  —— john pig  这篇文章按道理来说是不应该存在于这里的，但是出于总总原因，我不得不在这里插入这篇文章以作为后面需要了解内容的预备知识。 大量文字预警！！！">
<meta name="keywords" content="Android,SourceCode">
<meta property="og:type" content="article">
<meta property="og:title" content="View工作流程[零]：从setContentView到measure">
<meta property="og:url" content="https://pigrange.github.io/2019/09/21/View-process-0/index.html">
<meta property="og:site_name" content="Pigrange&#39;s Blog">
<meta property="og:description" content="我不管你看不看得懂，反正只要我看得懂就行了  —— john pig  这篇文章按道理来说是不应该存在于这里的，但是出于总总原因，我不得不在这里插入这篇文章以作为后面需要了解内容的预备知识。 大量文字预警！！！">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://pigrange.github.io/assets/gallery/thumbnails/SourceCode.jpg">
<meta property="og:updated_time" content="2019-09-22T01:21:17.602Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="View工作流程[零]：从setContentView到measure">
<meta name="twitter:description" content="我不管你看不看得懂，反正只要我看得懂就行了  —— john pig  这篇文章按道理来说是不应该存在于这里的，但是出于总总原因，我不得不在这里插入这篇文章以作为后面需要了解内容的预备知识。 大量文字预警！！！">
<meta name="twitter:image" content="https://pigrange.github.io/assets/gallery/thumbnails/SourceCode.jpg">







<link rel="icon" href="/assets/img/logo.jpg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/assets/img/logo.jpg" alt="View工作流程[零]：从setContentView到measure" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">主页</a>
                
                <a class="navbar-item" href="/categories">分类</a>
                
                <a class="navbar-item" href="/archives">归档</a>
                
                <a class="navbar-item" href="/tags">标签</a>
                
                <a class="navbar-item" href="/about">关于我</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-10-tablet is-8-desktop is-8-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                    View工作流程[零]：从setContentView到measure
                    
        </h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-21T15:53:50.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-21</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-22T01:21:17.602Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-22</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 7476 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p><em>我不管你看不看得懂，反正只要我看得懂就行了  —— john pig</em> </p>
<p>这篇文章按道理来说是不应该存在于这里的，但是出于总总原因，我不得不在这里插入这篇文章以作为后面需要了解内容的预备知识。</p>
<h3 id="大量文字预警！！！"><a href="#大量文字预警！！！" class="headerlink" title="大量文字预警！！！"></a>大量文字预警！！！</h3><a id="more"></a>

<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li><strong><a href="#setcontentview">setContentView</a></strong><ul>
<li><strong><a href="#initdecor">DecorView的初始化</a></strong></li>
<li><strong><a href="#addcontent">ContentView的添加</a></strong></li>
</ul>
</li>
<li><strong><a href="#resume">Activity的resume</a></strong></li>
<li><strong><a href="#process">View的工作流程</a></strong></li>
<li><a href>补充</a><ul>
<li><strong><a href="#additional">Choreographer.postCallback</a></strong></li>
<li><strong><a href="#requestlayout">ViewParent#requestLayout</a></strong></li>
</ul>
</li>
</ul>
<p>写在前面：</p>
<p>在学习View的工作流程的时候，很多人都是直接从measure方法开始讲，或者稍微提到了从ViewRootImpl的performTraversal开始就不在详细说明了。确实Android源码是一个无底洞，深入进去往往无法自拔，很多东西抓住重点学习，可以快速熟悉整个系统的生态，不会在某些细枝末节的地方花上太多的时间。但是我始终觉得，这样学到的知识是零散的，导致我们很多时候很难将某些内容联系起来，这样显然对于Android的更加深入的理解是不利的。</p>
<p><strong>为什么我要将setContenView和measure一起讲：</strong></p>
<p>首先我要说明，这两者是没有关系的。setContentView方法是在Activity的onCreate中被调用的。我一直觉得Google的开发者真的是命名鬼才，对于方法的命名是非常精准的，所以我正好可以借助google的思路所作出强调：<strong>setContentView就只做了setContentView，仅此而已 (所以千万不要像我一样在那里死磕setContentView在AppcompactActivity中的实现, 它其实对于View的工作流程没有任何关联。</strong>而整个ViewTree的测量，定位，绘制是在Activity的onResume方法之后的某一个时刻被调用的，为什么是某一个时刻呢？因为这里用到了Handler，我们并不能确定handler具体处理整个message的时刻。</p>
<p><strong>但是! ! !</strong>，我在学习的过程中发现有不少blog是误导性或者甚至是有错的。他们都过多强调了Window.addView方法的功能，导致一些没有搞清Window和WindowManager的同学很容易在这里去纠结这个方法的具体实现，因为它们会觉得只要View和Window关联起来了，那么contentView在这里就成功的添加到了屏幕上了，所以可能会和我一样，傻乎乎的在setContentView里面去找半天ViewRootImpl的performTraversal方法，然而in vain。</p>
<p><strong>我的理解：</strong></p>
<ul>
<li>JAVA的锅。很大一部分原因是因为JAVA面向对象的语义太强了，导致开发者很容易沉迷于某一个封装好的类的功能中去。然而实际上对于对象来说，我们应重其成员而轻其方法，因为对于类结构，它的所有实例都是共享运行时常量池里方法的引用的。那么对于对象这个数据结构来说，其本质就是运行在堆空间的一块存放数据的内存。那么回到我之前谈的话题，setContentView做了什么事情？其实很简单，就是把ContentView这棵ViewTree挂载到了另一棵ViewTree上，组建成了我们最终需要的ViewTree（这里我们把所有的View就当作数据结构中树的最基本节点），那么核心方法是什么呢？两步：<ul>
<li><code>parentView-&gt;child = contentLayout</code></li>
<li><code>contentLayout-&gt;parent = parentView</code></li>
</ul>
</li>
<li>Android View 设计的锅。先声明，我不是说View设计得不好哇，但是不得不吐槽，View实在是太臃肿了。一个最基本的控件居然有27753行代码，这也间接或直接得导致了许多人对其闻之色变，觉得View是一个又难又高深莫测的存在。个人觉得还是因为View的设计者太省事了，把一大堆方法都往View里面丢(虽然确实和View有关，但是个人觉得拆分成多个类的话可以更加凸显出View的职责)，这也直接导致我在学习整个Android的过程中一直认为View就是一个能够显示的控件，至于它如何被显示，因为它有draw方法，能够在canvas上面画它。其实这种解释是说的过去的，但是不严谨的，因为这会让人把屏幕上的显示的东西和View这个类(或者其实例)绑定在一起。但是，事实是View的显示或者如何做到在屏幕上显示和View的对象本身半毛钱关系的没有，View对象就是一个巨大（成员很多）的数据结构，存放了我们约定的那个逻辑上的视图的一堆信息，这些数据有也好，没有也罢，其实都不会对屏幕上的图像如何显示产生影响(这里要搞明白，我是指图像的产生的过程，也就是到底是怎么被绘制的，不是说图像的大小形状这些最终显现出来的特征)，因为View如何在屏幕上显示(绘制)是通过调用底层的Skia API实现的。</li>
</ul>
<p>回到最初的问题：在讲setContentView的具体实现之前，我们可以先给其一个不怎么准确但是比较好理解的定义：创建了contentView对象节点和其子View对象节点组成的一个树，(我们就把它们当作View类型的对象的数据结构)，并和PhoneWindow对象进行了关联（这里我刻意说明了对象这两个字，是想强调对象就是一块内存这个基本原则）。</p>
<p><strong>好了，不BB了，上代码。</strong></p>
<h2 id="SetContentView"><a href="#SetContentView" class="headerlink" title="SetContentView"></a><span id="setcontentview">SetContentView</span></h2><p>我们先来康康AppCompactActivity的SetContentView做了什么：</p>
<h4 id="setContentView-1"><a href="#setContentView-1" class="headerlink" title="setContentView (1)"></a>setContentView (1)</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//AppCompactActivity#setContentView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是一脸蒙蔽，这个Delegate是啥？管它是啥，咱们继续往下看。getDelegate最终返回了mDelegate，而这里的delegate的实际类型是AppCompactDelegateImpl，我们再康康它的setContentView</p>
<h4 id="setContentView-2"><a href="#setContentView-2" class="headerlink" title="setContentView (2)"></a>setContentView (2)</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// AppCompactDelegateImpl#setContentView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor(); #(1)</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    <span class="hljs-comment">//注意: 这个变量的名字为虽然叫contentParent</span></span><br><span class="line">    <span class="hljs-comment">//但是和后面提到的DecorView持有的contentParent并不是一个东西</span></span><br><span class="line">    <span class="hljs-comment">//为了防止和后面搞混，我在这里先统一规定contentParent为DecorView的child</span></span><br><span class="line">    <span class="hljs-comment">//而setContentView挂载的parent，我们将其称为ContentFrameLayout</span></span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent); #(2)</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有看过activity的setContentView的朋友可能会觉得这里的代码似曾相识，但是我需要说明appCompactActivity远比ActivityView复杂，通过后面的分析，我们可以了解到，它其实在contentFrameLayout和DecorView之间还引入了两层ViewGroup，其分别是FrameLayout (就是我们后面会提到的subDecor)，和FitWindowsLimearLayout，也就是说，从AppComactActivity开始，我们的ContentFrameLayout并不是直接挂载到DecorView上的，而是挂载在FitWindowsLimearLayout上面的。</p>
<p><strong>另外，为了便于读者理解上面两个比较重要的方法的具体功能，我将下面的内容分成了DecorView的初始化和ContentView的挂载两个小标题。</strong></p>
<h3 id="DeocrView的初始化："><a href="#DeocrView的初始化：" class="headerlink" title="DeocrView的初始化："></a><span id="initdecor">DeocrView的初始化：</span></h3><p>扯远了，我们着重康康ensureSubDecor的实现。</p>
<h4 id="ensureSubDecor"><a href="#ensureSubDecor" class="headerlink" title="ensureSubDecor"></a>ensureSubDecor</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//AppCompactDelegateImpl#ensureSubDecor</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureSubDecor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mSubDecorInstalled) &#123;</span><br><span class="line">        <span class="hljs-comment">//ensureSubDecor的核心是createSubDecor这个方法</span></span><br><span class="line">        mSubDecor = createSubDecor();</span><br><span class="line">        <span class="hljs-comment">//...下面的代码都是subDecor创建好了之后才有用的</span></span><br><span class="line">        <span class="hljs-comment">//不是重点，我们这里不做研究</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，里面调用了createSubDecor这个方法。(哈？为什么是subDecor，那我的DecorView呢？啥时候创建呢? )前面括号里的内容是我第一次看到这里时内心的感受，想必大多朋友和我一样蒙蔽，但是不要慌，咋们继续往下看。</p>
<p>说明一下，这个createSubDecor是一个长达222行代码超长方法，为了阅读体验和文章篇幅，我删掉了大量无关代码，并且对相关方法做了较为详细的描述。</p>
<h4 id="createSubDecor"><a href="#createSubDecor" class="headerlink" title="createSubDecor"></a>createSubDecor</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//AppCompactDelegateImpl#createSubDecor</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> ViewGroup <span class="hljs-title">createSubDecor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//这里的ensureWindow我们不用多管，对于普通的启动</span></span><br><span class="line">    <span class="hljs-comment">//我们默认Activity的phoneWindow在这之前就已经创建好了</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//PhoneWindow对象的创建是在Actvity的attach方法里面的</span></span><br><span class="line">    <span class="hljs-comment">//具体见ActivityThread#performLaunchActivity</span></span><br><span class="line">    <span class="hljs-comment">//里面调用了activity.attatch</span></span><br><span class="line">    ensureWindow();</span><br><span class="line">    mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> LayoutInflater inflater = LayoutInflater.from(mContext);</span><br><span class="line">    ViewGroup subDecor = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//下面的这整个代码块都是对subDecor进行创建的</span></span><br><span class="line">    <span class="hljs-comment">//本质是inflater解析xml文件生成View对象的过程</span></span><br><span class="line">    <span class="hljs-comment">//因为涉及到很多种场景，所以有很多判断逻辑</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!mWindowNoTitle) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                R.layout.abc_dialog_title_material, <span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            mHasActionBar = mOverlayActionBar = <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mHasActionBar) &#123;</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//...删了很多无关代码</span></span><br><span class="line">            subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                .inflate(R.layout.abc_screen_toolbar, <span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            mDecorContentParent = (DecorContentParent) subDecor</span><br><span class="line">                .findViewById(R.id.decor_content_parent);</span><br><span class="line">            mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//...删了很多无关代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mOverlayActionMode) &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                R.layout.abc_screen_simple_overlay_action_mode, <span class="hljs-keyword">null</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, <span class="hljs-keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删了很多无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...这里删除了大量的无关代码</span></span><br><span class="line">    <span class="hljs-comment">//但是我觉得有必要说一下</span></span><br><span class="line">    <span class="hljs-comment">//前面不是提到了AppCompatctActivtity在原来的基础上面又多了两层结构吗</span></span><br><span class="line">    <span class="hljs-comment">//subDecor是多的那一个FrameLayout，而真正持有contentFrameLayout的</span></span><br><span class="line">    <span class="hljs-comment">//是FitWindowsLinearLayout</span></span><br><span class="line">    <span class="hljs-comment">//这里删掉的代码就是和FitWindowsLinearLayout初始化有关的</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//将subDecor挂载在mWindow上</span></span><br><span class="line">    <span class="hljs-comment">//这里我并不想分析PhoneWindow的代码</span></span><br><span class="line">    <span class="hljs-comment">//因为转过去转过来很容易将人转晕</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//只是强调一下，mWindow本质上并不是View</span></span><br><span class="line">    <span class="hljs-comment">//而其setContentView会调用它持有的mContentParent的addView</span></span><br><span class="line">    <span class="hljs-comment">//而mWindow持有的mContentParent是我们在上面创建的DecorView的</span></span><br><span class="line">    <span class="hljs-comment">//一个名为contentParent的成员，其本身就是DecorView的一个child</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//复习一下：DecorView有两个child，一个是titleView，一个是contentParent</span></span><br><span class="line">    <span class="hljs-comment">//我们把SubDecor挂在DecorView上，实际上是把subDecor添加到了contentParent</span></span><br><span class="line">    <span class="hljs-comment">//这个FrameLayout里面</span></span><br><span class="line">    mWindow.setContentView(subDecor);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉一些没用的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> subDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，我们可以知道，通过调用了mWindow.getDecorView()创建了DecorView的对象，同时通过ViewInflater创建了subDecor的对象。subDecor的工作流程在这里已经讲的特别清楚了(其实大多数都被我删掉了hhhh)，所以我们着重康康mWindow.getDecorView()这个方法。</p>
<p><strong>再次强调：上述方法完成很重要的两个任务：</strong></p>
<ul>
<li>创建了DecorView的对象</li>
<li>创建了subDecor的对象</li>
</ul>
<h4 id="getDecorView"><a href="#getDecorView" class="headerlink" title="getDecorView"></a>getDecorView</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//PhoneWindow#getDecorView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">getDecorView</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mDecor == <span class="hljs-keyword">null</span> || mForceDecorInstall) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是做了一层封装，我们在康康installDecor方法。（又是一个200多行的方法，不过被删的只有3行，hhh</p>
<h4 id="installDecor"><a href="#installDecor" class="headerlink" title="installDecor"></a>installDecor</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//PhoneWindow#installDecor</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installDecor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//..删掉了大量的没啥卵用的代码</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//创建DecorView的对象</span></span><br><span class="line">    mDecor = generateDecor(-<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-comment">//创建contentParent的对象</span></span><br><span class="line">    mContentParent = generateLayout(mDecor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过重重删减后，可以看到，只剩下了俩方法了，通过名字我们可以了解到，这两个方法主要干了两件事情。</p>
<ul>
<li>生成了我们的DecorView的实例</li>
<li>生成了ContentParent的实际</li>
</ul>
<p>我们接下来就来康康generateDecor()到底是如何创建了DecorView的，同样为了阅读体验，我将代码中没有用的部分都删除了。</p>
<h4 id="generateDecor"><a href="#generateDecor" class="headerlink" title="generateDecor"></a>generateDecor</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//PhoneWindow#generateDecor</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> DecorView <span class="hljs-title">generateDecor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">    <span class="hljs-comment">//...删掉了大量没啥用的代码</span></span><br><span class="line">    context = <span class="hljs-keyword">new</span> DecorContext(applicationContext, getContext());</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorView(context, featureId, <span class="hljs-keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，找了半天，我们终于找到了DecorView的创建了。挖了这么深，我们也该回头了，要不又得绕晕了hhhh。这个时候我们应该保持头脑清醒，告诉自己，这一切都是在AppCompactActivity的setContentView中被调用的。<strong>并且！</strong>，到目前为止，我们所作的一切工作都还是在为添加contentView做准备，而我们的主角 — contentView 还没有正式登场。</p>
<p><strong>先别急，都走到这一步了，回头之前，我们还是把最后一个坑填了，简单看看DecorView的contenParent是咋创建的</strong>，和前面一样，删掉大量无关代码。</p>
<h4 id="generateLayout"><a href="#generateLayout" class="headerlink" title="generateLayout"></a>generateLayout</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//PhoneWindow#generateLayout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ViewGroup <span class="hljs-title">generateLayout</span><span class="hljs-params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量无关代码</span></span><br><span class="line">    <span class="hljs-comment">//emmm 其实有关的，上面的代码会决定下面会用到的layoutResource具体为</span></span><br><span class="line">    <span class="hljs-comment">//哪一个ID, 但是这里我们就不深入研究了，假装上面返回的是一个固定的值</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//contentParent实际产生的方法</span></span><br><span class="line">    <span class="hljs-comment">//具体的实现在DecorView内部，实际上就是通过layoutInflater</span></span><br><span class="line">    <span class="hljs-comment">//去解析xml构建了这个View实例,并且将其和DecorView进行关联</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup) findViewById(ID_ANDROID_CONTENT);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量有关contentParent初始化的代码</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们可以发现，contentParent的实际创建是在DecorView的onResourcesLoaded回调中完成的，既然都走到这一步了，我们干脆一气呵成，刨根问底，康康onResourcesLoaded是如何实现的。</p>
<h4 id="onResourcesLoaded"><a href="#onResourcesLoaded" class="headerlink" title="onResourcesLoaded"></a>onResourcesLoaded</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//DecorView#onResourcesLoaded</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResourcesLoaded</span><span class="hljs-params">(LayoutInflater inflater, <span class="hljs-keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了多余的代码</span></span><br><span class="line">    <span class="hljs-keyword">final</span> View root = inflater.inflate(layoutResource, <span class="hljs-keyword">null</span>);</span><br><span class="line">    addView(root, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，看到这里，我们的思路就非常清晰了，其实就是在这个里面通过LayoutInflater 构建了我们的contentParent的实例，并且将其和DecorView关联。</p>
<p><strong>走到这一步，我们对整个DecorView的初始化就非常清楚了</strong>，接下来我们就需要具体康康contentView是如何挂载到我们的ContentFrameLayout上的，但是在这之前，<strong>我必须强调</strong>一下：我在上面的代码分析其实是有错误的，错误的位置是在DecorView的onResourcesLoaded中，实际上这里通过inflater产生的View并不是我们的contentParent，而是一个LinearLayout，我们所说的contentParent实际上是这个LinearLayout的child，但是为了便于大家理解，我在上面的描述中就刻意隐藏这个LinearLayout的存在。</p>
<p><strong>补充说明：在这篇文章中我并不打算谈论ActionBar或者ToolBar的存在</strong>。所以我这里的描述是有残缺的，主要还是怕一下子信息量太多难以理解，还有就是ActionBar的工作流程也比较复杂，值得单独写一篇文章来分析它的创建。</p>
<p>这里给一个网上找到的比较准确的View层级关系的图，图中是给出了ActionBar的位置的(黄色框框)，大家选择性忽略就好。(补充一个地方，图里FitWindowsLinearLayout外层的深色框框就是subDecorView没有标注出来，本质是一个FrameLayout)。</p>
<p><img src="https://github.com/pigrange/pigrange.github.io/blob/master/assets/img/ViewHierarchy.png?raw=true" alt></p>
<h3 id="ContentView的添加："><a href="#ContentView的添加：" class="headerlink" title="ContentView的添加："></a><span id="addcontent">ContentView的添加：</span></h3><p>再次回到AppCompactDelegateImpl的setContentView方法</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//AppCompactDelegateImpl#setContentView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//ensureSubDecor();已经被调用了，我们不看了</span></span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里通过调用了LayoutInflater的inflate方法构建了我们的contentView(及其子View)的对象，并且将其添加到了我们的contentParent上，而这里的contentParent就是我们前面提及到的ContentFrameLayout.(注意这里的其实是给的contentView的xml的id)。</p>
<p><strong>由于上面就是一个很朴实的inflate方法，所以这里我就不多讲了。感兴趣的可以自己去了解一下inflate方法的具体实现。</strong></p>
<p><strong>再多BB一句，setContentView虽然初始化了，DecorView，但是ViewRootImpl还并未被初始化，并且这个时刻AttachInfo也是null.</strong></p>
<h2 id="View的工作流程-Activity-Resume-："><a href="#View的工作流程-Activity-Resume-：" class="headerlink" title="View的工作流程(Activity#Resume)："></a><span id="resume">View的工作流程(Activity#Resume)：</span></h2><p>这里的View工作机制就是我们所说的测量，定位，以及绘制的流程，但是这里我并不会去讲那三大方法，接下来我会单独写文章去研究它们的代码。前面的文章(View工作流程[一])以及说明了这三大方法会在ViewRootImpl的performTraversal调用，那么这里我们就继续追根溯源，康康ViewRootImpl到底是在什么时候被创建的，它的performTraversal又是在啥时候被调用的呢？这些时间点又处于Activity生命周期的哪个时刻呢？</p>
<p><strong>首先说明，和前面刨根问底不同，接下来我们要做的是追根溯源，所以这里我们是向上层层递归，去寻找performTraversal的最初调用，这个其实很容易，debug观察内存栈帧就明白了。为了方便起见，我还是自顶向下的讲解。</strong></p>
<h4 id="handleResumeActivity"><a href="#handleResumeActivity" class="headerlink" title="handleResumeActivity"></a>handleResumeActivity</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ActivityThread#handleResumeActivity</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                 String reason)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量没有用的代码</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...并且，先不要管后面的代码！！！</span></span><br><span class="line">	<span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//强调：实际上ViewRootImpl就是在这后面被创建的，但是我们先不忙看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有留意我注释的朋友一定会说：“你这不坑我吗？前面没有用的你让我看，后面有用的你告诉我现在不看？”</p>
<p>先不要激动，没看到我上面写了个大大的Activity#Resume吗？如果你不耐烦的话，可以点击<strong><a href="#process">这里</a></strong>跳转到和View工作流程直接相关的内容。这里，我主要还是想顺带的复习一下Activity的onResume的具体调用逻辑(因为都是在一起的，顺带一起复习了，这样也能加深印象，对View的工作流程的开始位置有一个更加深入的了解，嘿嘿嘿)。</p>
<h4 id="performResumeActivity"><a href="#performResumeActivity" class="headerlink" title="performResumeActivity"></a>performResumeActivity</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ActivityThread#performResumeActivity</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityClientRecord <span class="hljs-title">performResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                                  String reason)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="hljs-comment">//...删除了大量没啥关联的代码</span></span><br><span class="line">    r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="performResume"><a href="#performResume" class="headerlink" title="performResume"></a>performResume</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Activity#performResume</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performResume</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//这个方法我没有删，主要是觉得有必要留意一些</span></span><br><span class="line">    <span class="hljs-comment">//没错它就是第一个被调用的。。。</span></span><br><span class="line">    <span class="hljs-comment">//而在performRestart里面，又依次调用了</span></span><br><span class="line">    <span class="hljs-comment">//(1)、mInstrumentation.callActivityOnRestart() --&gt; onRestart</span></span><br><span class="line">    <span class="hljs-comment">//(2)、performStart() --&gt; onStart</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    performRestart(<span class="hljs-keyword">true</span> <span class="hljs-comment">/* start */</span>, reason);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    mInstrumentation.callActivityOnResume(<span class="hljs-keyword">this</span>);</span><br><span class="line">	<span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量的无关的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="callActivityOnResume"><a href="#callActivityOnResume" class="headerlink" title="callActivityOnResume"></a>callActivityOnResume</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Instrmentation#callActivityOnResume()</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnResume</span><span class="hljs-params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.mResumed = <span class="hljs-keyword">true</span>;</span><br><span class="line">    activity.onResume();</span><br><span class="line">    <span class="hljs-comment">//... 删掉大量无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到目前位置，Activity的onResume如何被调用的我们也了解了。那么接下来，我们正式的康康handleResumeActivity中被抹去的代码吧。</p>
<h2 id="View的工作流程-真-："><a href="#View的工作流程-真-：" class="headerlink" title=" View的工作流程(真)："></a><span id="process"> View的工作流程(真)：</span></h2><h3 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h3><h4 id="handleResumeActivity-1"><a href="#handleResumeActivity-1" class="headerlink" title="handleResumeActivity"></a>handleResumeActivity</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ActivityThread#handleResumeActivity</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                 String reason)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="hljs-keyword">if</span> (r.window == <span class="hljs-keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//获取DecorView并设置相关属性</span></span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//获取WindowManager</span></span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//准备将decorView添加到windowManger中</span></span><br><span class="line">        <span class="hljs-comment">//所以这里要创建一个WindowManager.LayoutParams</span></span><br><span class="line">        <span class="hljs-comment">//并设置相关的属性</span></span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删掉了大量无关的代码</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//将decorView添加到WindowManager中</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="hljs-keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删掉了大量无关的代码</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在上述的代码块中出现了WindowManager，并且将我们的decorView添加到了WindowManager里，那你肯定想问: “妈的，那我的phoneWindow就这样不管了吗？“ 我只能这么回答，是的，因为后面真的就没有它什么事情了。View层级结构的PhoneWindow是一个很抽象的概念它始终给我们一种可有可无的感觉。</p>
<p>如果你要问PhoneWindow有什么作用，我可以这么回答：给整个ViewTree(注意这里不指某个节点，研究对象是整个ViewTree)提供了一个对外统一的API(再次注意，这里是面向用户对ViewTree的操作，) ，换句话说就是PhoneWindow是对整个View的层级结构的一层封装(隐藏了内部实现)，它本身不可见，也不是View层级结构中的一员。</p>
<p>我再举一个更详细的例子，比如JAVA中的LinkedList。我们知道LinkedList内部是由链表实现的，但是我们把它当集合框架的时候只会去研究某一个具体的节点或者整个链表整体的属性，对于大多数人，它们不会关心整个链表的逻辑结构(对应这里的ViewTree)，也不会去关系链表的头节点(对应这里的DecorView)，它们只会使用LinkedList这个类的实例(对应这里的phoneWindow)，或者研究某一个节点的属性或值(LinkedList的第 i 个元素)。</p>
<p><strong>插入中断：谈一谈WindowManager</strong></p>
<p>因为个人觉得在描述了PhoneWindow的作用后再去看WindowManager的职责就很清晰了，所以决定在这里强行插入关于WindowManger的解释。</p>
<p>前面提到，我们可以把PhoneWindow类别成一个LinkedList。然后我们再回到Android里，显然每一个Acitivity都会有这么一个PhoneWindow与之对应。但是我们的应用有可能会由很多个Activity哇，也就是说会有很多个PhoneWindow哇，所以是不是又需要一个组件来存储和管理这一系列的PhoneWindow呢，而提供这个功能的组件就是我们的WindowManager，（这也是为什么对于一个Application，WindowManager是一个全局的单例，因为只会用的到一个呀😂）。</p>
<p>另外再解释一下为什么这里WindowManger添加的是DecorView，还是基于上面链表的例子，对于一个存放所有链表的数据结构，它里面存放所有链表封装的抽象(LinkedList)或者第一个元素(DecorView)本质是一样的。但是上面我也说了，WindowManger不仅仅只是存储，它也有管理的功能，而它对ViewTree的管理肯定是依附于其节点的，通过查看PhoneWindow的API我们知道其实PhoneWindow的功能是很受限制的，所以要实现更多的功能，肯定还是直接管理节点更加方便，而WindowManger对ViewTree的管理，就是通过ViewRootImpl来实现的，或者说WindowManager把ViewTree的管理托付给了ViewRootImpl来替它完成。</p>
<p>我们再审视一下ViewRootImpl和PhoneWindow的功能：</p>
<ul>
<li>本质都是对ViewTree进行管理的类</li>
<li>ViewRootImpl是面向WindowManager的</li>
<li>PhoneWindow是面向用户的</li>
<li>ViewRootImpl倾向于对ViewTree的工作流程的管理</li>
<li>PhoneWindow倾向于对ViewTree的信息的管理</li>
</ul>
<p><strong>又扯远了</strong></p>
<h4 id="addView-1"><a href="#addView-1" class="headerlink" title="addView (1)"></a>addView (1)</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//WindwowManager#addView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们可以看到，WindowManager的addView，内部调用了WindowManagerGlobal的addView方法。</p>
<h4 id="addView-2"><a href="#addView-2" class="headerlink" title="addView (2)"></a>addView (2)</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//WindwowManagerGlobal#addView</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                    Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量无关代码</span></span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删掉了大量无关代码</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//初始化ViewRootImpl的对象</span></span><br><span class="line">        root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        <span class="hljs-comment">//将DecorView的LayoutParams设置为WindowManager关联的LayoutParams</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="hljs-comment">//将DecorView添加到WindowManager的mView中</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        <span class="hljs-comment">//将和此DecorView关联的ViewRootImpl添加到mRoots中</span></span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        <span class="hljs-comment">//将和此DecorView关联的LayoutParams添加到mParams中</span></span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">        <span class="hljs-comment">//将DecorView与ViewRootImpl进行关联</span></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删掉了大量无关的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的内容也是十分清晰，其实mViews , mRoots , mParams 都是数组，所以我们暂时不管。需要留意的是ViewRootImpl是在这里被初始化的，而ViewRootImpl的构造方法到底干了什么事情我们先不管，但是可以了解一点，和此Activity关联的attachInfo是在ViewRootImpl的构造方法里面被创建的。</p>
<p>然后我们着重来看看ViewRootImpl的setView方法。</p>
<h4 id="setView"><a href="#setView" class="headerlink" title="setView"></a>setView</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#setView</span></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* We have one child   &lt;--- 我觉得这个注释很有意思，就保留了</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mView == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//...省略了大量无关(其实很重要的)代码</span></span><br><span class="line">            <span class="hljs-comment">//主要是对View的AttachInfo进行相关属性的初始化</span></span><br><span class="line">           </span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//注意：！！！</span></span><br><span class="line">            <span class="hljs-comment">//这个方法就是整篇文章的重点了</span></span><br><span class="line">            requestLayout();</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//...后面的代码就先不管了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于看到了一个我们非常熟悉的方法了，似乎也开始有头绪了，那么我们就再来康康ViewRootImpl的reuestLayout()到底做了什么吧。</p>
<h4 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#requestLayout</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="hljs-keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线索越来越清晰了！！！，我们继续康康 scheduleTraversals 方法。</p>
<h4 id="scheduleTraversals"><a href="#scheduleTraversals" class="headerlink" title="scheduleTraversals"></a>scheduleTraversals</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#scheduleTraversals</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);</span><br><span class="line">    	<span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...省略没有必要的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仿佛失去方向了，但是注意看mChoreographer，它调用了一个postCallBack方法，而这个方法里面的参数有一个名字带有runnable关键字的变量，那么它是什么呢？</p>
<h4 id="mTraversalRunnable"><a href="#mTraversalRunnable" class="headerlink" title="mTraversalRunnable"></a>mTraversalRunnable</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#mTraversalRunnable</span></span><br><span class="line"><span class="hljs-keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="hljs-keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来这家伙是就是一个封装了doTraversal方法的runnable哇 , 是不是线索又变得清晰了起来<del>~</del></p>
<h4 id="doTraversal"><a href="#doTraversal" class="headerlink" title="doTraversal"></a>doTraversal</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="hljs-keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//小老弟，看这里。是不是横竖都写着call me here. 😁</span></span><br><span class="line">        performTraversals();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//...省略一些代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，总算是找到了。 这样一来，我们的整个逻辑就被打通了，也就是说从这里开始，就进入了View真正的工作流程。</p>
<p>(累死了，这里我就先不忙画流程图了，真的是没时间哇，挖个坑，以后填。)</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a><span id="additional">补充：</span></h2><h3 id="Choreographer-postCallback"><a href="#Choreographer-postCallback" class="headerlink" title="Choreographer.postCallback"></a>Choreographer.postCallback</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Choreographer#postCallBack</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到postCallback内部调用了postCallbackDelayed() , 是不是感觉似曾相识？没错我就是说的Handler！我们继续来康康postCallbackDelayed的实现。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Choreographer#postCallbackDelayed</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCallbackDelayed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType,Runnable action, Object token, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">	<span class="hljs-comment">//...删掉部分没啥用的代码</span></span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postCallbackDelayed内部又调用了postCallbackDelayedInternal。emmm 没啥，这种写法谁没见过，咋们继续往下看，再来研究研究postCallbackDelayedInternal。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Choreographer#postCallbackDelayedInternal</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCallbackDelayedInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType,Object action,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                         Object token, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...删掉一些没啥用的判断</span></span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//...删掉一些没啥用的判断</span></span><br><span class="line">        Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">        msg.arg1 = callbackType;</span><br><span class="line">        msg.setAsynchronous(<span class="hljs-keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是觉得柳暗花明了，如果你还没有明白的话，请注意上面代码的下部分，那可是handler呀！！</p>
<p>好了，我也不多BB了，这段代码其实很简单，虽然Choreographer这个类做了很好的封装，但是其实本质上还是通过Handler实现的，只不过这里并没有直接把runnable封装到msg中，而是单独搞了一个mCallbackQueue，将runnable缓存在里面，然后让handler获取到<code>MSG_DO_SCHEDULE_CALLBACK</code>这个消息的时候，就去队列里面取出来运行…</p>
<p>至于为什么要这么做，我们这里就不多做研究了(坑是填不完的 _ <em>(:з)∠)</em> _   )…</p>
<h3 id="ViewParent-requestLayout"><a href="#ViewParent-requestLayout" class="headerlink" title="ViewParent#requestLayout"></a><span id="requestlayout">ViewParent#requestLayout</span></h3><p>我觉得很有必要把requestLayout拿出来讲一讲，因为看书学习的时候，我们会被灌输requestLayout将会导致整个ViewTree重新绘制的观点，而由于我们并不是很了解其实现，所以往往会对其功能产生固化的观点，甚至会情不自禁将其和View的三大工作流程联系起来。虽然事实是这样没错，但是在某一些场景下，这种惯性思维将会使我们误入歧途。</p>
<p><strong>比如：</strong>在setContentView中，我们其实是可以发现内部实现是由多次调用requestLayout这个方法的，如果你对这个方法了解不够具体，仅仅知道它会导致ViewTree的重新绘制，那么你可能就会像我一样拼命的去寻找它是在哪里让View重绘的，或者去思考它到底在哪里调用ViewRootImpl的方法。诚然，这种思路是一点问题的都没有的，但是我们犯了一个原则性的错误，就是在Activity的onCreate方法里面ViewRootImpl其实是还并未被初始化的(惊不惊喜，意不意外！)。所以在这里调用的requestLayout方法根本就不会导致整个ViewTree的重绘！！！</p>
<p><strong>所以：</strong>requestLayout导致ViewTree重绘一定是建立在DecorView被添加到WindowManagerGlobal之后这个前提条件的。</p>
<p>最后，我们再来分析一些下requestLayout的实现：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewParent#requestLayout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉这里用不到的代码块</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里的逻辑很简单，向上递归调用parent的requestLayout</span></span><br><span class="line">    <span class="hljs-comment">//但是我们要注意，这里的mParent并不是View</span></span><br><span class="line">    <span class="hljs-comment">//而是一个ViewParent的接口，所有的View和ViewRootImpl都实现了它</span></span><br><span class="line">    <span class="hljs-comment">//这也是为什么DecorView能够调用ViewRootImpl的requestLayout的原因</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//在Activity的onCreate方法里，由于ViewRootImpl为空</span></span><br><span class="line">    <span class="hljs-comment">//所以这个方法的递归掉用都会在DecorView处终止</span></span><br><span class="line">    <span class="hljs-comment">//所以，(在这种情况下)并不会导致ViewTree的重绘</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>
        
        <ul class="post-copyright">
            <li><strong>本文标题：</strong><a href="https://pigrange.github.io/2019/09/21/View-process-0/">View工作流程[零]：从setContentView到measure</a></li>
            <li><strong>本文作者：</strong><a href="https://pigrange.github.io">John Pig</a></li>
            <li><strong>本文链接：</strong><a href="https://pigrange.github.io/2019/09/21/View-process-0/">https://pigrange.github.io/2019/09/21/View-process-0/</a></li>
            <li><strong>发布时间：</strong>2019-09-21</li>
            <li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
            </li>
        </ul>
        
        
        <hr style="height:1px;margin:1rem 0">
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <i class="fas fa-tags has-text-grey"></i>&nbsp;
                    <a class="has-link-grey -link" href="/tags/Android/">Android</a>,&nbsp;<a class="has-link-grey -link" href="/tags/SourceCode/">SourceCode</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2019/09/19/View-process-1/">
                <span class="level-item">View工作流程[一]：Measure测量</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <figure class="image is-128x128 has-mb-6">
                            <img class="is-rounded" src="/assets/img/favicon.jpg" alt="pigrange">
                        </figure>
                    
                    
                    <p class="is-size-4 is-block">
                        pigrange
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        JohnPig
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>ChengDu China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        10
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        4
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        4
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/pigrange" target="_blank">
                关注我</a>
        </div>
        
        
    </div>
</div>
    
        
<div class="card widget column-left is-sticky" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                目录
            </h3>
            <ul class="menu-list"><ul class="menu-list"><li>
        <a class="is-flex" href="#大量文字预警！！！">
        <span class="has-mr-6">1.1</span>
        <span>大量文字预警！！！</span>
        </a></li><li>
        <a class="is-flex" href="#目录：">
        <span class="has-mr-6">1.2</span>
        <span>目录：</span>
        </a></li></ul><li>
        <a class="is-flex" href="#SetContentView">
        <span class="has-mr-6">2</span>
        <span>SetContentView</span>
        </a><ul class="menu-list"><ul class="menu-list"><li>
        <a class="is-flex" href="#setContentView-1">
        <span class="has-mr-6">2.1.1</span>
        <span>setContentView (1)</span>
        </a></li><li>
        <a class="is-flex" href="#setContentView-2">
        <span class="has-mr-6">2.1.2</span>
        <span>setContentView (2)</span>
        </a></li></ul><li>
        <a class="is-flex" href="#DeocrView的初始化：">
        <span class="has-mr-6">2.2</span>
        <span>DeocrView的初始化：</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#ensureSubDecor">
        <span class="has-mr-6">2.2.1</span>
        <span>ensureSubDecor</span>
        </a></li><li>
        <a class="is-flex" href="#createSubDecor">
        <span class="has-mr-6">2.2.2</span>
        <span>createSubDecor</span>
        </a></li><li>
        <a class="is-flex" href="#getDecorView">
        <span class="has-mr-6">2.2.3</span>
        <span>getDecorView</span>
        </a></li><li>
        <a class="is-flex" href="#installDecor">
        <span class="has-mr-6">2.2.4</span>
        <span>installDecor</span>
        </a></li><li>
        <a class="is-flex" href="#generateDecor">
        <span class="has-mr-6">2.2.5</span>
        <span>generateDecor</span>
        </a></li><li>
        <a class="is-flex" href="#generateLayout">
        <span class="has-mr-6">2.2.6</span>
        <span>generateLayout</span>
        </a></li><li>
        <a class="is-flex" href="#onResourcesLoaded">
        <span class="has-mr-6">2.2.7</span>
        <span>onResourcesLoaded</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#ContentView的添加：">
        <span class="has-mr-6">2.3</span>
        <span>ContentView的添加：</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#View的工作流程-Activity-Resume-：">
        <span class="has-mr-6">3</span>
        <span>View的工作流程(Activity#Resume)：</span>
        </a><ul class="menu-list"><ul class="menu-list"><li>
        <a class="is-flex" href="#handleResumeActivity">
        <span class="has-mr-6">3.1.1</span>
        <span>handleResumeActivity</span>
        </a></li><li>
        <a class="is-flex" href="#performResumeActivity">
        <span class="has-mr-6">3.1.2</span>
        <span>performResumeActivity</span>
        </a></li><li>
        <a class="is-flex" href="#performResume">
        <span class="has-mr-6">3.1.3</span>
        <span>performResume</span>
        </a></li><li>
        <a class="is-flex" href="#callActivityOnResume">
        <span class="has-mr-6">3.1.4</span>
        <span>callActivityOnResume</span>
        </a></li></ul></ul></li><li>
        <a class="is-flex" href="#View的工作流程-真-：">
        <span class="has-mr-6">4</span>
        <span> View的工作流程(真)：</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#源码分析：">
        <span class="has-mr-6">4.1</span>
        <span>源码分析：</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#handleResumeActivity-1">
        <span class="has-mr-6">4.1.1</span>
        <span>handleResumeActivity</span>
        </a></li><li>
        <a class="is-flex" href="#addView-1">
        <span class="has-mr-6">4.1.2</span>
        <span>addView (1)</span>
        </a></li><li>
        <a class="is-flex" href="#addView-2">
        <span class="has-mr-6">4.1.3</span>
        <span>addView (2)</span>
        </a></li><li>
        <a class="is-flex" href="#setView">
        <span class="has-mr-6">4.1.4</span>
        <span>setView</span>
        </a></li><li>
        <a class="is-flex" href="#requestLayout">
        <span class="has-mr-6">4.1.5</span>
        <span>requestLayout</span>
        </a></li><li>
        <a class="is-flex" href="#scheduleTraversals">
        <span class="has-mr-6">4.1.6</span>
        <span>scheduleTraversals</span>
        </a></li><li>
        <a class="is-flex" href="#mTraversalRunnable">
        <span class="has-mr-6">4.1.7</span>
        <span>mTraversalRunnable</span>
        </a></li><li>
        <a class="is-flex" href="#doTraversal">
        <span class="has-mr-6">4.1.8</span>
        <span>doTraversal</span>
        </a></li></ul></li></ul></li><li>
        <a class="is-flex" href="#补充：">
        <span class="has-mr-6">5</span>
        <span>补充：</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#Choreographer-postCallback">
        <span class="has-mr-6">5.1</span>
        <span>Choreographer.postCallback</span>
        </a></li><li>
        <a class="is-flex" href="#ViewParent-requestLayout">
        <span class="has-mr-6">5.2</span>
        <span>ViewParent#requestLayout</span>
        </a></li></ul></li></ul>
        </div>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                    
                    <img src="/assets/img/logo.jpg" alt="View工作流程[零]：从setContentView到measure" height="28" style="margin-left: 0.5em">
                    
                </a>
                <p class="is-size-7" style="padding-bottom: 0.5em">
                    <span id="timeDate" class="is-size-7"></span>
                    <span id="times" class="is-size-7"></span>
                </p>
                <p class="is-size-7">
                    &copy; 2019 John Pig&nbsp;
                    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                    
                </p>
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                <script>
                    var now = new Date();
                    function createtime() {
                        var grt = new Date("7/24/2019 16:00:00");//此处修改你的建站时间或者网站上线时间 
                        now.setTime(now.getTime() + 250);
                        days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                        if (String(hnum).length == 1) { hnum = "0" + hnum; } minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
                        mnum = Math.floor(minutes); if (String(mnum).length == 1) { mnum = "0" + mnum; }
                        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                        snum = Math.round(seconds); if (String(snum).length == 1) { snum = "0" + snum; }
                        document.getElementById("timeDate").innerHTML = "&nbsp;&nbsp" + "本站已安全运行 " + dnum + " 天 ";
                        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                    }
                    setInterval("createtime()", 250);
                </script>
            </div>
            <div class="level-end">
                
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"mobile":{"show":false},"model":{"scale":0.7,"jsonPath":"/live2dw/assets/hijiki.model.json"},"log":false});</script></body>
</html>