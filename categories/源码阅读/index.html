<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>分类: 源码阅读 - Pigrange&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta property="og:type" content="website">
<meta property="og:title" content="Pigrange&#39;s Blog">
<meta property="og:url" content="https://pigrange.github.io/categories/源码阅读/index.html">
<meta property="og:site_name" content="Pigrange&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://pigrange.github.io/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pigrange&#39;s Blog">
<meta name="twitter:image" content="https://pigrange.github.io/images/og_image.png">







<link rel="icon" href="/assets/img/logo.jpg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/assets/img/logo.jpg" alt="Pigrange&#39;s Blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">主页</a>
                
                <a class="navbar-item" href="/categories">分类</a>
                
                <a class="navbar-item" href="/archives">归档</a>
                
                <a class="navbar-item" href="/tags">标签</a>
                
                <a class="navbar-item" href="/about">关于我</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/categories">分类</a></li>
            
            <li class="is-active"><a href="#" aria-current="page">源码阅读</a></li>
        </ul>
        </nav>
    </div>
</div>

    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/23/View-process-2/">View工作流程[二]：Measure布局<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-23T06:35:36.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-23</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-24T12:21:56.389Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-24</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/源码阅读/View工作流程/">View工作流程</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 分钟 读完 (大约 2323 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p><em>我不管你看不看得懂，反正这一次我也没有看懂</em> 😭 <em>—— john pig</em></p>
<p>Android太难了。我太南了。</p>
<p>&lt;!-- more --&gt;</p>
<p><code>ViewRootImpl#PerformTraversals()</code>
<code>ViewRootImpl#performLayout(lp, mWidth, mHeight)</code>
<code>DecorView#layout()</code></p>
<p><strong>写在前面：</strong></p>
<p>这真的是到目前看的最累的一次，我，真的是看不下去了(我指的是ViewRootImpt的performLayout方法)，太难了，debug跳过去调过来的，递归看着是真的恼火，所以对那里某一些源码的部分描述我就打算说一个大概了。真的是在这个上面熬了不少的时间，但是我特么真的是看不懂啊，递归过去递归过来我怎么知道递归到那里去了呢？</p>
<p>其他的我也不做过多的描述了，个人觉得这篇文章长度虽然不多，但是内容信息量挺大，建议一遍DEBUG一边看。另外这篇文章的注释已经写的很详细了，就不做过多的文字描述了，后面如果有空的话，会补一个ViewGroup的onLayout方法的解析，今天太累了，就先🕊了。</p>
<h4>performLayout</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#performLayout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performLayout</span><span class="hljs-params">(WindowManager.LayoutParams lp, <span class="hljs-keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                           <span class="hljs-keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这个标识符用于标识此View是否在进行Layout</span></span><br><span class="line">    <span class="hljs-comment">//因为下一步就是进行Layout了，所以这里将其设置为true</span></span><br><span class="line">    mInLayout = <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里的Host就是我们的decorView</span></span><br><span class="line">    <span class="hljs-keyword">final</span> View host = mView;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//调用host的layout方法，即在这里调用DecorView的layout方法</span></span><br><span class="line">    host.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//Lyout完后将其设置为false</span></span><br><span class="line">    mInLayout = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//判断是否有View在进行Layout的过程中调用了RequestLayout方法</span></span><br><span class="line">    <span class="hljs-keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">    <span class="hljs-keyword">if</span> (numViewsRequestingLayout &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//过滤一些已经被解决的child view</span></span><br><span class="line">        ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                                                                         <span class="hljs-keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//将这个标志位置为True，作为requestLayout的一个判断标识</span></span><br><span class="line">            <span class="hljs-comment">//下面我们会调用缓存的View的requestLayout方法</span></span><br><span class="line">            <span class="hljs-comment">//由于之前的ViewTree的整个Layout已经结束了</span></span><br><span class="line">            <span class="hljs-comment">//所以Force_Layout标识已经被置为了0</span></span><br><span class="line">            <span class="hljs-comment">//所以之后View调用requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//条件判断mParent.isLayoutRequested()会返回false</span></span><br><span class="line">            <span class="hljs-comment">//这会导致整个ViewTree向上递归requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//最终调用ViewRootImpl的requestLayout方法</span></span><br><span class="line">            <span class="hljs-comment">//但是ViewRootImpl的requestLayout会导致</span></span><br><span class="line">            <span class="hljs-comment">//其performTraversal的调用，也就是说会导致</span></span><br><span class="line">            <span class="hljs-comment">//PerfromLayout这个方法被递归调用</span></span><br><span class="line">            <span class="hljs-comment">//考虑到性能的问题，有很多逻辑是不需要的</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//所以这个标识的作用就是拦截ViewRootImpl接受layout的请求</span></span><br><span class="line">            <span class="hljs-comment">//通过在performLayout中的某些逻辑来解决。</span></span><br><span class="line">            mHandlingLayoutInLayoutRequest = <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//遍历整个numValidRequests, 对每一个view调用requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//这里的requestLayout的作用是将其父View链的FORCE_LAYOUT标志位</span></span><br><span class="line">            <span class="hljs-comment">//全部设置为1，但是并不会真正的在这里对其layout</span></span><br><span class="line">            <span class="hljs-keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                <span class="hljs-keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                view.requestLayout();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//对ViewTree进行测量，注意，我们之前看过measure的代码知道</span></span><br><span class="line">            <span class="hljs-comment">//这里只有被标志位FORCE_LAYOUT的View才会再次被测量</span></span><br><span class="line">            <span class="hljs-comment">//也就是上面我们request的那个View链</span></span><br><span class="line">            measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                             desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//将Layout标识置为True，标识即将进行Layout</span></span><br><span class="line">            mInLayout = <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//进行ViewTree的再次Layout</span></span><br><span class="line">            <span class="hljs-comment">//这里如果child再次调用了requestLayout的话</span></span><br><span class="line">            <span class="hljs-comment">//处理策略一样，只把当前调用requestLayout的View</span></span><br><span class="line">            <span class="hljs-comment">//加入到mLayoutRequesters中即可，不会影响parent</span></span><br><span class="line">            host.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//将mHandlingLayoutInLayoutRequest置为false</span></span><br><span class="line">            <span class="hljs-comment">//这个时候前面的Layout已经完成了</span></span><br><span class="line">            mHandlingLayoutInLayoutRequest = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//这里的代码是用来解决View出现无尽的递归调用requestLayout的</span></span><br><span class="line">            <span class="hljs-comment">//比如上述layout中child又调用了requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//注释我看的不是很懂，主要是理解不到那个奇怪的 noop'd 是什么意思</span></span><br><span class="line">            <span class="hljs-comment">//不过我们可以猜测，大概就是Android对于这个重复无意义的requestLayout有检测机制</span></span><br><span class="line">            <span class="hljs-comment">//这里就是将这些View送给相关的判断逻辑</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//猜测用runnable queue的原因：</span></span><br><span class="line">            <span class="hljs-comment">//防止performLayout太耗时以至于系统卡顿或者长时间未响应</span></span><br><span class="line">            <span class="hljs-comment">//也算是一种优化策略吧</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//这里我有试过直接在View的onLayout里调用requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//最终发现ViewRootImpl的performLayout大概会在调用了3次后</span></span><br><span class="line">            <span class="hljs-comment">//就不会再调用了，可见这种无效的方法系统是有检测机制的</span></span><br><span class="line">            <span class="hljs-comment">//但是由于本人的能力有限，所以不做过多描述</span></span><br><span class="line">            validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="hljs-keyword">true</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                getRunQueue().post(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="hljs-meta">@Override</span></span><br><span class="line">                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                        <span class="hljs-keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                            <span class="hljs-keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                            Log.w(<span class="hljs-string">"View"</span>, <span class="hljs-string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                  <span class="hljs-string">" during second layout pass: posting in next frame"</span>);</span><br><span class="line">                            view.requestLayout();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//最后把mInLayout 置为false</span></span><br><span class="line">mInLayout =<span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>Layout</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//View#layout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT只有在之前的measure方法</span></span><br><span class="line">    <span class="hljs-comment">//直接拿的缓存设置的measuredWidth和measuredHeight的时候才会使用</span></span><br><span class="line">    <span class="hljs-comment">//这里不做过多的描述</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//记录之前的四个顶点</span></span><br><span class="line">    <span class="hljs-keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="hljs-keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="hljs-keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="hljs-keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//根据View是否具有光学边界，调用不同类型的setFrame方法</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//强调：View的四个顶点就是在这里面被确定的</span></span><br><span class="line">    <span class="hljs-comment">//但是这里面设置的此View的四个顶点的位置</span></span><br><span class="line">    <span class="hljs-comment">//对于哪些包含有child的View，可能还需要设置child的位置</span></span><br><span class="line">    <span class="hljs-comment">//而对child四个顶点位置的确定，我们就写在onLayout里面</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//这里返回的值是新的四个顶点是否和之前的四个顶点一样</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">        setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里我们先不管后面的标志</span></span><br><span class="line">    <span class="hljs-comment">//但是可以这么记一下，就是只要View被调用了measure</span></span><br><span class="line">    <span class="hljs-comment">//那么后面的条件就一定成立</span></span><br><span class="line">    <span class="hljs-comment">//而这里的changed主要是用来解决View仅改变了位置的情况</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//View里面什么都没有，但是个人觉得来说其实是比较重要的方法</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//对于自定义ViewGroup来说，这个方法是用于确定其child的位置</span></span><br><span class="line">        <span class="hljs-comment">//唯二实现方法，当然也可以重写layout（难度较大）</span></span><br><span class="line">        <span class="hljs-comment">//这里传入的四个参数是，ViewGroup的最新的四个顶点的位置</span></span><br><span class="line">        <span class="hljs-comment">//和它希望通知child自己是否位置改变的一个标识</span></span><br><span class="line">        <span class="hljs-comment">//~~后面想怎么搞child的位置就是开发者自己的事情了</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//补充：不建议在onLayout方法里面通过手动调用setFrame来让View</span></span><br><span class="line">        <span class="hljs-comment">//基于某一个初始位置有一个偏移量,虽然这样View的位置确实没有问题</span></span><br><span class="line">        <span class="hljs-comment">//但是会导致后面listener监听的位置有误</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//个人觉得比较理想的实现是在View的构造方法里手动加一个margin</span></span><br><span class="line">        <span class="hljs-comment">//这样才能从根本上(从通知parent上)解决问题</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//移除PFLAG_LAYOUT_REQUIRED标识</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//回调一些Listener的onLayoutChange方法</span></span><br><span class="line">        <span class="hljs-comment">//所以这里也可以拿得到View的坐标，宽高等属性</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                (ArrayList&lt;OnLayoutChangeListener&gt;) li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="hljs-keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="hljs-keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量和View焦点有关的代码</span></span><br><span class="line">    <span class="hljs-comment">//反正我又看不懂，放在那里凑字数吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>再探RequestLayout</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewParent#requestLayout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//首先，前面说过，这个方法在第一次performTraversal的时候一定不会被调用</span></span><br><span class="line">    <span class="hljs-comment">//这里说一下mViewRequestingLayout这个标识符</span></span><br><span class="line">    <span class="hljs-comment">//它用来标识整个ViewTree真正调用requestLayout的那个View</span></span><br><span class="line">    <span class="hljs-comment">//这里是true的话，就说明此次调用requestLayout的是整个</span></span><br><span class="line">    <span class="hljs-comment">//requestLayout事件链的罪魁祸首，需要对它进行一些特殊的处理</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//只要ViewRoot调用了layou方法，而child在layout中又调用了</span></span><br><span class="line">        <span class="hljs-comment">//requestLayout,那么这里的判断就是true，就会调用下面的</span></span><br><span class="line">        <span class="hljs-comment">//viewRoot.requestLayoutDuringLayout(this)方法</span></span><br><span class="line">        <span class="hljs-comment">//而这个方法的就是将这个view加入到mLayoutRequesters中的</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (viewRoot != <span class="hljs-keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="hljs-keyword">this</span>)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//因为上面有可能会return,这段语句和上面本来是没有关联的</span></span><br><span class="line">        <span class="hljs-comment">//但是如果上面return的话，可能会引起错误，所以就放下面</span></span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//将View的PFLAG_FORCE_LAYOUT置为1</span></span><br><span class="line">    <span class="hljs-comment">//将View的PFLAG_INVALIDATED置为1</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//INVALIDATED标识暂时还不清楚，不过猜测和View的重新绘制有关</span></span><br><span class="line">    <span class="hljs-comment">//FORCE_LAYOUT十分重要，它是这个View在后面的重新measure和layout</span></span><br><span class="line">    <span class="hljs-comment">//中是否真的需要被测量的定位的标识</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里的代码块是View递归向上传递requestLayout的关键</span></span><br><span class="line">    <span class="hljs-comment">//而这里的判断语句又是是否使得view向上传递事件的核心</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//isLayoutRequested 方法会判断其parent的FORCE_LAYOUT是否是1</span></span><br><span class="line">    <span class="hljs-comment">//如果其PARENT是在进行layout的话，那么FORCE_LAYOUT将会是1</span></span><br><span class="line">    <span class="hljs-comment">//这个标志位会在onLayout之后被重置为0，但是对child的layout是在</span></span><br><span class="line">    <span class="hljs-comment">//onLayout中实现的，所以这个时候FORCE_LAYOUT仍然是1</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里很好理解，把罪魁祸首的标识取消了，不做多的解释</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>补一个requetLayout方法的流程图：</p>
<p><img src="https://github.com/pigrange/pigrange.github.io/blob/master/assets/img/view-process-2/requestLayout.png?raw=true" alt></p>

        </div>
        
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/21/View-process-0/">View工作流程[零]：从setContentView到measure<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-21T15:53:50.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-21</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-24T12:21:46.366Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-24</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/源码阅读/View工作流程/">View工作流程</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 7477 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p><em>我不管你看不看得懂，反正只要我看得懂就行了  —— john pig</em></p>
<p>这篇文章按道理来说是不应该存在于这里的，但是出于总总原因，我不得不在这里插入这篇文章以作为后面需要了解内容的预备知识。</p>
<h3>大量文字预警！！！</h3>
<p>&lt;!-- more --&gt;</p>
<h3>目录：</h3>
<ul>
<li><strong><a href="#setcontentview">setContentView</a></strong>
<ul>
<li><strong><a href="#initdecor">DecorView的初始化</a></strong></li>
<li><strong><a href="#addcontent">ContentView的添加</a></strong></li>
</ul>
</li>
<li><strong><a href="#resume">Activity的resume</a></strong></li>
<li><strong><a href="#process">View的工作流程</a></strong></li>
<li><strong><a href="#additional">补充</a></strong>
<ul>
<li><strong><a href="#additional">Choreographer.postCallback</a></strong></li>
<li><strong><a href="#requestlayout">ViewParent#requestLayout</a></strong></li>
</ul>
</li>
</ul>
<p><strong>写在前面：</strong></p>
<p>在学习View的工作流程的时候，很多人都是直接从measure方法开始讲，或者稍微提到了从ViewRootImpl的performTraversal开始就不在详细说明了。确实Android源码是一个无底洞，深入进去往往无法自拔，很多东西抓住重点学习，可以快速熟悉整个系统的生态，不会在某些细枝末节的地方花上太多的时间。但是我始终觉得，这样学到的知识是零散的，导致我们很多时候很难将某些内容联系起来，这样显然对于Android的更加深入的理解是不利的。</p>
<p><strong>为什么我要将setContenView和measure一起讲：</strong></p>
<p>首先我要说明，这两者是没有关系的。setContentView方法是在Activity的onCreate中被调用的。我一直觉得Google的开发者真的是命名鬼才，对于方法的命名是非常精准的，所以我正好可以借助google的思路所作出强调：**setContentView就只做了setContentView，仅此而已 (所以千万不要像我一样在那里死磕setContentView在AppcompactActivity中的实现, 它其实对于View的工作流程没有任何关联。**而整个ViewTree的测量，定位，绘制是在Activity的onResume方法之后的某一个时刻被调用的，为什么是某一个时刻呢？因为这里用到了Handler，我们并不能确定handler具体处理整个message的时刻。</p>
<p><strong>但是! ! !</strong>，我在学习的过程中发现有不少blog是误导性或者甚至是有错的。他们都过多强调了Window.addView方法的功能，导致一些没有搞清Window和WindowManager的同学很容易在这里去纠结这个方法的具体实现，因为它们会觉得只要View和Window关联起来了，那么contentView在这里就成功的添加到了屏幕上了，所以可能会和我一样，傻乎乎的在setContentView里面去找半天ViewRootImpl的performTraversal方法，然而in vain。</p>
<p><strong>我的理解：</strong></p>
<ul>
<li>JAVA的锅。很大一部分原因是因为JAVA面向对象的语义太强了，导致开发者很容易沉迷于某一个封装好的类的功能中去。然而实际上对于对象来说，我们应重其成员而轻其方法，因为对于类结构，它的所有实例都是共享运行时常量池里方法的引用的。那么对于对象这个数据结构来说，其本质就是运行在堆空间的一块存放数据的内存。那么回到我之前谈的话题，setContentView做了什么事情？其实很简单，就是把ContentView这棵ViewTree挂载到了另一棵ViewTree上，组建成了我们最终需要的ViewTree（这里我们把所有的View就当作数据结构中树的最基本节点），那么核心方法是什么呢？两步：
<ul>
<li><code>parentView-&gt;child = contentLayout</code></li>
<li><code>contentLayout-&gt;parent = parentView</code></li>
</ul>
</li>
<li>Android View 设计的锅。先声明，我不是说View设计得不好哇，但是不得不吐槽，View实在是太臃肿了。一个最基本的控件居然有27753行代码，这也间接或直接得导致了许多人对其闻之色变，觉得View是一个又难又高深莫测的存在。个人觉得还是因为View的设计者太省事了，把一大堆方法都往View里面丢(虽然确实和View有关，但是个人觉得拆分成多个类的话可以更加凸显出View的职责)，这也直接导致我在学习整个Android的过程中一直认为View就是一个能够显示的控件，至于它如何被显示，因为它有draw方法，能够在canvas上面画它。其实这种解释是说的过去的，但是不严谨的，因为这会让人把屏幕上的显示的东西和View这个类(或者其实例)绑定在一起。但是，事实是View的显示或者如何做到在屏幕上显示和View的对象本身半毛钱关系的没有，View对象就是一个巨大（成员很多）的数据结构，存放了我们约定的那个逻辑上的视图的一堆信息，这些数据有也好，没有也罢，其实都不会对屏幕上的图像如何显示产生影响(这里要搞明白，我是指图像的产生的过程，也就是到底是怎么被绘制的，不是说图像的大小形状这些最终显现出来的特征)，因为View如何在屏幕上显示(绘制)是通过调用底层的Skia API实现的。</li>
</ul>
<p>回到最初的问题：在讲setContentView的具体实现之前，我们可以先给其一个不怎么准确但是比较好理解的定义：创建了contentView对象节点和其子View对象节点组成的一个树，(我们就把它们当作View类型的对象的数据结构)，并和PhoneWindow对象进行了关联（这里我刻意说明了对象这两个字，是想强调对象就是一块内存这个基本原则）。</p>
<p><strong>好了，不BB了，上代码。</strong></p>
<h2>&lt;span id=&quot;setcontentview&quot;&gt;SetContentView&lt;/span&gt;</h2>
<p>我们先来康康AppCompactActivity的SetContentView做了什么：</p>
<h4>setContentView (1)</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//AppCompactActivity#setContentView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是一脸蒙蔽，这个Delegate是啥？管它是啥，咱们继续往下看。getDelegate最终返回了mDelegate，而这里的delegate的实际类型是AppCompactDelegateImpl，我们再康康它的setContentView</p>
<h4>setContentView (2)</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// AppCompactDelegateImpl#setContentView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor(); #(1)</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    <span class="hljs-comment">//注意: 这个变量的名字为虽然叫contentParent</span></span><br><span class="line">    <span class="hljs-comment">//但是和后面提到的DecorView持有的contentParent并不是一个东西</span></span><br><span class="line">    <span class="hljs-comment">//为了防止和后面搞混，我在这里先统一规定contentParent为DecorView的child</span></span><br><span class="line">    <span class="hljs-comment">//而setContentView挂载的parent，我们将其称为ContentFrameLayout</span></span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent); #(2)</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果有看过activity的setContentView的朋友可能会觉得这里的代码似曾相识，但是我需要说明appCompactActivity远比ActivityView复杂，通过后面的分析，我们可以了解到，它其实在contentFrameLayout和DecorView之间还引入了两层ViewGroup，其分别是FrameLayout (就是我们后面会提到的subDecor)，和FitWindowsLimearLayout，也就是说，从AppComactActivity开始，我们的ContentFrameLayout并不是直接挂载到DecorView上的，而是挂载在FitWindowsLimearLayout上面的。</p>
<p><strong>另外，为了便于读者理解上面两个比较重要的方法的具体功能，我将下面的内容分成了DecorView的初始化和ContentView的挂载两个小标题。</strong></p>
<h3>&lt;span id=&quot;initdecor&quot;&gt;DeocrView的初始化：&lt;/span&gt;</h3>
<p>扯远了，我们着重康康ensureSubDecor的实现。</p>
<h4>ensureSubDecor</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//AppCompactDelegateImpl#ensureSubDecor</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureSubDecor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mSubDecorInstalled) &#123;</span><br><span class="line">        <span class="hljs-comment">//ensureSubDecor的核心是createSubDecor这个方法</span></span><br><span class="line">        mSubDecor = createSubDecor();</span><br><span class="line">        <span class="hljs-comment">//...下面的代码都是subDecor创建好了之后才有用的</span></span><br><span class="line">        <span class="hljs-comment">//不是重点，我们这里不做研究</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，里面调用了createSubDecor这个方法。(哈？为什么是subDecor，那我的DecorView呢？啥时候创建呢? )前面括号里的内容是我第一次看到这里时内心的感受，想必大多朋友和我一样蒙蔽，但是不要慌，咋们继续往下看。</p>
<p>说明一下，这个createSubDecor是一个长达222行代码超长方法，为了阅读体验和文章篇幅，我删掉了大量无关代码，并且对相关方法做了较为详细的描述。</p>
<h4>createSubDecor</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//AppCompactDelegateImpl#createSubDecor</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> ViewGroup <span class="hljs-title">createSubDecor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//这里的ensureWindow我们不用多管，对于普通的启动</span></span><br><span class="line">    <span class="hljs-comment">//我们默认Activity的phoneWindow在这之前就已经创建好了</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//PhoneWindow对象的创建是在Actvity的attach方法里面的</span></span><br><span class="line">    <span class="hljs-comment">//具体见ActivityThread#performLaunchActivity</span></span><br><span class="line">    <span class="hljs-comment">//里面调用了activity.attatch</span></span><br><span class="line">    ensureWindow();</span><br><span class="line">    mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> LayoutInflater inflater = LayoutInflater.from(mContext);</span><br><span class="line">    ViewGroup subDecor = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//下面的这整个代码块都是对subDecor进行创建的</span></span><br><span class="line">    <span class="hljs-comment">//本质是inflater解析xml文件生成View对象的过程</span></span><br><span class="line">    <span class="hljs-comment">//因为涉及到很多种场景，所以有很多判断逻辑</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!mWindowNoTitle) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                R.layout.abc_dialog_title_material, <span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            mHasActionBar = mOverlayActionBar = <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mHasActionBar) &#123;</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//...删了很多无关代码</span></span><br><span class="line">            subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                .inflate(R.layout.abc_screen_toolbar, <span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            mDecorContentParent = (DecorContentParent) subDecor</span><br><span class="line">                .findViewById(R.id.decor_content_parent);</span><br><span class="line">            mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//...删了很多无关代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mOverlayActionMode) &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                R.layout.abc_screen_simple_overlay_action_mode, <span class="hljs-keyword">null</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, <span class="hljs-keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删了很多无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...这里删除了大量的无关代码</span></span><br><span class="line">    <span class="hljs-comment">//但是我觉得有必要说一下</span></span><br><span class="line">    <span class="hljs-comment">//前面不是提到了AppCompatctActivtity在原来的基础上面又多了两层结构吗</span></span><br><span class="line">    <span class="hljs-comment">//subDecor是多的那一个FrameLayout，而真正持有contentFrameLayout的</span></span><br><span class="line">    <span class="hljs-comment">//是FitWindowsLinearLayout</span></span><br><span class="line">    <span class="hljs-comment">//这里删掉的代码就是和FitWindowsLinearLayout初始化有关的</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//将subDecor挂载在mWindow上</span></span><br><span class="line">    <span class="hljs-comment">//这里我并不想分析PhoneWindow的代码</span></span><br><span class="line">    <span class="hljs-comment">//因为转过去转过来很容易将人转晕</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//只是强调一下，mWindow本质上并不是View</span></span><br><span class="line">    <span class="hljs-comment">//而其setContentView会调用它持有的mContentParent的addView</span></span><br><span class="line">    <span class="hljs-comment">//而mWindow持有的mContentParent是我们在上面创建的DecorView的</span></span><br><span class="line">    <span class="hljs-comment">//一个名为contentParent的成员，其本身就是DecorView的一个child</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//复习一下：DecorView有两个child，一个是titleView，一个是contentParent</span></span><br><span class="line">    <span class="hljs-comment">//我们把SubDecor挂在DecorView上，实际上是把subDecor添加到了contentParent</span></span><br><span class="line">    <span class="hljs-comment">//这个FrameLayout里面</span></span><br><span class="line">    mWindow.setContentView(subDecor);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉一些没用的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> subDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码，我们可以知道，通过调用了mWindow.getDecorView()创建了DecorView的对象，同时通过ViewInflater创建了subDecor的对象。subDecor的工作流程在这里已经讲的特别清楚了(其实大多数都被我删掉了hhhh)，所以我们着重康康mWindow.getDecorView()这个方法。</p>
<p><strong>再次强调：上述方法完成很重要的两个任务：</strong></p>
<ul>
<li>创建了DecorView的对象</li>
<li>创建了subDecor的对象</li>
</ul>
<h4>getDecorView</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//PhoneWindow#getDecorView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">getDecorView</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mDecor == <span class="hljs-keyword">null</span> || mForceDecorInstall) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是做了一层封装，我们在康康installDecor方法。（又是一个200多行的方法，不过被删的只有3行，hhh</p>
<h4>installDecor</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//PhoneWindow#installDecor</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installDecor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//..删掉了大量的没啥卵用的代码</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//创建DecorView的对象</span></span><br><span class="line">    mDecor = generateDecor(-<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-comment">//创建contentParent的对象</span></span><br><span class="line">    mContentParent = generateLayout(mDecor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过重重删减后，可以看到，只剩下了俩方法了，通过名字我们可以了解到，这两个方法主要干了两件事情。</p>
<ul>
<li>生成了我们的DecorView的实例</li>
<li>生成了ContentParent的实际</li>
</ul>
<p>我们接下来就来康康generateDecor()到底是如何创建了DecorView的，同样为了阅读体验，我将代码中没有用的部分都删除了。</p>
<h4>generateDecor</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//PhoneWindow#generateDecor</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> DecorView <span class="hljs-title">generateDecor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">    <span class="hljs-comment">//...删掉了大量没啥用的代码</span></span><br><span class="line">    context = <span class="hljs-keyword">new</span> DecorContext(applicationContext, getContext());</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorView(context, featureId, <span class="hljs-keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，找了半天，我们终于找到了DecorView的创建了。挖了这么深，我们也该回头了，要不又得绕晕了hhhh。这个时候我们应该保持头脑清醒，告诉自己，这一切都是在AppCompactActivity的setContentView中被调用的。<strong>并且！</strong>，到目前为止，我们所作的一切工作都还是在为添加contentView做准备，而我们的主角 — contentView 还没有正式登场。</p>
<p><strong>先别急，都走到这一步了，回头之前，我们还是把最后一个坑填了，简单看看DecorView的contenParent是咋创建的</strong>，和前面一样，删掉大量无关代码。</p>
<h4>generateLayout</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//PhoneWindow#generateLayout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ViewGroup <span class="hljs-title">generateLayout</span><span class="hljs-params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量无关代码</span></span><br><span class="line">    <span class="hljs-comment">//emmm 其实有关的，上面的代码会决定下面会用到的layoutResource具体为</span></span><br><span class="line">    <span class="hljs-comment">//哪一个ID, 但是这里我们就不深入研究了，假装上面返回的是一个固定的值</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//contentParent实际产生的方法</span></span><br><span class="line">    <span class="hljs-comment">//具体的实现在DecorView内部，实际上就是通过layoutInflater</span></span><br><span class="line">    <span class="hljs-comment">//去解析xml构建了这个View实例,并且将其和DecorView进行关联</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup) findViewById(ID_ANDROID_CONTENT);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量有关contentParent初始化的代码</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以发现，contentParent的实际创建是在DecorView的onResourcesLoaded回调中完成的，既然都走到这一步了，我们干脆一气呵成，刨根问底，康康onResourcesLoaded是如何实现的。</p>
<h4>onResourcesLoaded</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//DecorView#onResourcesLoaded</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResourcesLoaded</span><span class="hljs-params">(LayoutInflater inflater, <span class="hljs-keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了多余的代码</span></span><br><span class="line">    <span class="hljs-keyword">final</span> View root = inflater.inflate(layoutResource, <span class="hljs-keyword">null</span>);</span><br><span class="line">    addView(root, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，看到这里，我们的思路就非常清晰了，其实就是在这个里面通过LayoutInflater 构建了我们的contentParent的实例，并且将其和DecorView关联。</p>
<p><strong>走到这一步，我们对整个DecorView的初始化就非常清楚了</strong>，接下来我们就需要具体康康contentView是如何挂载到我们的ContentFrameLayout上的，但是在这之前，<strong>我必须强调</strong>一下：我在上面的代码分析其实是有错误的，错误的位置是在DecorView的onResourcesLoaded中，实际上这里通过inflater产生的View并不是我们的contentParent，而是一个LinearLayout，我们所说的contentParent实际上是这个LinearLayout的child，但是为了便于大家理解，我在上面的描述中就刻意隐藏这个LinearLayout的存在。</p>
<p><strong>补充说明：在这篇文章中我并不打算谈论ActionBar或者ToolBar的存在</strong>。所以我这里的描述是有残缺的，主要还是怕一下子信息量太多难以理解，还有就是ActionBar的工作流程也比较复杂，值得单独写一篇文章来分析它的创建。</p>
<p>这里给一个网上找到的比较准确的View层级关系的图，图中是给出了ActionBar的位置的(黄色框框)，大家选择性忽略就好。(补充一个地方，图里FitWindowsLinearLayout外层的深色框框就是subDecorView没有标注出来，本质是一个FrameLayout)。</p>
<p><img src="https://github.com/pigrange/pigrange.github.io/blob/master/assets/img/ViewHierarchy.png?raw=true" alt></p>
<h3>&lt;span id=&quot;addcontent&quot;&gt;ContentView的添加：&lt;/span&gt;</h3>
<p>再次回到AppCompactDelegateImpl的setContentView方法</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//AppCompactDelegateImpl#setContentView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//ensureSubDecor();已经被调用了，我们不看了</span></span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里通过调用了LayoutInflater的inflate方法构建了我们的contentView(及其子View)的对象，并且将其添加到了我们的contentParent上，而这里的contentParent就是我们前面提及到的ContentFrameLayout.(注意这里的其实是给的contentView的xml的id)。</p>
<p><strong>由于上面就是一个很朴实的inflate方法，所以这里我就不多讲了。感兴趣的可以自己去了解一下inflate方法的具体实现。</strong></p>
<p><strong>再多BB一句，setContentView虽然初始化了，DecorView，但是ViewRootImpl还并未被初始化，并且这个时刻AttachInfo也是null.</strong></p>
<h2>&lt;span id=&quot;resume&quot;&gt;View的工作流程(Activity#Resume)：&lt;/span&gt;</h2>
<p>这里的View工作机制就是我们所说的测量，定位，以及绘制的流程，但是这里我并不会去讲那三大方法，接下来我会单独写文章去研究它们的代码。前面的文章(View工作流程[一])以及说明了这三大方法会在ViewRootImpl的performTraversal调用，那么这里我们就继续追根溯源，康康ViewRootImpl到底是在什么时候被创建的，它的performTraversal又是在啥时候被调用的呢？这些时间点又处于Activity生命周期的哪个时刻呢？</p>
<p><strong>首先说明，和前面刨根问底不同，接下来我们要做的是追根溯源，所以这里我们是向上层层递归，去寻找performTraversal的最初调用，这个其实很容易，debug观察内存栈帧就明白了。为了方便起见，我还是自顶向下的讲解。</strong></p>
<h4>handleResumeActivity</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ActivityThread#handleResumeActivity</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                 String reason)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量没有用的代码</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...并且，先不要管后面的代码！！！</span></span><br><span class="line">	<span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//强调：实际上ViewRootImpl就是在这后面被创建的，但是我们先不忙看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果有留意我注释的朋友一定会说：“你这不坑我吗？前面没有用的你让我看，后面有用的你告诉我现在不看？”</p>
<p>先不要激动，没看到我上面写了个大大的Activity#Resume吗？如果你不耐烦的话，可以点击**<a href="#process">这里</a>**跳转到和View工作流程直接相关的内容。这里，我主要还是想顺带的复习一下Activity的onResume的具体调用逻辑(因为都是在一起的，顺带一起复习了，这样也能加深印象，对View的工作流程的开始位置有一个更加深入的了解，嘿嘿嘿)。</p>
<h4>performResumeActivity</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ActivityThread#performResumeActivity</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityClientRecord <span class="hljs-title">performResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                                  String reason)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="hljs-comment">//...删除了大量没啥关联的代码</span></span><br><span class="line">    r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>performResume</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Activity#performResume</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performResume</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//这个方法我没有删，主要是觉得有必要留意一些</span></span><br><span class="line">    <span class="hljs-comment">//没错它就是第一个被调用的。。。</span></span><br><span class="line">    <span class="hljs-comment">//而在performRestart里面，又依次调用了</span></span><br><span class="line">    <span class="hljs-comment">//(1)、mInstrumentation.callActivityOnRestart() --&gt; onRestart</span></span><br><span class="line">    <span class="hljs-comment">//(2)、performStart() --&gt; onStart</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    performRestart(<span class="hljs-keyword">true</span> <span class="hljs-comment">/* start */</span>, reason);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    mInstrumentation.callActivityOnResume(<span class="hljs-keyword">this</span>);</span><br><span class="line">	<span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量的无关的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>callActivityOnResume</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Instrmentation#callActivityOnResume()</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnResume</span><span class="hljs-params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.mResumed = <span class="hljs-keyword">true</span>;</span><br><span class="line">    activity.onResume();</span><br><span class="line">    <span class="hljs-comment">//... 删掉大量无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，到目前位置，Activity的onResume如何被调用的我们也了解了。那么接下来，我们正式的康康handleResumeActivity中被抹去的代码吧。</p>
<h2>&lt;span id=&quot;process&quot;&gt; View的工作流程(真)：&lt;/span&gt;</h2>
<h3>源码分析：</h3>
<h4>handleResumeActivity</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ActivityThread#handleResumeActivity</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                 String reason)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="hljs-keyword">if</span> (r.window == <span class="hljs-keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//获取DecorView并设置相关属性</span></span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//获取WindowManager</span></span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//准备将decorView添加到windowManger中</span></span><br><span class="line">        <span class="hljs-comment">//所以这里要创建一个WindowManager.LayoutParams</span></span><br><span class="line">        <span class="hljs-comment">//并设置相关的属性</span></span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删掉了大量无关的代码</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//将decorView添加到WindowManager中</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="hljs-keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删掉了大量无关的代码</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述的代码块中出现了WindowManager，并且将我们的decorView添加到了WindowManager里，那你肯定想问: &quot;妈的，那我的phoneWindow就这样不管了吗？“ 我只能这么回答，是的，因为后面真的就没有它什么事情了。View层级结构的PhoneWindow是一个很抽象的概念它始终给我们一种可有可无的感觉。</p>
<p>如果你要问PhoneWindow有什么作用，我可以这么回答：给整个ViewTree(注意这里不指某个节点，研究对象是整个ViewTree)提供了一个对外统一的API(再次注意，这里是面向用户对ViewTree的操作，) ，换句话说就是PhoneWindow是对整个View的层级结构的一层封装(隐藏了内部实现)，它本身不可见，也不是View层级结构中的一员。</p>
<p>我再举一个更详细的例子，比如JAVA中的LinkedList。我们知道LinkedList内部是由链表实现的，但是我们把它当集合框架的时候只会去研究某一个具体的节点或者整个链表整体的属性，对于大多数人，它们不会关心整个链表的逻辑结构(对应这里的ViewTree)，也不会去关系链表的头节点(对应这里的DecorView)，它们只会使用LinkedList这个类的实例(对应这里的phoneWindow)，或者研究某一个节点的属性或值(LinkedList的第 i 个元素)。</p>
<p><strong>插入中断：谈一谈WindowManager</strong></p>
<p>因为个人觉得在描述了PhoneWindow的作用后再去看WindowManager的职责就很清晰了，所以决定在这里强行插入关于WindowManger的解释。</p>
<p>前面提到，我们可以把PhoneWindow类别成一个LinkedList。然后我们再回到Android里，显然每一个Acitivity都会有这么一个PhoneWindow与之对应。但是我们的应用有可能会由很多个Activity哇，也就是说会有很多个PhoneWindow哇，所以是不是又需要一个组件来存储和管理这一系列的PhoneWindow呢，而提供这个功能的组件就是我们的WindowManager，（这也是为什么对于一个Application，WindowManager是一个全局的单例，因为只会用的到一个呀😂）。</p>
<p>另外再解释一下为什么这里WindowManger添加的是DecorView，还是基于上面链表的例子，对于一个存放所有链表的数据结构，它里面存放所有链表封装的抽象(LinkedList)或者第一个元素(DecorView)本质是一样的。但是上面我也说了，WindowManger不仅仅只是存储，它也有管理的功能，而它对ViewTree的管理肯定是依附于其节点的，通过查看PhoneWindow的API我们知道其实PhoneWindow的功能是很受限制的，所以要实现更多的功能，肯定还是直接管理节点更加方便，而WindowManger对ViewTree的管理，就是通过ViewRootImpl来实现的，或者说WindowManager把ViewTree的管理托付给了ViewRootImpl来替它完成。</p>
<p>我们再审视一下ViewRootImpl和PhoneWindow的功能：</p>
<ul>
<li>本质都是对ViewTree进行管理的类</li>
<li>ViewRootImpl是面向WindowManager的</li>
<li>PhoneWindow是面向用户的</li>
<li>ViewRootImpl倾向于对ViewTree的工作流程的管理</li>
<li>PhoneWindow倾向于对ViewTree的信息的管理</li>
</ul>
<p><strong>又扯远了</strong></p>
<h4>addView (1)</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//WindwowManager#addView</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们可以看到，WindowManager的addView，内部调用了WindowManagerGlobal的addView方法。</p>
<h4>addView (2)</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//WindwowManagerGlobal#addView</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                    Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量无关代码</span></span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删掉了大量无关代码</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//初始化ViewRootImpl的对象</span></span><br><span class="line">        root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        <span class="hljs-comment">//将DecorView的LayoutParams设置为WindowManager关联的LayoutParams</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="hljs-comment">//将DecorView添加到WindowManager的mView中</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        <span class="hljs-comment">//将和此DecorView关联的ViewRootImpl添加到mRoots中</span></span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        <span class="hljs-comment">//将和此DecorView关联的LayoutParams添加到mParams中</span></span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">        <span class="hljs-comment">//将DecorView与ViewRootImpl进行关联</span></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...删掉了大量无关的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的内容也是十分清晰，其实mViews , mRoots , mParams 都是数组，所以我们暂时不管。需要留意的是ViewRootImpl是在这里被初始化的，而ViewRootImpl的构造方法到底干了什么事情我们先不管，但是可以了解一点，和此Activity关联的attachInfo是在ViewRootImpl的构造方法里面被创建的。</p>
<p>然后我们着重来看看ViewRootImpl的setView方法。</p>
<h4>setView</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#setView</span></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* We have one child   &lt;--- 我觉得这个注释很有意思，就保留了</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mView == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//...省略了大量无关(其实很重要的)代码</span></span><br><span class="line">            <span class="hljs-comment">//主要是对View的AttachInfo进行相关属性的初始化</span></span><br><span class="line">           </span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//注意：！！！</span></span><br><span class="line">            <span class="hljs-comment">//这个方法就是整篇文章的重点了</span></span><br><span class="line">            requestLayout();</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//...后面的代码就先不管了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>终于看到了一个我们非常熟悉的方法了，似乎也开始有头绪了，那么我们就再来康康ViewRootImpl的reuestLayout()到底做了什么吧。</p>
<h4>requestLayout</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#requestLayout</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="hljs-keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线索越来越清晰了！！！，我们继续康康 scheduleTraversals 方法。</p>
<h4>scheduleTraversals</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#scheduleTraversals</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);</span><br><span class="line">    	<span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//...省略没有必要的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仿佛失去方向了，但是注意看mChoreographer，它调用了一个postCallBack方法，而这个方法里面的参数有一个名字带有runnable关键字的变量，那么它是什么呢？</p>
<h4>mTraversalRunnable</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#mTraversalRunnable</span></span><br><span class="line"><span class="hljs-keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="hljs-keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原来这家伙是就是一个封装了doTraversal方法的runnable哇 , 是不是线索又变得清晰了起来~~~</p>
<h4>doTraversal</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="hljs-keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//小老弟，看这里。是不是横竖都写着call me here. 😁</span></span><br><span class="line">        performTraversals();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//...省略一些代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ok，总算是找到了。 这样一来，我们的整个逻辑就被打通了，也就是说从这里开始，就进入了View真正的工作流程。</p>
<p>(累死了，这里我就先不忙画流程图了，真的是没时间哇，挖个坑，以后填。)</p>
<h2>&lt;span id=&quot;additional&quot;&gt;补充：&lt;/span&gt;</h2>
<h3>Choreographer.postCallback</h3>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Choreographer#postCallBack</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到postCallback内部调用了postCallbackDelayed() , 是不是感觉似曾相识？没错我就是说的Handler！我们继续来康康postCallbackDelayed的实现。</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Choreographer#postCallbackDelayed</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCallbackDelayed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType,Runnable action, Object token, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">	<span class="hljs-comment">//...删掉部分没啥用的代码</span></span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>postCallbackDelayed内部又调用了postCallbackDelayedInternal。emmm 没啥，这种写法谁没见过，咋们继续往下看，再来研究研究postCallbackDelayedInternal。</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Choreographer#postCallbackDelayedInternal</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCallbackDelayedInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType,Object action,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                         Object token, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...删掉一些没啥用的判断</span></span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//...删掉一些没啥用的判断</span></span><br><span class="line">        Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">        msg.arg1 = callbackType;</span><br><span class="line">        msg.setAsynchronous(<span class="hljs-keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是觉得柳暗花明了，如果你还没有明白的话，请注意上面代码的下部分，那可是handler呀！！</p>
<p>好了，我也不多BB了，这段代码其实很简单，虽然Choreographer这个类做了很好的封装，但是其实本质上还是通过Handler实现的，只不过这里并没有直接把runnable封装到msg中，而是单独搞了一个mCallbackQueue，将runnable缓存在里面，然后让handler获取到<code>MSG_DO_SCHEDULE_CALLBACK</code>这个消息的时候，就去队列里面取出来运行...</p>
<p>至于为什么要这么做，我们这里就不多做研究了(坑是填不完的 _ <em>(:з)∠)</em> _   )...</p>
<h3>&lt;span id=&quot;requestlayout&quot;&gt;ViewParent#requestLayout&lt;/span&gt;</h3>
<p>我觉得很有必要把requestLayout拿出来讲一讲，因为看书学习的时候，我们会被灌输requestLayout将会导致整个ViewTree重新绘制的观点，而由于我们并不是很了解其实现，所以往往会对其功能产生固化的观点，甚至会情不自禁将其和View的三大工作流程联系起来。虽然事实是这样没错，但是在某一些场景下，这种惯性思维将会使我们误入歧途。</p>
<p>**比如：**在setContentView中，我们其实是可以发现内部实现是由多次调用requestLayout这个方法的，如果你对这个方法了解不够具体，仅仅知道它会导致ViewTree的重新绘制，那么你可能就会像我一样拼命的去寻找它是在哪里让View重绘的，或者去思考它到底在哪里调用ViewRootImpl的方法。诚然，这种思路是一点问题的都没有的，但是我们犯了一个原则性的错误，就是在Activity的onCreate方法里面ViewRootImpl其实是还并未被初始化的(惊不惊喜，意不意外！)。所以在这里调用的requestLayout方法根本就不会导致整个ViewTree的重绘！！！</p>
<p>**所以：**requestLayout导致ViewTree重绘一定是建立在DecorView被添加到WindowManagerGlobal之后这个前提条件的。</p>
<p>最后，我们再来分析一些下requestLayout的实现：</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewParent#requestLayout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉这里用不到的代码块</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里的逻辑很简单，向上递归调用parent的requestLayout</span></span><br><span class="line">    <span class="hljs-comment">//但是我们要注意，这里的mParent并不是View</span></span><br><span class="line">    <span class="hljs-comment">//而是一个ViewParent的接口，所有的View和ViewRootImpl都实现了它</span></span><br><span class="line">    <span class="hljs-comment">//这也是为什么DecorView能够调用ViewRootImpl的requestLayout的原因</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//在Activity的onCreate方法里，由于ViewRootImpl为空</span></span><br><span class="line">    <span class="hljs-comment">//所以这个方法的递归掉用都会在DecorView处终止</span></span><br><span class="line">    <span class="hljs-comment">//所以，(在这种情况下)并不会导致ViewTree的重绘</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        </div>
        
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/19/View-process-1/">View工作流程[一]：Measure测量<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-19T10:49:53.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-19</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-24T12:21:52.931Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-24</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/源码阅读/View工作流程/">View工作流程</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16 分钟 读完 (大约 2337 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p><em>我不管你看不看得懂，反正只要我看得懂就行了  —— john pig</em></p>
<h4>写在前面：</h4>
<p>哭了，本来打算想先了解了解setContentView，如果内容不多的话，就放在这里和View的measure(准确的说应该是ViewRootImpl#PerformTraversals) 一起来讲的，结果debug看了一晚上，发现AppCompactActivity在DecorView和FrameContent之间又加了2层，找了一晚上的PhoneWindow的setContentView，结果搞了个subDecor。难受得一批。</p>
<p>现在的心情就是填坑，填着填着发现这是一个无底洞。。。_ <em>(:з)∠)</em> _</p>
<p>&lt;!-- more --&gt;</p>
<p><strong>好吧，又挖一个坑。争取本周之前把ContentView和View的工作流程都撸出来吧...(得找个时间学一下UML图</strong></p>
<p>本来打算把整个View的事件流程写到一篇文章的，但是工作量巨大，并且很有可能字数劝退。所以干脆分开，这样的话你们看起来也舒服，我写起来也高产(雾)，实不相瞒，还是因为这个坑太深了，不知道什么时候才填的完，所以能写一点是一点，一步一个脚印，做起来也更容易，看起来也更有成就感(嘿嘿嘿)。</p>
<p>我先说一个基本原则，对于普通的View它的measure方法一定是被其parent调用的(ViewTree的递归调用)，所以研究ViewTree的某一个节点的意义不大，所以我这里我贴一个DecorView的measure是如何被调用的，这样对于整个View工作流程的开端有一个较为准确的认识.</p>
<ol>
<li><code>ViewRootImpl#PerformTraversals()</code></li>
<li><code>ViewRootImpl#measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight)</code></li>
<li><code>ViewRootImpl#getRootMesasureSpec(windowSize,rootDimension)</code></li>
<li><code>ViewRootImpl#performMeasure(childWidthMeasureSpec, childHeightMeasureSpec)</code></li>
<li><code>DecorView#measure(childWidthMeasureSpec, childHeightMeasureSpec)</code></li>
<li><code>View#measure(childWidthMeasureSpec, childHeightMeasureSpec)</code></li>
</ol>
<h4>View.java#measure()</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//判断当前View是否有光学边界</span></span><br><span class="line">    <span class="hljs-comment">//我并不知道光学边界有什么用，但是这并不妨碍我们对源码的解读</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> optical = isLayoutModeOptical(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-comment">//对于DecorView，其ViewParent是PhoneWindow</span></span><br><span class="line">    <span class="hljs-comment">//这里对于DecorView和其Parent都是返回的false</span></span><br><span class="line">    <span class="hljs-comment">//所以下面的不等条件不成立，不进入下面代码块</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//这里判断一下parent是否和自己一样是使用了有光学边界的View</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        <span class="hljs-keyword">int</span> oWidth = insets.left + insets.right;</span><br><span class="line">        <span class="hljs-keyword">int</span> oHeight = insets.top + insets.bottom;</span><br><span class="line">        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);</span><br><span class="line">        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//讲widthMeasureSpec和heightMeasureSpec组合成一个64位长的数据</span></span><br><span class="line">    <span class="hljs-comment">//用于键，后面我们可以看到，其实View是有缓存了measuredWidth和measuredHeight的</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//这里可以先说明一下</span></span><br><span class="line">    <span class="hljs-comment">//key: widthMeasureSpec和heightMeasureSpec的组合</span></span><br><span class="line">    <span class="hljs-comment">//value: measuredWidth 和 measureHeight的组合</span></span><br><span class="line">    <span class="hljs-keyword">long</span> key = (<span class="hljs-keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="hljs-number">32</span> | (<span class="hljs-keyword">long</span>) heightMeasureSpec &amp; <span class="hljs-number">0xffffffffL</span>;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//基于这个方法我们可以知道View的测量是有缓存机制的。</span></span><br><span class="line">    <span class="hljs-comment">//如果mMeasureCache为空的话，就初始化一个长度是2的数组来缓存</span></span><br><span class="line">    <span class="hljs-comment">//widthMeasureCache和heightMeasureCache</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mMeasureCache == <span class="hljs-keyword">null</span>) mMeasureCache = <span class="hljs-keyword">new</span> LongSparseLongArray(<span class="hljs-number">2</span>);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//强制Layout的一个标志位，字面意思。apib被隐藏了的</span></span><br><span class="line">    <span class="hljs-comment">//不是很清楚这个标志位具体有什么作用</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//字面意思，判断View的spec是否改变。</span></span><br><span class="line">    <span class="hljs-comment">//如果没有改变的话，应该会省不少事情 嘿嘿嘿</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> specChanged = widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">        || heightMeasureSpec != mOldHeightMeasureSpec;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">// 判断View的measureMode是否是EXACTLY</span></span><br><span class="line">    <span class="hljs-comment">//注意，对于DecorView，其MeasureSpec是在ViewRootImpl中产生的</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">        &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//判断当前的View的MeasuredSize时候和MeasureSpec传递下来的值是一样</span></span><br><span class="line">    <span class="hljs-comment">//这个标志主要是用于在之后View树重绘的时判断View的大小是否改变</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//根据前面的几个标志信息，判断这个View是否需要重新(被)布局</span></span><br><span class="line">    <span class="hljs-comment">//对于第一次测量，这个标志位一定是返回的true</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> needsLayout = specChanged</span><br><span class="line">        &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//首先说明：View的onMeasure方法是在这个代码块里面被调用的</span></span><br><span class="line">    <span class="hljs-comment">//通过上面的判断我们知道</span></span><br><span class="line">    <span class="hljs-comment">//对于一个mesureMode是Exactly并且大小并没有改变的View</span></span><br><span class="line">    <span class="hljs-comment">//needsLayout是false,</span></span><br><span class="line">    <span class="hljs-comment">//也就是说其onMeasure方法并不会被再次调用</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//相反的，如果view需要layout的话，就进入此代码块</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//注意：这里是needLayout，而这里实际上是measure的方法块</span></span><br><span class="line">    <span class="hljs-comment">//所以View本身的大小是没有改变的，对于非ForceLayout来说</span></span><br><span class="line">    <span class="hljs-comment">//可以直接使用之前缓存了的结果</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//清理掉之前的状态标志</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//解析所有的RTL相关的属性</span></span><br><span class="line">        <span class="hljs-comment">//RTL就是从右到左的意思，这里不用多管，好像有些国家对界面的使用习惯</span></span><br><span class="line">        <span class="hljs-comment">//和我们是反的，所以对于布局需要修改一下</span></span><br><span class="line">        resolveRtlPropertiesIfNeeded();</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//如果是强制layout的话，会放弃缓存里的内容</span></span><br><span class="line">        <span class="hljs-comment">//下面的代码我们可以看到，如果cacheIndex是-1那么就重新调用onMeasure</span></span><br><span class="line">        <span class="hljs-comment">//注意：View的setDimension是在onMeasure中完成的</span></span><br><span class="line">        <span class="hljs-keyword">int</span> cacheIndex = forceLayout ? -<span class="hljs-number">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">// 这里解释一下sIgnoreMeasureCache标志</span></span><br><span class="line">        <span class="hljs-comment">//当Android的版本小于19的话，这个标志就会被置为true</span></span><br><span class="line">        <span class="hljs-comment">//也就是api小于19的话，是不会使用缓存的宽高</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (cacheIndex &lt; <span class="hljs-number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//privateFlag我们不做详细了解</span></span><br><span class="line">            <span class="hljs-comment">//但是这里需要明白：这里将PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT</span></span><br><span class="line">            <span class="hljs-comment">//这个标志清除了即可</span></span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//获取缓存的measuredWidth和measuredHeight</span></span><br><span class="line">            <span class="hljs-keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//直接使用缓存的measure来作为尺寸</span></span><br><span class="line">            <span class="hljs-comment">//那么我们可以推测，这里缓存的并不是通过measureSpec计算出来的值</span></span><br><span class="line">            <span class="hljs-comment">//而是通过调用setDimension的最终值</span></span><br><span class="line">            setMeasuredDimensionRaw((<span class="hljs-keyword">int</span>) (value &gt;&gt; <span class="hljs-number">32</span>), (<span class="hljs-keyword">int</span>) value);</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//由于onMeasure方法会最终调用setMeasuredDimensionRaw</span></span><br><span class="line">        <span class="hljs-comment">//而上述方法一定会将PFLAG_MEASURED_DIMENSION_SET设置</span></span><br><span class="line">        <span class="hljs-comment">//也就是这里的代码块是setMeasuredDimensionRaw失败调用时异常通知的</span></span><br><span class="line">        <span class="hljs-comment">// （ 不过我想不到setMeasuredDimensionRaw会失败调用的场景</span></span><br><span class="line">        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"View with id "</span> + getId() + <span class="hljs-string">": "</span></span><br><span class="line">                                            + getClass().getName() + <span class="hljs-string">"#onMeasure() did not set the"</span></span><br><span class="line">                                            + <span class="hljs-string">" measured dimension by calling"</span></span><br><span class="line">                                            + <span class="hljs-string">" setMeasuredDimension()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//缓存measureSpec</span></span><br><span class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//缓存测量之后的宽和高</span></span><br><span class="line">    mMeasureCache.put(key, ((<span class="hljs-keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="hljs-number">32</span> |</span><br><span class="line">                      (<span class="hljs-keyword">long</span>) mMeasuredHeight &amp; <span class="hljs-number">0xffffffffL</span>); <span class="hljs-comment">// suppress sign extension</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>View.java#onMeasure()</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//可以看到View的onMeasure方法里面很简单</span></span><br><span class="line">    <span class="hljs-comment">//就调用了一个setMeasuredDimension方法</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//而setMeasuredDimension内部调用了setMeasuredDimensionRaw</span></span><br><span class="line">    <span class="hljs-comment">//所以我们暂时就认为View的宽高的设置就是通过setMeasureDimension完成的</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//这里我们重点分析一下getSuggestedMinimumWidth()</span></span><br><span class="line">    <span class="hljs-comment">//以及getDefaultSize()</span></span><br><span class="line">    setMeasuredDimension(</span><br><span class="line">        getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>View.java#getSuggestedMinimumWidth()</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 这里的代码写的比较的难读，所以我重写了一下</span></span><br><span class="line"><span class="hljs-comment">* 不过这里建议不要太留意代码里面的内容</span></span><br><span class="line"><span class="hljs-comment">* 而应该着重放法名的含义：获取此View能够接受的最小宽度</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuggestedMinimumWidth</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> result;</span><br><span class="line">    <span class="hljs-comment">//如果有背景的话，那么宽度就是背景宽度和自己宽度的最大值</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mBackground != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        result = max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">//如果没有背景的话，那么能够接受的最小宽度就是mMinWidth</span></span><br><span class="line">        res = mMinWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>View.java#getDefaultSize()</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * View最终确定自己的大小的方法，这里返回的结果就是View在本次测量的最终大小了</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> size : getSuggestedMinimumWidth返回的结果，也就是View能够接受的最小的大小</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> measureSpec : parent传递下来的值，用于通知View最终的测量模式和parent建议的值</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDefaultSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">// size是getSuggestedMinimumWidth返回的结果</span></span><br><span class="line">    <span class="hljs-keyword">int</span> result = size;</span><br><span class="line">    <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">// specSize是parent的建议值</span></span><br><span class="line">    <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//通过这里我们可以看到，一般来说，child是很听parent的建议的</span></span><br><span class="line">    <span class="hljs-comment">//对于AT_MOST和EXACTLY都是直接设置parent建议的大小(注意这里我们不考虑ViewGroup)</span></span><br><span class="line">    <span class="hljs-comment">//只有在specMode是UNSPECIFIED的时候child才会采用自己的最小值</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//补充一下：子View的specMode的UNSPECIFIED只会继承自parent</span></span><br><span class="line">    <span class="hljs-keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>写到最后：</strong></p>
<p>前面有提到，这些源码的阅读其实是同步《开发艺术探索的》的阅读的。我觉得有必要指出刚哥在书里面提到的 &quot;ViewGroup提供了一个measureChildren方法来测量它的child&quot; 这个观点，其实看了源码我们知道，虽然确实ViewGroup有提供此方法，但是它并没有调用此方法，并且对于ViewGroup的大多实现，它们都是直接在onMeasure里面实现了自己对于Child的测量措施。所以对于ViewGroup的实现，我们不应该刻意去强调它的存在，更多的是把它当作一个通用解决方案或者一种保守策略。比如说当我们自己实现ViewGroup的时候，可以考虑在onMeasure调用measureChildren，来降低我们直接实现的成本开销。</p>
<p>我其实有考虑补一个ViewGroup派生类的onMeasure方法，比如说LinearLayout或者ConstraintLayout，但是粗略看了一下，代码多得吓人，无奈本人时间有限外加这些特定ViewGroup的功能专一性，浪费时间在它们源码的解读上实在有点亏。(千真万确，逃~~~)</p>

        </div>
        
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/16/ViewEvent/">这是一篇非常详细的View事件分发机制的源码分析文章<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-16T08:31:58.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-16</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-24T12:22:09.078Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-24</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/源码阅读/View事件分发机制/">View事件分发机制</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 6697 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p><em>我不管你看不看得懂，反正只要我看得懂就行了  —— john pig</em></p>
<p>为了准备接下来的面试，这几天又在看《开发艺术探索》，老觉得View的事件流程看的不是很明白，索性干脆直接上源码刨根问底，肝了两天，终于是对View的事件流程有一个详细的了解。</p>
<p>本来打算像其他的大佬一样把源码拆开，结合图文描述关键方法的。但是发现这样做很难弄清整个流程的具体逻辑，脑子里可能就一个大致的流程图，也就逮住几个关键方法侃侃而谈。这样做或许可以快速了解，但是由于没有深入，始终不能留下深刻的印象。并且对于我自己来说，本来就对着整个流程了解不够清晰，一口气看完来写想必会忘记不少细节；而一边看一边写又容易分心，并且很容易纠结某一个细枝末节的东西而失去整体的框架。</p>
<p><strong>好了，废话不多说。请慢慢 read the fucking code 吧</strong></p>
<p>&lt;!-- more --&gt;</p>
<h2>ViewGroup的dispatchTouchEvent()</h2>
<p><strong>ViewGroup.java#dispatchTouchEvent()</strong></p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//省略掉开头的一些看不懂的代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//dispathcTouchEvent的返回值</span></span><br><span class="line">    <span class="hljs-comment">//用于表示当前的View(ViewGroup是否消耗了此次点击事件)</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> handled = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//一个安全策略，主要用于过滤屏保的时候的点击事件的分发</span></span><br><span class="line">    <span class="hljs-comment">//如果被拦截了，那么dispatchTouchEvent直接返回false</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// ACTION_DOWN的时候，会将之前的状态清理</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// FLAG_DISALLOW_INTERCEPT会被重置为空</span></span><br><span class="line">            <span class="hljs-comment">// mFirstTouchTarget在这个方法中被重置为空</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 用于判断此ViewGroup是否拦截这个事件</span></span><br><span class="line">        <span class="hljs-comment">// 两种类情况</span></span><br><span class="line">        <span class="hljs-comment">// (1)、MotionEvent.ACTION_DOWN,即这是一次点击的事件(按下去,还未抬手)</span></span><br><span class="line">        <span class="hljs-comment">// (2)、mFirstTouchTarget != null：首先说明，这种情况一定不是ActionDown(不考虑多点)</span></span><br><span class="line">        <span class="hljs-comment">// 有可能是ACTION_MOVE 或者 ACTIION_UP</span></span><br><span class="line">        <span class="hljs-comment">// 同时也表示了此ViewGroup在最近的一次ACTION_DOWN事件</span></span><br><span class="line">        <span class="hljs-comment">// 所导致的dispatchTouchEvent返回的结果是true。</span></span><br><span class="line">        <span class="hljs-comment">// (因为如果是False的话,那么DecorView的mFirstTouchTarget是空的,后续的点击事件就不会通过</span></span><br><span class="line">        <span class="hljs-comment">// DecorView的mFirstTouchTarget传递下来，那么这个View就一定不会收到除了ACTION_DOWN外</span></span><br><span class="line">        <span class="hljs-comment">// 的所有的事件。</span></span><br><span class="line">        <span class="hljs-comment">// 同时因为mFirstTouchTarget不为空，即说明了此View的dispatchTouchEvent返回true是因为</span></span><br><span class="line">        <span class="hljs-comment">// 此parent有child消耗了这个ACTION_DOWN</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">// 同时这里也反应了另外一个策略，</span></span><br><span class="line">        <span class="hljs-comment">// (在一个事件序列中)parent的dispatchTouchEvent一旦返回了true</span></span><br><span class="line">        <span class="hljs-comment">// 那么在后续的事件序列中:</span></span><br><span class="line">        <span class="hljs-comment">// (1)、dispatchTouchEvent一定不会被再次调用</span></span><br><span class="line">        <span class="hljs-comment">// (2)、后续的所有TouchEvent一定会被这个parent拦截，</span></span><br><span class="line">        <span class="hljs-comment">// (3)、后续的所有TouchEvent均会触发这个parent的消耗</span></span><br><span class="line">        <span class="hljs-comment">// (4)、这个parent的mFirstTouchTarget链表会被移除</span></span><br><span class="line">        <span class="hljs-comment">// (5)、这个parent的所有子View一定不会接受到后面传来的事件</span></span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = </span><br><span class="line">                (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            intercepted = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//表示此View是否被Cancel掉了</span></span><br><span class="line">        <span class="hljs-comment">//cancel的消息来自于其parent</span></span><br><span class="line">        <span class="hljs-comment">//当在处于非ACTION_DOWN的事件序列中的某一个事件，且被其parent拦截了</span></span><br><span class="line">        <span class="hljs-comment">//那么其parent仍然会调用此View的dispatchTouchEvent,但是传递过来的</span></span><br><span class="line">        <span class="hljs-comment">//event是ACTION_CANCEL, 通知此View清空自己的mFirstTouchTarget</span></span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="hljs-keyword">this</span>)</span><br><span class="line">            || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//一个引用，用来指向在ACTION_DOWN事件来的时候</span></span><br><span class="line">        <span class="hljs-comment">//新加入到mFirstTouchTarget链表中的节点</span></span><br><span class="line">        <span class="hljs-comment">//同时会用于一些在多点触控中的判断</span></span><br><span class="line">        TouchTarget newTouchTarget = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//防止消耗了ACCTION_DOWN的child在添加到了</span></span><br><span class="line">        <span class="hljs-comment">//mFirstTouchTarget之后再次被调用</span></span><br><span class="line">        <span class="hljs-comment">//dispatchTouchEvent这个方法的一个标志</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//注意：这里的代码块的执行和actionDown没有说明关系！！！</span></span><br><span class="line">        <span class="hljs-comment">//actionMove 和 actionUp 均会进入这个代码块</span></span><br><span class="line">        <span class="hljs-comment">//内部有一个单独的关于ActionDown的判断</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//省略部分(或许)无用(主要是看不懂)的代码</span></span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//用于找出能够消耗点击事件的子View</span></span><br><span class="line">            <span class="hljs-comment">//并通过调用子View的DispatchTouchEvent方法</span></span><br><span class="line">            <span class="hljs-comment">//来判断子View是否会消耗会这个点击事件</span></span><br><span class="line">            <span class="hljs-comment">//注意：遍历会一直持续到有子View返回了它将消耗此事件结束。</span></span><br><span class="line">            <span class="hljs-comment">//也就是说，对于哪些Z轴在上但是并不打算消耗点击事件的子View</span></span><br><span class="line">            <span class="hljs-comment">//它们的dispatchTouchEvent均会被调用</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> actionIndex = ev.getActionIndex(); <span class="hljs-comment">// always 0 for down</span></span><br><span class="line">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> idBitsToAssign = split ? <span class="hljs-number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                    : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//这里的newTouchTarget一定为null</span></span><br><span class="line">                <span class="hljs-comment">//单点的情况下mFirstTouchTarget一定为空</span></span><br><span class="line">                <span class="hljs-comment">//因为前面的ActionDown把mFirstTouchTarget重置了</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-keyword">null</span> &amp;&amp; childrenCount != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//将所以的child按照Z轴的顺序，创建一个List</span></span><br><span class="line">                    <span class="hljs-comment">//z值越大的在越上面</span></span><br><span class="line">                    <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//这里的cutomeOrder并不是说子View的顺序就是按照人为自定义的</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//这里有一个先前条件，就是preorderList == null</span></span><br><span class="line">                    <span class="hljs-comment">//在内部代码里面我们可以看到，如果所有的child的Z均是0的话</span></span><br><span class="line">                    <span class="hljs-comment">//那么preorderList就是null，这种情况下子View会根据</span></span><br><span class="line">                    <span class="hljs-comment">//draw的顺序去拿</span></span><br><span class="line">                    <span class="hljs-comment">//这里我们推测，当用户设置了setChildrenDrawingOrderEnabled(true)</span></span><br><span class="line">                    <span class="hljs-comment">//的时候，所有的子View的Z轴均是0</span></span><br><span class="line">                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span></span><br><span class="line">                        &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//所有的子View构成的数组</span></span><br><span class="line">                    <span class="hljs-keyword">final</span> View[] children = mChildren;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//遍历整个childList</span></span><br><span class="line">                    <span class="hljs-comment">//其实不是childList,而是将child通过z轴的值进行排序的一个List</span></span><br><span class="line">                    <span class="hljs-comment">//就是上面提到的preoderList</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//然后从上至下寻找能够接受整个点击事件的child</span></span><br><span class="line">                    <span class="hljs-comment">//再调用child的dispatchTouchEvent</span></span><br><span class="line">                    <span class="hljs-comment">//判断child是否消耗这个点击事件</span></span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-comment">//因为有上面的customer标志位，所以实际上遍历的子View的顺序</span></span><br><span class="line">                        <span class="hljs-comment">//并不一定是按照Z轴，也就是说在这个方法里才会真正拿到</span></span><br><span class="line">                        <span class="hljs-comment">//子View的位置，即确定子View的遍历顺序</span></span><br><span class="line">                        <span class="hljs-comment">//(1)、preorderList重前至后的顺序</span></span><br><span class="line">                        <span class="hljs-comment">//(2)、View的绘制顺序</span></span><br><span class="line">                        <span class="hljs-comment">//(3)、mChildren的逆序，及child被add的顺序</span></span><br><span class="line">                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                            childrenCount, i, customOrder);</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-comment">//获取这个child</span></span><br><span class="line">                        <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                            preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-comment">//这个方法会判断子View是否能接收到这个点击事件</span></span><br><span class="line">                        <span class="hljs-comment">//这里还没有调用子View的dispatchTouchEvent</span></span><br><span class="line">                        <span class="hljs-comment">//如果子view不能够接受的话，就说明这个点击的点在子View的范围外</span></span><br><span class="line">                        <span class="hljs-comment">//直接continue</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//同理，只有下面的代码块只有能够接受到点击事件的child才能够被执行</span></span><br><span class="line">                        <span class="hljs-keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                            || !isTransformedTouchPointInView(x, y, child, <span class="hljs-keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);</span><br><span class="line">                            <span class="hljs-keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="hljs-comment">//注意：能接触到此代码块的child一定能够接受点击事件</span></span><br><span class="line">                        <span class="hljs-comment">//遍历整个mFirstTouchTarget,寻找child是否在mFirstTouchTarget</span></span><br><span class="line">                        <span class="hljs-comment">//中出现过。</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//这里在单点的情况下一定是没有的,所以这个方法的针对的是多点的情景。</span></span><br><span class="line">                        <span class="hljs-comment">//可能是防止多点的时候多个ACTION_DOWN作用到了同一个View上</span></span><br><span class="line">                        <span class="hljs-comment">//导致被多次调用了dispatchTouchEvent的情况</span></span><br><span class="line">                        <span class="hljs-comment">//到目前 mFirstTouchTarget 还是null</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="hljs-keyword">if</span> (newTouchTarget != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="hljs-keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-comment">//调用dispatchTransformedTouchEvent</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">// 这里注意一下，上面传下来的child一定是非空且能够接受点击事件的</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//因为进入方法块的条件是mChildren.length &gt; 0,</span></span><br><span class="line">                        <span class="hljs-comment">//且不能接受点击的被continue了</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//这里的主要作用是调用Child的dispatchToucEvent方法</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">// 调用自己onTouchEvent(super.dispatchToucEvent())方法是在下面</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//这个判断条件进入了之</span></span><br><span class="line">                        <span class="hljs-comment">//也就是说dispatchTransformedTouchEvent返回了true就直接break了</span></span><br><span class="line">                        <span class="hljs-comment">//可能后面也有子View能够接受点击事件,但是均不会被调用</span></span><br><span class="line">                        <span class="hljs-comment">//dispatchTouchEvent方法了</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//如果返回了false,只有一种条件，有child能够接受这个点击事件，但是child不</span></span><br><span class="line">                        <span class="hljs-comment">//打算消耗它(比如说child实际也是一个ViewGroup)</span></span><br><span class="line">                        <span class="hljs-comment">//所以这种情况下，继续遍历寻找其他能够接受点击事件的child，看他们</span></span><br><span class="line">                        <span class="hljs-comment">//是否打算消耗这个点击事件</span></span><br><span class="line">                        <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="hljs-comment">//进入了这个方法块其实就已经表示了child能够接受这个点击事件了</span></span><br><span class="line">                            <span class="hljs-comment">//这里需要遍历一波children，来标志最后一个被点击的child</span></span><br><span class="line">                            <span class="hljs-comment">//注意，这里的Index是指的在chidren数组中的index</span></span><br><span class="line">                            <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="hljs-keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="hljs-keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="hljs-comment">//记录一下最后一次TouchDown的位置</span></span><br><span class="line">                            <span class="hljs-comment">//猜测和多点触控有关</span></span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="hljs-comment">//这个方法会将child添加到mFirstTouchTarget链表中</span></span><br><span class="line">                            <span class="hljs-comment">//这会使得newTouchTarget和mFirstTouchTarget都不为空</span></span><br><span class="line">                            <span class="hljs-comment">//</span></span><br><span class="line">                            <span class="hljs-comment">//注意这里的break：</span></span><br><span class="line">                            <span class="hljs-comment">//也就是说，只要有一个child消耗了点击事件，这个循环就已经退出了</span></span><br><span class="line">                            <span class="hljs-comment">//即：对于任何(单)点击事件来说，mFirtTouchTarget中只可能存在</span></span><br><span class="line">                            <span class="hljs-comment">//一个元素，就是消耗actionDown的那一个child</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                            <span class="hljs-comment">//这个标志位用于后面防止再调用一次dispatchTransformedTouchEvent</span></span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="hljs-keyword">true</span>;</span><br><span class="line">                            <span class="hljs-keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//preorderList已经没有用了,释放内存</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//考虑到这个代码块是处于ACTION_DOWN的前置条件的</span></span><br><span class="line">                <span class="hljs-comment">//这里实在想不到newTouchTarget == null但是 mFirstTouchTarget 不是 null</span></span><br><span class="line">                <span class="hljs-comment">//的场景，猜测可能和多点触控有关，这里我们就先不管</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="hljs-keyword">while</span> (newTouchTarget.next != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//如果有子View消耗了点击事件的话，mFirstTouchTarget会指向消耗事件的child</span></span><br><span class="line">        <span class="hljs-comment">//此时child的dispatchTouchEvent方法已经被调用了</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//ViewGroup自身的super.dispatchTouchEvent方法是在这里被调用的</span></span><br><span class="line">        <span class="hljs-comment">//即：ViewGroup自身的onTouchEvent是在这里被调用的</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//对于ViewGroup，如果其子View消耗了这个点击事件，那么它将不会被调用onTouchEvent</span></span><br><span class="line">        <span class="hljs-comment">//但是它仍然会对其上级ViewGroup表示它已经消耗了这个点击事件(尽管是它的child消耗的)</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//mFirstTouchTarget 是空就说明这个ViewGroup的所有child均没有消耗这个点击事件</span></span><br><span class="line">            <span class="hljs-comment">//强调：不是说child接受不到，只是说child没有消耗.</span></span><br><span class="line">            <span class="hljs-comment">//即: 能接受点击事件的child的dispatchTouchEvent方法,返回的是false</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//注意，这里所说的消耗是dispatchTouchEvent(onTouchEvent)向上级返回的结果</span></span><br><span class="line">            <span class="hljs-comment">//而默认情况下(对于ViewGroup来说)，这个方法的返回值是false</span></span><br><span class="line">            <span class="hljs-comment">//这里要排除一个情况，就是clickable的情况</span></span><br><span class="line">            <span class="hljs-comment">//补充：如果view是clickable的话，就要单独考虑</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//以下为调用自己的super.dispatchTouchEvent --&gt; onTouchEvent</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-keyword">null</span>,</span><br><span class="line">                                                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//遍历整个mFirstTouchTarget链表</span></span><br><span class="line">            <span class="hljs-comment">//一般来说这里的链表应该只有一个元素，就是之前能够接受点击事件的元素</span></span><br><span class="line">            <span class="hljs-comment">//在这个链表的遍历中，只要有一个child的onTouchEvent返回了true,那么此方法就会返回true</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            TouchTarget predecessor = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// &lt;--指向链表的前驱</span></span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//注意这里是一个while，会被调用多次的</span></span><br><span class="line">            <span class="hljs-comment">//下面会提到，如果parent打算拦截child的话，会将TouchTarget移除</span></span><br><span class="line">            <span class="hljs-comment">//也就是说，parent打算拦截，整个接受传递事件的序列均会被移除</span></span><br><span class="line">            <span class="hljs-comment">//(先不管resetCancelNextUpFlag 这个方法)</span></span><br><span class="line">            <span class="hljs-keyword">while</span> (target != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="hljs-comment">//</span></span><br><span class="line">                <span class="hljs-comment">//可以看到，前面创建的newTarget是用来暂存那个消耗了点击事件的child的</span></span><br><span class="line">                <span class="hljs-comment">//这个判断只会针对actionDown,因为在任何的非down的action,newtarget都是null</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//ActionDown的后续事件序列将会进入这个代码块</span></span><br><span class="line">                    <span class="hljs-comment">//因为newTouchTarget为空，并且mFirstTouchTarget非空</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//前面提到了onInterceptTouchEvent是在整个事件序列中均进行判断的</span></span><br><span class="line">                    <span class="hljs-comment">//也就是说在后续的事件序列中onInterceptTouchEvent仍然会被多次调用</span></span><br><span class="line">                    <span class="hljs-comment">//只要有一次onInterceptTouchEvent方法返回了true，那么后面的整个事件序列</span></span><br><span class="line">                    <span class="hljs-comment">//均会被整个ViewGroup所消耗了,并且在这一次事件中会把所有的能够接受事件的child</span></span><br><span class="line">                    <span class="hljs-comment">//移除，也就是说，即使这个事件序列后面parent不拦截了(比如说滑动)</span></span><br><span class="line">                    <span class="hljs-comment">//这些事件仍然不会被分发给这些child(因为mFirstTouchEvent已经被移除了)</span></span><br><span class="line">                    <span class="hljs-comment">//注意，这里会调用child的dispatchTouchEvent</span></span><br><span class="line">                    <span class="hljs-comment">//但是会给child传递一个cancel事件</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//!!!!!!注意一下这里的resetCancelNextUpFlag方法</span></span><br><span class="line">                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                        || intercepted;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                                                      target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="hljs-keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="hljs-comment">//前面提到touchTarget是一个链表的结构</span></span><br><span class="line">                        <span class="hljs-comment">//如果一个点击事件被ViewGroup拦截了的话</span></span><br><span class="line">                        <span class="hljs-comment">//ViewGroup会把链表中的这个touchTarget节点移除掉</span></span><br><span class="line">                        <span class="hljs-comment">//如果是第一个节点，就直接把mFirstTouchTarget移除</span></span><br><span class="line">                        <span class="hljs-keyword">if</span> (predecessor == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="hljs-comment">//被发送cancel的TouchTraget，直接被recycle了</span></span><br><span class="line">                        <span class="hljs-comment">//即被发送了cancel事件的子view会从TouchTarget链表中移除</span></span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="hljs-keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//三种情景</span></span><br><span class="line">        <span class="hljs-comment">//(1)、接受到了Parent传来的cancelEvent</span></span><br><span class="line">        <span class="hljs-comment">//(2)、此次事件是ACTION_UP</span></span><br><span class="line">        <span class="hljs-comment">//(3)、此次事件是ACTION_HOVER_MOVE</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//此ViewGroup会清空其mFirstTouchTarget</span></span><br><span class="line">        <span class="hljs-comment">//并且会把FLAG_DISALLOW_INTERCEPT也重置</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (canceled</span><br><span class="line">            || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//看不懂。。。。。</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> idBitsToRemove = <span class="hljs-number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//看不懂。。。</span></span><br><span class="line">    <span class="hljs-comment">//大概就是通知该事件被忽略掉了</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>View的dispatchTouchEvent()</h2>
<p>相比ViewGroup，View的onTouchEvent方法就相对来说简单很多了。我们只需要注意一下这个方法对于onTouchEvent的判断逻辑就行了。</p>
<p><strong>View.java#dispatchTouchEvent()</strong></p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//省掉一些看不懂的代码</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//mInputEventConsistencyVerifier用于检测这个输入的</span></span><br><span class="line">    <span class="hljs-comment">//事件序列是否完整和Log通知用户的</span></span><br><span class="line">    <span class="hljs-comment">//比如说用户点击事件的ActionDown被此View消耗</span></span><br><span class="line">    <span class="hljs-comment">//但是因为开发者在自定义ViewGroup中错误的拦截逻辑</span></span><br><span class="line">    <span class="hljs-comment">//导致了ActionUP事件未传递到这里来</span></span><br><span class="line">    <span class="hljs-comment">//那么这个类将会检测到这种问题，并且在Log中通知</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mInputEventConsistencyVerifier != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="hljs-number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//如果是ACTION_DOWN的话，会尝试停止嵌套滚动</span></span><br><span class="line">    <span class="hljs-comment">//由于本人对嵌套滚动的原理并不太熟悉</span></span><br><span class="line">    <span class="hljs-comment">//但是点进去可以看到，里面其实就是把嵌套滚动的相关标志清除了</span></span><br><span class="line">    <span class="hljs-comment">//这里可以联想ViewGroup的dispatchTouchEvent方法</span></span><br><span class="line">    <span class="hljs-comment">//在ACTION_DOWN的时候，也会重置整个View的事件序列</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//同ViewGroup一样，onFilterTouchEventForSecurity 是一个安全策略</span></span><br><span class="line">    <span class="hljs-comment">//主要是用来拦截屏保下用户的误触</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//先宏观的看一下这个代码块</span></span><br><span class="line">    <span class="hljs-comment">//(1)、几乎所有的判断逻辑都是返回的true</span></span><br><span class="line">    <span class="hljs-comment">//(2)、onTouchListener的onTouch方法在这里被调用</span></span><br><span class="line">    <span class="hljs-comment">//(3)、onTouchEvent 方法在这里被调用</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//也就是说ViewGroup只有调用了super.onInterceptTouchEvent</span></span><br><span class="line">    <span class="hljs-comment">//才会调用onTouchEvent方法</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//这里有一个要注意的地方，就是第一、二个判断条件</span></span><br><span class="line">    <span class="hljs-comment">//和第三个判断条件，也就是调用onTouchEvent的方法是互斥的</span></span><br><span class="line">    <span class="hljs-comment">//也就是说，只要View设置onTouchListener并且返回了true</span></span><br><span class="line">    <span class="hljs-comment">//的话，View的onTouchEvent方法是不会被调用的</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-keyword">null</span></span><br><span class="line">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//如果不进入安全策略才可能会进入这个代码块</span></span><br><span class="line">    <span class="hljs-comment">//这个代码块其实没啥用，就是Log通知一下</span></span><br><span class="line">    <span class="hljs-comment">//这个Event并没有被这个View消耗</span></span><br><span class="line">    <span class="hljs-comment">//前面提到已经谈了InputEventConsistencyVerifier的功能</span></span><br><span class="line">    <span class="hljs-comment">//这里就不在赘述</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="hljs-number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//同ViewGroup一样，在ACTION_UP的时候</span></span><br><span class="line">    <span class="hljs-comment">//View自身也会尝试清理View事件序列的状态</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">        actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">        (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>OnTouchEvent()</h2>
<p>然后我们再来看一看View的onTouchEvent方法。我发现很多人的博客对于onTouchEvent的描述都是比较少的，确实也应该这样，因为onTouchEvent方法不像ViewGroup的dispatchTouchEvent那么复杂，并且相对来说对整个View的事件机制也没有这么重要(我的意思是逻辑比较固化 ， 不算是一个难点，一般来说了解一下流程就可以了)。</p>
<p><strong>View.java#onTouchEvent()</strong></p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//获取点击的x坐标和y坐标</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> y = event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//前面提到了viewFlag是用来存放View状态的一个标志位</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="hljs-comment">//获取点击事件的种类</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//判断这个View是否是可以点击的</span></span><br><span class="line">    <span class="hljs-comment">//可以看到，实际上View是否可以点击是通过viewFlags的某一个标志位来获取到的</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//注意：这里无论是CLICKABLE 还是 LONG_CLICKABLE 均被视为可点击的</span></span><br><span class="line">    <span class="hljs-comment">//不过Android实际上对于长按的检测和onLongClick的调用</span></span><br><span class="line">    <span class="hljs-comment">//是在ACTION_DOWN的判断逻辑中而onClick是在ACTION_UP</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//补充：</span></span><br><span class="line">    <span class="hljs-comment">//(1)、如果一个View同时设置了onLongClickListener和clickListener时</span></span><br><span class="line">    <span class="hljs-comment">//如果onLongClick返回了false,那么mHasPerformedLongPress是为false的</span></span><br><span class="line">    <span class="hljs-comment">//也就是说，在ACTION_UP的场景View还是会调用onClick</span></span><br><span class="line">    <span class="hljs-comment">//(2)、如果onLongClick返回了true,也就是说长按消耗了这个点击事件</span></span><br><span class="line">    <span class="hljs-comment">//那么mHasPerformedLongPress就是true,这个时候onClick是不会执行的</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                               || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">        || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//如果这个View是不可触摸的话</span></span><br><span class="line">    <span class="hljs-comment">//按道理就应该直接返回false了,因为disable的View不应该能够消耗这个事件</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//但是看下面的注释我们知道</span></span><br><span class="line">    <span class="hljs-comment">//对于一个被disabled的View如果设置了clickable</span></span><br><span class="line">    <span class="hljs-comment">//逻辑判断它会消耗这个事件(虽然什么事情都没有做,只是返回true了而已)</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="hljs-keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//clickable是False返回false</span></span><br><span class="line">        <span class="hljs-comment">//clickable是True返回true</span></span><br><span class="line">        <span class="hljs-keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这个Delegate是用来扩大一个View的点击范围的</span></span><br><span class="line">    <span class="hljs-comment">//所以在这里我(们)就不研究它了</span></span><br><span class="line">    <span class="hljs-comment">//只需要注意一下，只要有Delegate的话，此View</span></span><br><span class="line">    <span class="hljs-comment">//的onTouchEvent方法就会返回True</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mTouchDelegate != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//如果这个View是可以点击的或这个设置了TOOLTIP的话，就进入下面的代码块</span></span><br><span class="line">    <span class="hljs-comment">//TOOLTIP是指这个View可以被长按弹出一个小小的提示</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//只要View是clickable的，那么它的onToucEvent就一定会返回true</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        <span class="hljs-keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="hljs-comment">//privateFlag这里是非公开API的内容,这里我们不管</span></span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//点进去我们可以看到，ACTION_UP的的时候</span></span><br><span class="line">                <span class="hljs-comment">//View会把ToolTip隐藏,并且将TOOLTIP的callback移除</span></span><br><span class="line">                <span class="hljs-keyword">if</span> ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">                    handleTooltipUp();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//在只有设置了TOOLTIP的情况下才会进入这个代码块</span></span><br><span class="line">                <span class="hljs-comment">//也就是说, 设置了TOOLTIP并不代表View可以点击</span></span><br><span class="line">                <span class="hljs-comment">//同样,这里做了一堆把CallBack移除的操作</span></span><br><span class="line">                <span class="hljs-comment">//</span></span><br><span class="line">                <span class="hljs-comment">//注意下面，直接就break了, 即后续的判断都不考虑</span></span><br><span class="line">                <span class="hljs-comment">//也就是说，对于ToolTip，在ACTION_UP的时候</span></span><br><span class="line">                <span class="hljs-comment">//所做的操作是清理状态和标志的</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (!clickable) &#123;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    mInContextButtonPress = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    mHasPerformedLongPress = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    mIgnoreNextUpEvent = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//一个表示prepressed的标志位</span></span><br><span class="line">                <span class="hljs-comment">//prepressed是一个不可描述的奇怪的标志位</span></span><br><span class="line">                <span class="hljs-comment">//表示的是在ACRION_DOWN和pressed之间的状态</span></span><br><span class="line">                <span class="hljs-comment">//大概就是如果按压的时间在115ms之内</span></span><br><span class="line">                <span class="hljs-comment">//那么这个较短的按压不会被算作press</span></span><br><span class="line">                <span class="hljs-comment">//而是被称为prepress的状态</span></span><br><span class="line">                <span class="hljs-keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-comment">//</span></span><br><span class="line">                <span class="hljs-comment">//注意这里的代码段是基于ACTION_UP的</span></span><br><span class="line">                <span class="hljs-comment">//下面的代码段的场景描述的是在pressed状态或者prepressed</span></span><br><span class="line">                <span class="hljs-comment">//状态下用户手指抬起来了,即ACTION_UP的时候的场景</span></span><br><span class="line">                <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span> || prepressed) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//注意：</span></span><br><span class="line">                    <span class="hljs-comment">//对于View，只有满足clickable才能够获取到焦点，</span></span><br><span class="line">                    <span class="hljs-comment">//但是这并不代表满足clickable就一定能获取到焦点</span></span><br><span class="line">                    <span class="hljs-comment">//即：clickable是获取焦点的必要条件</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//所以前面直接break也是有原因的(因为根本就进不来</span></span><br><span class="line">                    <span class="hljs-comment">//同理可知：能够进入下面这一部分的这一段代码</span></span><br><span class="line">                    <span class="hljs-comment">//View一定是能够被点击的</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//由于在ACTION_UP的时候，</span></span><br><span class="line">                    <span class="hljs-comment">//View会响应一些用户交互，比如editText弹出键盘</span></span><br><span class="line">                    <span class="hljs-comment">//所以View会尝试获取focus</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//注意：</span></span><br><span class="line">                    <span class="hljs-comment">// (1)、isFocusable的意思是这个View可以获取焦点，而不是已经获取了</span></span><br><span class="line">                    <span class="hljs-comment">// (2)、对于触摸屏的情况，我们只需要考虑isFocusableInTouchMode，</span></span><br><span class="line">                    <span class="hljs-comment">//      前者是针对的是键盘或者遥控器的场景</span></span><br><span class="line">                    <span class="hljs-comment">// (3)、requestFocus()会返回这个View是否成功的获取了焦点</span></span><br><span class="line">                    <span class="hljs-keyword">boolean</span> focusTaken = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                        focusTaken = requestFocus();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//前面提到prepress是115ms之内的一个预判定的状态</span></span><br><span class="line">                    <span class="hljs-comment">//由于用户在很短的时间内手指离开了屏幕</span></span><br><span class="line">                    <span class="hljs-comment">//115ms的press判定还没有开始</span></span><br><span class="line">                    <span class="hljs-comment">//即：drawableHotspotChanged这个方法还未调用</span></span><br><span class="line">                    <span class="hljs-comment">//drawableHotspotChanged 会记录手指的位置</span></span><br><span class="line">                    <span class="hljs-comment">//用于后面涟漪动画播放的中心位置的选择</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//但是这里drawableHotspotChanged还未调用</span></span><br><span class="line">                    <span class="hljs-comment">//而这次ACTION_UP很有可能是一次点击事件</span></span><br><span class="line">                    <span class="hljs-comment">//而点击需要播放动画，所以这里强制执行一次setPressed</span></span><br><span class="line">                    <span class="hljs-comment">//用于记录pressed的位置</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        setPressed(<span class="hljs-keyword">true</span>, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//mHasPerformedLongPress是一个用于记录是否出现了longPress的标志位</span></span><br><span class="line">                    <span class="hljs-comment">//View的在ACTION_DOWN持续了一段时间后，就会把这个标志位设置为true</span></span><br><span class="line">                    <span class="hljs-comment">//这种情况，从第一个ACTION_DOWN至ACTION_UP是不会被判断为tap事件的</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//移除掉LongPress的CallBack</span></span><br><span class="line">                        <span class="hljs-comment">//因为ACTION_UP就已经表示这个事件序列已经结束了</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-comment">//这里做一下解释：</span></span><br><span class="line">                        <span class="hljs-comment">//view的点击事件和获取焦点(这个行为)是互斥的</span></span><br><span class="line">                        <span class="hljs-comment">//也就是说一个View能够获取焦点的话，那么它将优先获取焦点</span></span><br><span class="line">                        <span class="hljs-comment">//而不会触发点击事件，在上面的判断逻辑中，如果view能够</span></span><br><span class="line">                        <span class="hljs-comment">//获取焦点的话，就会调用requestFocus方法，并且把结果返回给</span></span><br><span class="line">                        <span class="hljs-comment">//focusTaken，获取成功了的话，下面的代码块就不会被执行。</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//不过这里需要留意，如果一个View已经获取了焦点的话，</span></span><br><span class="line">                        <span class="hljs-comment">//focusTaken的返回结果是false，这里参考上面的判断逻辑</span></span><br><span class="line">                        <span class="hljs-comment">//</span></span><br><span class="line">                        <span class="hljs-comment">//如果还是不能理解的话，可以结合一下editText设置了onClickListener</span></span><br><span class="line">                        <span class="hljs-comment">//之后的行为，会发现点击第一次的时候是不会出发onClick的</span></span><br><span class="line">                        <span class="hljs-keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="hljs-comment">//</span></span><br><span class="line">                            <span class="hljs-comment">//mPerformClick是一个Runnable的的实现</span></span><br><span class="line">                            <span class="hljs-comment">//内部封装了mListenerInfo的onClick的方法</span></span><br><span class="line">                            <span class="hljs-keyword">if</span> (mPerformClick == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="hljs-keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="hljs-comment">//通过handler将onClick方法丢到消息队列中执行</span></span><br><span class="line">                            <span class="hljs-comment">//如果post(就是将mPerformClick往小修队列丢)失败的话</span></span><br><span class="line">                            <span class="hljs-comment">//那么就立即执行performClickInternal方法</span></span><br><span class="line">                            <span class="hljs-comment">//OnClickListener的onClick方法是在</span></span><br><span class="line">                            <span class="hljs-comment">//performClickInternalf方法里面被调用的</span></span><br><span class="line">                            <span class="hljs-keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClickInternal();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//在事件是ACTION_UP但是判定标志是prepress的状态的时候</span></span><br><span class="line">                    <span class="hljs-comment">//会将unSetPressState这个接口的实现丢到消息队列</span></span><br><span class="line">                    <span class="hljs-comment">//内部封装了setPress(false)方法，并且会把这个setPress(false)</span></span><br><span class="line">                    <span class="hljs-comment">//通过dispatchSetPressed方法传递下去</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (mUnsetPressedState == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="hljs-keyword">new</span> UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//注意，这里的实际作用就是重置press的状态</span></span><br><span class="line">                    <span class="hljs-comment">//前面我们可以看到，View的press状态会在</span></span><br><span class="line">                    <span class="hljs-comment">//ACTION_DOWN的时候重新设置，所以在ACTION_UP</span></span><br><span class="line">                    <span class="hljs-comment">//的时候需要将前面事件序列的press清理掉</span></span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//补充一下这里为什么要对prepress进行一个判断</span></span><br><span class="line">                    <span class="hljs-comment">//考虑到用户有可能在115ms之内出现ACTION_UP</span></span><br><span class="line">                    <span class="hljs-comment">//而通过下面的代码我们可以看到对于prepress的状态</span></span><br><span class="line">                    <span class="hljs-comment">//会115ms之后延迟执行setPress(true)</span></span><br><span class="line">                    <span class="hljs-comment">//所以显然这里设置press为false的时候也需要115ms执行</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        postDelayed(mUnsetPressedState,</span><br><span class="line">                                    ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                        mUnsetPressedState.run();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                &#125;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="hljs-keyword">false</span>;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//这里留意一下press标志位和prepress标志位</span></span><br><span class="line">                <span class="hljs-comment">//</span></span><br><span class="line">                <span class="hljs-comment">//(1)、当一个View是不在可滚动的容器中的话</span></span><br><span class="line">                <span class="hljs-comment">//那么从用户的ACTION_DOWN一直到用户ACTION_UP</span></span><br><span class="line">                <span class="hljs-comment">//的整个事件序列中,pressed一直是true</span></span><br><span class="line">                <span class="hljs-comment">//</span></span><br><span class="line">                <span class="hljs-comment">//(2)、当一个View在一个滚动的容器中的话</span></span><br><span class="line">                <span class="hljs-comment">//那么会在前115ms设置此View为prepress状态</span></span><br><span class="line">                <span class="hljs-comment">//115ms之后才会被设置为pressed</span></span><br><span class="line">            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="hljs-keyword">if</span> (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class="line">                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">//在ACTION_DOWN的时候把已经长按的标识重置了</span></span><br><span class="line">                <span class="hljs-comment">//注意：这个表示是提供给onClick参考的</span></span><br><span class="line">                mHasPerformedLongPress = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//如果是不是Clickable调用一次checkForLongClick</span></span><br><span class="line">                <span class="hljs-comment">//在内部检测是否是TOOLTIP的情况</span></span><br><span class="line">                <span class="hljs-comment">//因为TOOLTIP本质上也是一种长按</span></span><br><span class="line">                <span class="hljs-comment">//但是为了和View本身的长按不冲突</span></span><br><span class="line">                <span class="hljs-comment">//所以被设置为了一种单独的情况进行考虑</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (!clickable) &#123;</span><br><span class="line">                    checkForLongClick(<span class="hljs-number">0</span>, x, y);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//这个一般情况下都是返回false, 所以我们不管它</span></span><br><span class="line">                <span class="hljs-comment">//因为这个好像是用来处理鼠标的右键点击的</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//遍历View层级，判断是否是在一个能够滚动的容器中</span></span><br><span class="line">                <span class="hljs-keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//如果上面的标志返回是true的话，</span></span><br><span class="line">                <span class="hljs-comment">//下面的代码块会让View延迟处理长按的检测</span></span><br><span class="line">                <span class="hljs-comment">//也就是说会在115ms之后才检测用户是否处于长按状态</span></span><br><span class="line">                <span class="hljs-comment">//并且把现在的事件状态设置成prepressed</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//立即设置状态为prepress</span></span><br><span class="line">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (mPendingCheckForTap == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        mPendingCheckForTap = <span class="hljs-keyword">new</span> CheckForTap();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingCheckForTap.x = event.getX();</span><br><span class="line">                    mPendingCheckForTap.y = event.getY();</span><br><span class="line">                    <span class="hljs-comment">//</span></span><br><span class="line">                    <span class="hljs-comment">//可以看到，这里往消息对立里面丢了一个CheckForTap的Runnable</span></span><br><span class="line">                    <span class="hljs-comment">//作用是在115ms后调用setPressed(true)再检测是否是长按</span></span><br><span class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    <span class="hljs-comment">//否则，直接设置Pressed, 并且检测长按</span></span><br><span class="line">                    setPressed(<span class="hljs-keyword">true</span>, x, y);</span><br><span class="line">                    checkForLongClick(<span class="hljs-number">0</span>, x, y);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//ACTION_CANCEL比较好理解，就是parent拦截了</span></span><br><span class="line">                <span class="hljs-comment">//传递下来的ACTION,同时向此View传递一个ACTION_CANCLE</span></span><br><span class="line">                <span class="hljs-comment">//</span></span><br><span class="line">                <span class="hljs-comment">//可以看到ACTION_CANCEL的判断逻辑里面</span></span><br><span class="line">                <span class="hljs-comment">//主要是做一些资源的清理和标志的移除</span></span><br><span class="line">                <span class="hljs-comment">//这里就不做过多的赘述了。</span></span><br><span class="line">            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="hljs-keyword">if</span> (clickable) &#123;</span><br><span class="line">                    setPressed(<span class="hljs-keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                removeTapCallback();</span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                mInContextButtonPress = <span class="hljs-keyword">false</span>;</span><br><span class="line">                mHasPerformedLongPress = <span class="hljs-keyword">false</span>;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="hljs-keyword">false</span>;</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="hljs-comment">//</span></span><br><span class="line">                <span class="hljs-comment">// 再一次看到了drawableHotspotChanged这个方法</span></span><br><span class="line">                <span class="hljs-comment">// 这个很容易理解，因为View的点击动画的的播放位置</span></span><br><span class="line">                <span class="hljs-comment">// 应该是在手指离开的位置的，而对于手指移动的场景</span></span><br><span class="line">                <span class="hljs-comment">// ACTION_UP的位置就是最后一次ACTION_MOVE的位置</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (clickable) &#123;</span><br><span class="line">                    drawableHotspotChanged(x, y);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">//用于判断我们当前手指的移动有没有移除这个View的范围之外</span></span><br><span class="line">                <span class="hljs-comment">//如果手指移除了范围之外的话，就将部分的资源清理(状态重置)</span></span><br><span class="line">                <span class="hljs-comment">//并且重新设置press为false</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                        setPressed(<span class="hljs-keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//默认是返回False的</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        </div>
        
        
        
        
    </div>
</div>








</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <figure class="image is-128x128 has-mb-6">
                            <img class="is-rounded" src="/assets/img/favicon.jpg" alt="pigrange">
                        </figure>
                    
                    
                    <p class="is-size-4 is-block">
                        pigrange
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        JohnPig
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>ChengDu China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        15
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        9
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        8
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/pigrange" target="_blank">
                关注我</a>
        </div>
        
        
    </div>
</div>
    
        

<div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="http://gityuan.com/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">袁神gityuan</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">gityuan.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://blog.piasy.com/index.html" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Piasy</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">blog.piasy.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.gcssloop.com/#blog" target="_blank">
                    <span class="level-left">
                        <span class="level-item">gcsloop</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.gcssloop.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.androidperformance.com/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">高爷Cracker</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.androidperformance.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://dp2px.com/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">dp2px</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">dp2px.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>


    
        
<div class="card widget is-hidden-mobile">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/tags/JAVA/" style="font-size: 13.33px;">JAVA</a> <a href="/tags/Review/" style="font-size: 16.67px;">Review</a> <a href="/tags/SourceCode/" style="font-size: 13.33px;">SourceCode</a> <a href="/tags/you/" style="font-size: 10px;">you</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/总结归纳/" style="font-size: 10px;">总结归纳</a>
    </div>
</div>

    
        
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/09/29/线程和线程池/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/ExploreAndroid.png" alt="线程和线程池">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-29T11:57:37.000Z">2019-09-29</time></div>
                    <a href="/2019/09/29/线程和线程池/" class="has-link-black-ter is-size-6">线程和线程池</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a> / <a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/29/Android消息机制/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/ExploreAndroid.png" alt="Android消息机制">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-29T07:27:00.000Z">2019-09-29</time></div>
                    <a href="/2019/09/29/Android消息机制/" class="has-link-black-ter is-size-6">Android消息机制</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a> / <a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/28/从多线程到Handler/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/img/handler/Handler.jpg" alt="从多线程到Handler">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-28T05:49:34.000Z">2019-09-28</time></div>
                    <a href="/2019/09/28/从多线程到Handler/" class="has-link-black-ter is-size-6">从多线程到Handler</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/日常/">日常</a> / <a class="has-link-grey -link" href="/categories/日常/胡思乱想/">胡思乱想</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/23/View-process-2/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/SourceCode.jpg" alt="View工作流程[二]：Measure布局">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-23T06:35:36.000Z">2019-09-23</time></div>
                    <a href="/2019/09/23/View-process-2/" class="has-link-black-ter is-size-6">View工作流程[二]：Measure布局</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a> / <a class="has-link-grey -link" href="/categories/源码阅读/View工作流程/">View工作流程</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/22/寄夏予你/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/you.png" alt="寄夏予你">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-22T11:03:10.000Z">2019-09-22</time></div>
                    <a href="/2019/09/22/寄夏予你/" class="has-link-black-ter is-size-6">寄夏予你</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/日常/">日常</a> / <a class="has-link-grey -link" href="/categories/日常/随笔/">随笔</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget is-hidden-mobile">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">11</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/09/29/线程和线程池/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/ExploreAndroid.png" alt="线程和线程池">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-29T11:57:37.000Z">2019-09-29</time></div>
                    <a href="/2019/09/29/线程和线程池/" class="has-link-black-ter is-size-6">线程和线程池</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a> / <a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/29/Android消息机制/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/ExploreAndroid.png" alt="Android消息机制">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-29T07:27:00.000Z">2019-09-29</time></div>
                    <a href="/2019/09/29/Android消息机制/" class="has-link-black-ter is-size-6">Android消息机制</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a> / <a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/28/从多线程到Handler/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/img/handler/Handler.jpg" alt="从多线程到Handler">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-28T05:49:34.000Z">2019-09-28</time></div>
                    <a href="/2019/09/28/从多线程到Handler/" class="has-link-black-ter is-size-6">从多线程到Handler</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/日常/">日常</a> / <a class="has-link-grey -link" href="/categories/日常/胡思乱想/">胡思乱想</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/23/View-process-2/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/SourceCode.jpg" alt="View工作流程[二]：Measure布局">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-23T06:35:36.000Z">2019-09-23</time></div>
                    <a href="/2019/09/23/View-process-2/" class="has-link-black-ter is-size-6">View工作流程[二]：Measure布局</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a> / <a class="has-link-grey -link" href="/categories/源码阅读/View工作流程/">View工作流程</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/22/寄夏予你/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/you.png" alt="寄夏予你">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-22T11:03:10.000Z">2019-09-22</time></div>
                    <a href="/2019/09/22/寄夏予你/" class="has-link-black-ter is-size-6">寄夏予你</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/日常/">日常</a> / <a class="has-link-grey -link" href="/categories/日常/随笔/">随笔</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget is-hidden-mobile">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">11</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                    
                    <img src="/assets/img/logo.jpg" alt="Pigrange&#39;s Blog" height="28" style="margin-left: 0.5em">
                    
                </a>
                <p class="is-size-7" style="padding-bottom: 0.5em">
                    <span id="timeDate" class="is-size-7"></span>
                    <span id="times" class="is-size-7"></span>
                </p>
                <p class="is-size-7">
                    &copy; 2019 John Pig&nbsp;
                    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                    
                </p>
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                <script>
                    var now = new Date();
                    function createtime() {
                        var grt = new Date("7/24/2019 16:00:00");//此处修改你的建站时间或者网站上线时间 
                        now.setTime(now.getTime() + 250);
                        days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                        if (String(hnum).length == 1) { hnum = "0" + hnum; } minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
                        mnum = Math.floor(minutes); if (String(mnum).length == 1) { mnum = "0" + mnum; }
                        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                        snum = Math.round(seconds); if (String(snum).length == 1) { snum = "0" + snum; }
                        document.getElementById("timeDate").innerHTML = "&nbsp;&nbsp" + "本站已安全运行 " + dnum + " 天 ";
                        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                    }
                    setInterval("createtime()", 250);
                </script>
            </div>
            <div class="level-end">
                
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"mobile":{"show":false},"model":{"scale":0.7,"jsonPath":"/live2dw/assets/hijiki.model.json"},"log":false});</script></body>
</html>