{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"EffectiveJava笔记[一]","text":"EffectiveJAVA的读书笔记(:з)∠) 1、考虑使用静态工厂方法代替构造方法：静态工厂方法的优点： 拥有名字，更加容易阅读 不需要每一次调用的时候都创建一个对象，可以对实例的数量进行严格的控制 可以返回其返回类型的任何子类型的对象 可以根据传入参数的不同而返回不同类型的对象，（构造方法只能返回自己的对象） 在编写包含该方法的类的时候，返回的对象的类不需要存在。 缺点： 如果只提供静态工厂方法，那么它就有可能没有public或者private的构造方法，也就是说无法被子类化。 没有一个统一的对静态构造方法的命名的规范，导致可能很难找到他们。 2、当构造方法的参数过多的时候，使用Builder模式:静态工厂方法和普通的构造方法都无法很好的解决构造方法中参数很多且可选的参数很多的问题。 使用构造方法的缺点： 过多的方法重载，导致非常的繁琐 并且在获取类的实例的时候可选(参数)的构造方法太多，以至于降低可读性 1、JavaBean模式： 通过一个无参数(这里指可选参数)的构造方法来创建对象，然后调用一系列setter方法来设置参数 缺点： 代码较为冗余 由于是实现创建好了对象在设置值，所以在多线程的情况下无法保证对象参数的一致性（也就是说先创建好了对象再去设置参数，无法保证在创建过程中对象的不可变的） 2、Builder模式： 客户端不直接创建对象，而是通过一个builder预先配置好对象的每一个可选参数，然后通过builder的build方法来生成对象，这样产生的对象就是不可改变的，Builder通常是它所构建的类的一个静态的成员。 3、使用私有构造方法或枚举来实现单例单例通常表示的是无状态的对象。比如说一个只提供函数功能的对象或者一个系统组件。 1、实现单例的方式： 创建一个静态final的自身引用，并私有构造方法 提供一个公共静态方法用于返回自身的单例。 注意，对于构造方法，应当在请求创建第二个实例的时候抛出异常，因为Java的反射机制可以调用private的构造方法。 2、单例与序列化： 如果单例的对象需要支持序列化的话，那么仅仅将这个类直接实现Serializable接口是不行的，这个问题正好是前面应该注意的点的良好反应。 当使用ObjectInuptStream对对象进行反序列化的时候，Java会通过反射去调用类的无参构造方法(尽管它是私有的)，当然如果按照我们前面的实现，那么很有可能在反序列化的时候直接抛出了异常(因为请求创建了第二个实例) 解决方案： 在单例类中提供一个readResolve方法，并在这个方法中返回我们的单例对象。 4、使用私有构造方法来执行非实例化这个条目是直接基于EffectiveJava直译而来。通俗来讲就是对于那些只用于提供静态方法或者静态属性的类(比如某些Util工具类或者config配置文件)，我们应该避免他们被创建实例或者继承，因为并没有任何意义。 采取的操作： 将类设置为final，避免被继承 将类的构造方法设置为私有，并在代码块里面抛出异常(防止别人通过反射来创建实 5、依赖注入优于硬连接资源这个又是显得异常的高大上。至少对于我来说，看见依赖注入就觉得这个是高大上且较难的东西，并且第一遍读这个条目的时候也没有搞明白这个到底是啥。 其实弄明白了什么是依赖注入，这个条目就非常的简单了。 依赖注入： 依赖：举个比较普遍的例子。我把我自己比作对象a，我的电脑比作对象b。如果我需要写这篇blog，我就需要我的电脑，也就是说a依赖于b。 依赖注入：对于a依赖的对象b，我们不应该在a的类中直接创建b的实例，而是提供b的设置api或者通过构造方法将b的引用传入。也就是说将a的依赖b注入给了b。 这样做有两个好处，一是b的生命周期并不用需要a来进行管理。二是对于多个依赖b的对象，如果b是不可变的，那么可以实现b的复用。 虽然通过接口传递依赖也是一种实现，不过不推荐这么做，因为在并发的环境中，这是非常容易出错的。除非我们的对象非得支持多种依赖，那么最好的解决方式还是将其设置为final然后再通过构造方法传入。 依赖注入的有用变体： 将资源工厂传递给构造方法。","link":"/2019/07/24/EffectiveJava笔记1/"},{"title":"Android消息处理机制","text":"从《Android开发艺术探讨》总结的关于消息处理机制的一些心得体会。 1、相关的类 Handler ：消息的处理者 MessageQueue：消息队列，单链表结构。主要用于对消息的插入和获取 Looper：消息队列的驱动者。即Looper驱动消息队列，在Looper的loop方法里面。 TheadLocal：全局唯一的一个静态的实力sThreadLoacl，用于在每一个线程中存储数据。这里主要是用来让线程和Looper进行绑定，这样就可以通过线程获取到这个线程对应的Looper了。 2、Android消息机制的描述 消息机制：Handler的运行机制和Handler所附带的MessageQueue和Looper的工作流程 使用Handler的原因：解决子线程中无法访问UI界面的矛盾 多线程控制UI：无法实现线程安全 单线程通过锁控制UI：会降低UI的访问效率 Handler的工作需要依赖于Handler对应线程里的Looper 2.1、Handler的创建代码分析: 12345678910111213141516//TAG1public Handler() { this(null, false);}//TAG2public Handler(Callback callback) { this(callback, false);}//TAG3public Handler(Looper looper) { this(looper, null, false);}//TAG4public Handler(Looper looper, Callback callback) { this(looper, callback, false);} 我们可以看到，Handler总共拥有四个构造方法。这里可以TAG2是传入了CallBack，Tag3是传入了Looper，而TAG4是都传入了。这里的具体实现我们放到后面来说，在这里，先看看TAG1(或TAG2)下的this指定的构造方法。 123456789101112public Handler(Callback callback, boolean async) { //省略没有啥用的代码 mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;} 这里我们可以看到Hanler的构造方法实际上做了四件事情: mLooper的初始化 mQueue的初始化 mCallBack的初始化 mAsynchronous的初始化 我们先不管mAsynchronous，仅看前三个变量。可以看到，首先通过了Looper.myLooper()这个方法获取了一个Looper的实例，我们查看实现，发现其实调用的是sThreadLocal的get方法。我们继续深究get方法的实现，可以看到get其实通过获取当前运行的线程返回了一个泛型参数，毫无疑问这就是我们的Looper，留意代码发现当 getMap返回为空的时候，返回的是setInitialValue()的返回值，这个方法其实就是返回null，只不过对我们之前为空的ThreadLocalMap 进行了初始化。 1234567891011121314151617public static @Nullable Looper myLooper() { return sThreadLocal.get();}public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue();}","link":"/2015/01/26/Android的消息机制/"},{"title":"一、生命周期与启动模式","text":"Activity的生命周期与启动模式 一、Activity的生命周期1、正常情况下Activity的什么周期:正常情况下，Activity经历的生命周期如下： onCreate() 表示Activity正在启动，这里编写用户的逻辑，比如数据的准备，视图的创建，Listener的注册。 这个方法调用的时候，Activity还未被创建好，也不可见。 onStart() 在perfromStart中调用 callActivityOnstart方法 &lt;— final 方法 表示当前的Activity正在被启动，on starting的意思。 在这个状态下，Activity已经可见了，但是由于没有出现在前台，所以不可见。 这个方法会在onCreate之后执行，所以这个时候Activity已经被创建好了 这个方法会将onStart指令分发给所有的子Fragment。(fragmentActivity中) onRestart Activity没有被完全销毁，重启的过程。 这种情况下，一般是用户的Activity离开前台退回到后台所导致的。 这个方法是在onStart()之前调用的。 补充：这个方法实际上是在performResume中调用的，performResume会首先调用perfromRestart，由于才创建的Activity的mStoped是false，所以perfromRestart直接return了，而performRestart里面会调用perfromStart来间接调用onStart方法。 performStart方法最终会将View变得可见(目前还不清楚具体的实现在哪里) onResume() Activity在onStart之后就已经创建完成。onResume是将其添加到window上，让其可见。 也就说onResume的时候Activity才正式显示到前台。 onPause() 表示Activity正在停止，这个方法是在onStop之前被调用的。 这个方法里面应该做一些停止动画的操作，但是不能太耗时。 这个方法会在新的Activity的onCreate方法调用之前被执行，所以如果这个方法耗时的话，新的Activity会被强制等待。 onStop() 表示Activity即将被停止，这个方法也同样不能太耗时。但是这个方法会在新的Activity的onResume之后才被调用。所以在调用这个方法的时候Activity已经变得不可见了。 说明：因为这个方法是在performStop里面调用的，而performStop里面会WindowManager将View从Window中移除了，onStop是在移除RootView之后被调用的。 onDestory() 表示Activity即将被销毁。用于做一些资源的释放。 注意：在内存不足的情况下从而导致Activity的非正常结束，这个方法是不会被回调的。 对应关系： onCreate -&gt; onDestory onStart -&gt; onStop onResume -&gt; onPause 注：对应关系并不是完全对应的，只是说宏观的流程下，这几个方法有如下的对应关系。 2、异常情况下Activity的生命周期异常情况下Activity的生命周期如下： 资源相关的系统配置发生改变导致Activity被杀死并重新创建 资源内存不足导致低优先级的Activity被杀死 （1）配置改变的情况(注意，这种情况activity算异常终止)： Activity会依赖于系统资源，如果系统的状态发生了改变会导致Activity所依赖的系统资源发生改变，因此Activity会进行重建。 手机的屏幕进行了旋转，Activity会进行重建(完全的重建)。 这种情况下Activity会被销毁，其onPause , onStop , onDestory均会被调用。 这种情况会调用activity的onSaveInstanceState方法 此方法会保存window的层级状态(通过调用window的saveHierarchyState方法) —&gt; Activity的视图结构 此方法会保存所有的fragment状态 此方法会保存所有的outfill状态（这个是什么东西？ 当系统重建的时候Activity会调用onSaveInstanceState方法。 因此，也可以在这个方法里面对保存的状态进行恢复 注意：这里保存的状态是是Boundle，故需要用Parceble来进行状态的保存。 （2）内存资源不足导致的Activity被重建的情况： 注意：在这种情况下，Activity的onSaveInstanceState方法也是会被调用的 Activity的优先级： 前台 可见但是并非前台：onStop没有被调用 后台：onStop方法被调用了 Avtivity脱离了四大组件很容易被杀死 对于Activity的配置发生了改变的情况，可以强制指定onConfigChange来拒绝系统重建Activity 在Manifast中指定configChange这个属性即可 注意：对于屏幕发生改变的情况，还需要指定screenSize属性 二、Avtivity的启动模式：任务栈：(1)任务栈是和App(包名)相绑定的 (2)注意任务栈是有前台和后台之分的。 (3)Activity不可见并不等于Activity就在后台的任务栈中。 一个Activity可能会有多个任务栈 任务栈通过taskAffinity进行指定 (4)出现前后台两个任务栈的例子： App1启动，打开了Activity A和Activity B 用户点击了Home，返回了主界面，此时App的所有任务栈回归后台。 用户启动了App2，并且通过App2的Activity启动了App1的Activity C Acitivity C是 singleTask，并且没有指定taskAffinity(即默认的) Activity C在前台任务栈，Activity A B 在后台任务栈。 四种启动模式： Standard: 标准模式，谁启动这个Activity，就压进启动者的任务栈，无复用机制，不绑定taskAffinity，始终创建新的实例。 SingleTop: 栈顶复用模式，有栈顶复用机制，其他的和Standard一样，不绑定taskAffinity SingleTask：栈内复用模式，绑定taskAffinity，三个强调点，如下： 系统会在指定的Task栈中创建新的Activity，并且在这个Task栈中实现单例，如果不指定Task栈的话，那就是默认的任务栈 (taskAffinity为包名) 尽管可能会在新的任务栈中创建Activity，但是点击返回会将焦点转移至原来的Activity，而不是这个Activity栈的下一个(当然也可能是，这个得看启动它的Activity所在的栈)。 这个Activity会在这个任务栈中实现单例，并且被赋予焦点的时候会将上面的所有Activity全部出栈。 如果前台任务栈启动了后台任务栈的方法，会把整个后台任务栈搬到前台来 这种情况，点击返回就会将此栈一一退出，因为后台栈已经和前台栈合并了 SingleInstance：全局单例的模式，Activity会维护一个自己的栈，并且这个栈中就只有这一个Activity。 android:taskAffinity属性：用于标记Activity所属的Task，默认的情况下值为应用的包名。 LaunchMode 为 singleTask的Activity LaunchMode为singleInstance的Activity 使用flag＝Intent.FLAG_ACTIVITY_NEW_TASK启动的Activity LaunchMode和Intent Flag的对应关系： FLAG_ACTIVITY_NEW_TASK &lt;==&gt; SingleTask FLAG_ACTIVITY_SINGLE_TOP &lt;==&gt; SingleTop FLAG_ACTIVITY_CLEAR_TOP： SingleTask默认带有ClearTop标志 如果Standard/或者SingleTop设置了FLAG_ACTIVITY_CLEAR_TOP的话，如果栈内有，会将当前栈的上面的全部去掉(包括原有的Activity)，再创建一个新的实例。 启动模式的指定： 通过配置AndroidMenifest实现 通过在Intent中设立标志位来实现 比较： 第一种的优先级更低 第一种无法为Standard设置ClearTop 第二种无法实现SingleInstance 三、IntentFilter的匹配规则：IntentFiler 用于匹配隐式的Intent 三个匹配规则：注意：三个匹配规则需均满足才能匹配成功。 action 匹配规则 category 匹配规则 data 匹配规则 Action： Activity可以设置多个 Intent只有能够匹配让其中的一个即可 如果不设置的话，就永远匹配不上 对于Intent来说，Intent只能设置一个Action属性 category： Intent和Activity均能够设置多个 intent设置的categoriy需要均匹配上 如果intent不设置，则其会设置默认的DEFAUT 对于Activity，需要设置DEFAULT来接受Intent中DEAFULT的匹配条件 Data 实际上只需要匹配两个内容： URI MimeType 由于URI结构比较复杂，故在注册Activity的时候，需要对URI的每一个结构单独设置匹配条件 Activity的Data可以设置多个 Intent的Data需要完全匹配上Activity中的其中一个才能通过 Intent中通过Uri.parse(string) 指定Uri，指代MIME的string 指定MimeType setData 和 setType有冲突，如果都要匹配，需要调用setDataAndType方法 URI的schema必须指定此URI才有效(才能够接受匹配) 判断是否有Activity能够匹配Intent： PackgeManager.resolveActivity方法 Intent.resolveActivity方法(其实就是调用的PM的resolveActivity方法，只是做了封装)","link":"/2019/09/13/Android1/"},{"title":"EffectiveJava笔记[二]","text":"EffectiveJAVA的读书笔记(:з)∠) 6、避免创建不必要的对象此条目下作者有这个观点：当你应该重用现有对象的时候，请不要创建新的对象 最突出的就是字符串常量创建的例子： 1String str = new String(\"hello\"); 如上所述，本来在字符串常量池中就存在字符串”hello”，但是我们又创建了一个新的字符串”hello”的实例，显然，这个新的str实例是并不需要的。 使用静态工厂方法： 构造方法一定会创建一个新的对象，但是其实很多时候并没有这个必要。对于一些可以重用现有对象的情况，我们可以使用静态的工厂方法来获取实例（因为静态工厂方法是九二一对实例进行严格控制的）。 缓存创建昂贵的对象： 对于那些可以复用的但是创建昂贵的对象，我们可以将其设置为公共静态的，这样既可以避免重复创建带来的性能开销，也可以避免持有这个对象的容器对象在失去引用后被GC清理掉。 注意，这里很容易进入一个误区，就是对那些(可能)会重用的对象都进行缓存。 这个条目并不代表对象的创建是昂贵的。其实通过构造方法创建和回收对象的性能开销并不高。 作者在此条目的下面提到： 除非池(对象缓存)中的对象非常重量级，否则通过维护自己的对象池来避免创建对象其实并不太好，因为者会显著的加大内存的占用。 回到条目的开始，我们应该将重点放在重用和不要创建新的对象上面。也就是说，我们更多应该考虑的是在重用某个对象的时候，尽可能的去避免创建新(没有必要)的对象。 7、消除过期的对象引用：这里有一个误区，就是JAVA拥有垃圾收集机制，所以我们就不需要手动对内存进行管理了。 但是，其实这个是不一定正确的，内存泄漏在JAVA里面太频繁了。 作者在书中提到当一个类自己管理内存时，程序员应当警惕内存泄漏，书中举了一个栈弹出的例子： 12345public Object pop() { if (size == 0) { throw new EmptyStackException(); } return elements[--size]; 可以看到，这种实现实际上仅仅是将size的-1了。但是elements任然保留着对size外的元素的引用，也就是说那一部分的元素的内存并不会被GC释放掉。 解决方案： 12345678public Object pop() { if (size == 0) { throw new EmptyStackException(); } Object result = elements[--size]; elements[size] = null; return result;} 8、避免使用Finalizer和Cleaner机制这可能对JAVA新手来说一脸懵逼(没错，我就是这种。因为压根就不知道什么是Finalizer，这里就不谈Cleaner机制了，因为我现在还是不会，不过功能应该和finalizer差不多) 对于C++程序员，我们知道有一个析构函数用于回收资源。 Finalizer机制： GC在回收对象之前调用其finalize方法，但是这并不说明finalize就等于C++的析构函数。finalize方法的调用存在很大的不确定性，也就是说它的调用在不同设备上面的行为具有很大的差异。 当一个对象变得不可达一直到finalize方法的调用这一段时间是任意长的。所以我们千万不要在这个方法里面做一些关闭文件流这种释放非内存资源的操作。因为很有可能出现文件流没有被及时的关闭从而导致后面的文件流打开失败。 finalize机制已经被弃用了。 Java并不能保证Finalizer和Cleaner机制的及时运行，甚至不能够确保他们是否能够运行 System.gc和System.runFinalization 可能会增加finalize被执行的几率，但是不保证其一定被执行 在Finalizer机制中，未被捕获的异常会被忽略，cleaner机制不会有这个问题 Finalizer机制会严重影响垃圾收集的效率和性能 Finalizer机制的作用： 作为安全网，防止资源拥有者忽略了他的close方法。这个很好理解，当资源拥有者忘记close的时候，通过finalize至少可能会关闭资源，着总比不关闭好。也就是说，这个机制虽然不可信，但是聊胜于无。 finalize方法适用于释放一些通过native方法释放的对象(比如说通过JNI创建的对象) 9、使用try-with-resources语句替代try-finally语句可能你刚看到这个条目的时候会和我一样对于什么叫做try-with-resources语句一脸懵逼(本人太菜，之前确实没有见过) 书中举了这样一个例子： 12345678static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); }} 在上述的代码块中，有可能由于文件流的没有正常打开导致异常出现。同理，由于引用了空的对象，br无法正常调用close方法。那么在这次情况下第二个异常会完全覆盖掉第一个异常。如果使用了catch语句块捕获了异常，那么代码就会变成如下的样子： 123456789101112131415static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } catch (IOException e) { e.printStackTrace(); } finally { try { br.close(); } catch (Exception e) { e.printStackTrace(); } } return null;} 这种代码，写出来简直辣眼睛。反复的异常捕捉显著的降低了代码的可读性。 使用try-with-resources语句： 1234567static String firstLineOfFile(String path) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch (IOException e) { return defaultValue; }} 相较于之前的代码，显然可读性有所提高。 原理： 能够使用try-with-resources语句的资源类其实都自动实现了AutoCloseable接口这个接口提供了一个无参数的close方法。也就是说，使用了try-with-resources语句声明的资源只要实现了这个方法，那么都会在抛出异常之前调用close方法关闭资源。另外，用于资源对象的close方法是由其自己控制，所以我们也不需要考虑资源文件关闭所产生的异常。 10、重写euquals方法时应当遵守的通用约定不需要重写equals方法的条件： 每一个类的实例都是一个固有且唯一的。 类并不需要提供一个逻辑相等的测试功能。 父类已经重写了equals方法。一个设计良好的可继承的父类应保证其子类完全实用于父类的equals方法。 类是private修饰的或者default修饰的，那么这个类的equals方法应该永远不会被调用。 需要重写equals方法的条件： 一个类包含逻辑相等的概念，并且父类并没有提供equals方法。这里特指一些表示值的类，比如Ineger或者String类。 使用equals方法的时候应当比较的是对象逻辑上面的相等，而并不是比较是否引用的是相同的对象。 当某一个类需要作为Map的key的时候。 equals方法应当满足的属性： 自反性：一个对象必须和自身相等 对称性：a.equals(b) == b.equals(a) 传递性：a.equals(b)，b.equals(c)，则a.equals(c) 一致性：相等的对象永远相等，不相等的对象永远不相等 非空性：所有的对象都不等于null 编写高质量的equals方法： 首先使用==运算符检查参数是否为该对象的引用，如果成立直接返回true，这是一种性能优化。 应当使用instanceof检查传递参数是否有正确的类型，因为equals方法默认传递的参数是Object类型的 将参数进行强制类型转化 对于参数的每一个值属性，应当验证值属性是否相等，注意，对于float或者double类型，不要用==而是使用Float.compare或者Double.compare方法比较。 对于参数的对象属性，应当递归的对持有的对象进行equals比较，由于对象引用可能为空，所以对引用对象进行比较的时候，应当使用Object.compare方法 使用equals方法进行比较的时候，应当首先考虑最有可能不同的属性，这也是一种性能优化。 不要忘记验证自己实现的equals方法是否满足上面提到的5个属性。 注意事项： 重写equals方法的时候，应该重写hashCode方法 不要对equals方法太过于吹毛求疵，这可能会因为考虑因素太多导致实现非常困难。 重写equals方法的时候，参数是Object类型的，不要将参数替换成其他的类型。","link":"/2019/07/24/EffectiveJava笔记2/"},{"title":"EffectiveJava笔记[三]","text":"EffectiveJAVA的读书笔记(:з)∠) 11、重写equals时重写hashCode方法在每一个重写了equals方法的类中，应当重写这个类的hashCode方法。如果不这么做，那么将会违背Object.hashCode的通用约定，从而导致某一些基于hash散列的集合无法正常运行，比如说HashSet， HashMap，HashTable。 规范： 在程序执行的这段时间，如果对象equals方法进行的比较信息没有被改变的话，那么这个对象的hashCode该返回同一个整数。 如果这个应用程序多次执行，那么没有必要保证每一次的hashCode都是一样的。 如果两个对象通过equals方法比较是相等的，那么他们的hashCode应该一样 如果两个对象通过equals方法比较是不相等的，那么他们的hashCode不应该一样。 对于基于hash散列的类来说，如果不重写hashCode方法的话，那么即便他们通过equals方法得到的结果是true，那么将他们作为hashMap的key也无法拿到正确的值，因为他们只是逻辑上相等，而hashMap是基于hashCode寻址的。 hashCode的计算： 为对象中的每一个关键域f，计算其散列码c 1result = 31 * result + c; 返回 result 注意： 如果一个域的值是由其他域演算出来的话，那么这个域不需要用于计算hashCode 如果一个域并没有在equals方法中使用，那么这个域不应该用于计算hashCode 不要排除一些关键的属性来提高hashCode的性能，这可能会降低这个方法的可靠性 在编写完hashCode之后，应当测试hashCode功能的正确性 如果一个对象计算hashCode的代价比较大的话，应当缓存这个hashCode 12、始终重写toString方法虽然Object类提供了toString方法的实现，但是在某些情况它返回的toString并没有什么乱用。提供一个良好的toString方法可以使类更易于使用和调试。 toString方法应当返回对象中包含的所有需要关注的信息 应当在文档中指定toString方法返回的格式 在静态工具类中，编写toString方法是没有任何意义的。 应当在任何抽象类型中定义toString方法，使得子类共享一个公共字符串表示形式 除非父类已经实现了toString方法，否则应该在每一个实例化的子类中重写toString方法。 13、谨慎地重写clone首先需要指出，这个条目是基于Cloneable接口或者说clone方法而列出的。Cloneable接口是一个空的接口，它仅仅用来表明这个对象是允许被克隆的。真正的clone方法的提供是在Object类中。这一点也被作者在书中描述为设计上面的缺陷。 Cloneable接口： 这是一个并未包含任何方法的接口，它的唯一作用就是决定Object类中clone方法实现的行为。换句话说，如果一个类实现了Cloneable接口，那么它就应该在clone方法里面返回对该对象的逐域拷贝，否则就会抛出CloneNotSupportedException异常。 这是一种比较极端的写法，因为它违背了定义接口的作用。 这是一种可以不调用构造器就创建对象的方法。 对于clone方法的一些约束： 1(x.clone() != x) == true 1(x.clone().getClass() == x.getClass()) == true 1x.clone().equals(x) == true 解读： 不得不说，这本书的翻译是真的烂。(:з)∠)_ 上面提到的不调用构造方法就可以创建对象的规定其实太过于强硬，或者享有了太大的特权，想象你好不容易实现了一个单例，并通私有构造方法并抛出异常，甚至提供了readResolve这个方法来保证反序列化也是单例。但是一旦你实现了Cloneable，接口并重写了clone方法，那么你好不容易设计的单例会因为clone而失效。作者指出行为良好的clone方法，应该是可以调用构造器来创建对象的，但是遗憾，clone并没有这么做。 作者强调（通常情况下）(x.clone().getClass() == x.getClass()) == true这个规定太过于软弱。这里我理解了半天。为什么叫过于软弱，因为它不是强制要求的，因为clone指出了不通过构造器就创建对象，但是却允许了(x.clone().getClass() == x.getClass()) != true。举个例子：比如我有一个child类，他继承了他的父类，但是并没有重写clone方法，那么这个方法将最终调用父类的clone。但是很遗憾，父类的设计者并未考虑到这个问题，因为他约定clone的一些约束，允许上面的不等条件出现，所以他使用了构造方法来clone了对象的副本。那么当子类调用clone方法的时候，你会惊讶的发现居然返回的是父类的对象，甚至你无法通过强制类型转化将其转化过来。 为了避免上面的情况，保证子类通过调用super.clone()也返回自己的实例。我们的父类也应该调用自己的super.clone()（父类的父类的clone方法）。在这种层层传递下，所有的super.clone()最终都会调用Object.clone()方法，这样就能保证在整个类的层级结构中，所有的子类的clone()方法最终均会返回Object的对象，由于 Objcet.clone()返回的是对象的逐域拷贝(也就是对整块内存的复制)，所以最终我们只需要进行强制类型转化即可。 很遗憾的是，Cloneable接口并没有清楚的指出一个类实现这个接口应该承担什么责任。 浅克隆： 这里作者列举了一个Stack类的例子： 12345678910111213141516171819202122232425262728public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { this.elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // Eliminate obsolete reference return result; } // Ensure space for at least one more element. private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); }} 我们可以看到，Stack类持有Object数组的应用。当我们克隆这个对象的时候，理想情况下，Stack的elements也会跟随一起被克隆，然而很遗憾，克隆出来的的对象和原来的对象持有相同element对象的引用，也就是说，克隆的时候，只传递了引用。 深克隆： 其实就是针对上面问题的一个解决方案罢了。 对于对象持有的对象引用，我们应当递归(或迭代)地调用这些对象的clone方法。 1234567891011121314151617181920@Override public HashTable clone() { try { HashTable result = (HashTable) super.clone(); result.buckets = new Entry[buckets.length]; for (int i = 0; i &lt; buckets.length; i++) if (buckets[i] != null) result.buckets[i] = buckets[i].deepCopy(); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); }}Entry deepCopy() { Entry result = new Entry(key, value, next); for (Entry p = result; p.next != null; p = p.next) p.next = new Entry(p.next.key, p.next.value, p.next.next); return result;} 克隆的替代方案： 对于那些确定是不可变的类，最好不要实现clone方法，因为这没有意义。 使用拷贝构造器或者拷贝工厂 使用基于接口的拷贝构造器(转换构造器)或者拷贝工厂(转换工厂)。 14、考虑实现Comparable接口compareTo方法并没有在Object类中声明，它是Comparable接口中的唯一方法，其实这个是很好理解的，因为我们并不需要每一个对象都是可以比较大小的。 compareT方法 1int compareTo(T t) 可以看到，这个方法是泛型的，并且返回的结果是int类型。其值和比较的结果关系如下： 负数：＜ 0：= 正数：&gt; 好处： 通过实现Comparable接口，可以让类与所有依赖此接口的通用算法和集合实现来进行相互操作。并且几乎所有的JAVA平台类库中的所有值类都实现了这个接口。 要求： sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) == true (x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) == (x.compareTo(z)&gt;0) == true x.compareTo(y) == 0 —&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z)) (x.compareTo(y) == 0) == (x.equals(y)) 注意，与equals方法不同的是，equals方法有可能花月不同类型的对象，而compareTo遇到不同类型的对象的时候，会直接抛出异常。 注意： 不要使用两个值之间的差值来返回compareTo的结果，这种写法可能会导致整数的最大长度溢出。 使用compareTo方法的时候，应当避免使用 “&lt;”(小于)或”&gt;”(大于)。在具体的值进行比较的时候，应当使用静态的compare或者Comparator接口中的构建方法。 15、使类和成员的可访问性最小化一个良好设计的类应该隐藏它的所有实现细节，仅仅对外暴露API，这样会比较干净。其他的组件，通过API和他们进行交互，并且对他们的内部工作应当一无所知。这个概念被称为封装。 封装的优势： 将组成系统的组件分开，允许他们被独立的开发，测试，优化。 拥有不同功能的组件可以并行开发。 可访问性最小化原则：让每一个类或成员尽可能的不可访问，即尽可能的降低访问级别。 一个顶级类(.java文件中的直接定义的类)或接口的访问级别只能是 default或者public的。如果没有必要将其设置为pubilic，那么我们就应该将其设置为default的。 当我们把一个类设置为public的时候，那么它就拥有导出API的功能，在这种情况下，我们应该有义务维护这个类，让其保持着API的兼容性。当然如果是default的话就没有这个必要，因为它是包级私有的，并不拥有到处API的功能，仅仅是组件实现的一部分。 如果一个default修饰的顶级类只被一个类使用的话，那么我们应该考虑将这个类作为其使用者的私有静态嵌套类。 对于一个public修饰的类，我们在设计其成员的时候，应该尽可能的将其成员设置为私有的。 注意： 如果一个类存在一个是public且非final的实例属性，那么我们就放弃了限制这个实例的属性被修改的能力，并且当这个实例的属性被修改的时候，我们也并没有解决的方案。 即便是类中的实例属性是final的，也只能保证它引用的对象无法改变而无法保证它引用的对象的属性保持不变。 对所有的静态属性也是如此。我们通过public static final 来表示一个常量。但是，如果其引用的是一个对象，虽然对象的引用无法被修改，但是我们我发保证对象的属性保持不变。 所有的public static final 修饰的长度不为0的数组，我们也应当注意，因为它是可变的。 相关链接：EffectiveJava笔记[一]EffectiveJava笔记[二]","link":"/2019/07/24/EffectiveJava笔记3/"},{"title":"EffectiveJava笔记[四]","text":"EffectiveJAVA的读书笔记(:з)∠) 【序】今天睡懒觉了，差点咕咕咕。(手动换行) 昨天试图分享自己的笔记，结果被吐槽只是抄书。这句话的对做为尝试写总结性质读书笔记的新手(我)的打击性其实是很大的。花了近3小时写的文章(姑且算是)，结果被别人看了一眼就说你这就是抄书，没有技术含量，也不算是原创。 无能狂怒：这是本人初次尝试通过记录笔记并公开分享，也是尝试对费曼学习法的一次尝试，如果你不喜欢或者觉得没有任何价值。只能抱歉，这确实是我的问题，请自行关闭。这个系列我还是会写，可能后期渐渐改变写作风格。当前的格式很受此书的影响（这本书本来就是总结性质的），只能说前几篇确实是写得太过于仓促有一点依葫芦画瓢的感觉吧。 为什么做这个系列：在才开始看EffectiveJava的几天，我其实是并没有这个打算的，因为此书本身是总结性质的，但是由于有不少的地方比较难，在网上搜索相关的内容大多都是完整的抄书没有得到实质性的讲解。所以打算自己总结来加深理解。 定位：帮助自己学习和理解JAVA，当然希望对别人有用。 16、在公共类中使用访问方法而不是公共属性关键字：public类，访问方法，public属性 在JAVA里面，对于那些需要对外提供某些属性的类。比较建议的一种写法是对外提供访问方法(getter和setter)而不直接将这些属性设置为public的。曾经有人问过我这个问题，为什么要这么做，我并不知道，只觉得这是封装思想的一种体现。 如下（例子源于书上）: 123456789101112131415161718192021222324252627//不建议这样写class Point { public double x; public double y;}//建议这样写class Point { private double x; private double y; public double getX() { return x; } public void setX(double x) { this.x = x; } public double getY() { return y; } public void setY(double y) { this.y = y; }} 理解： 这其实是类和成员可访问性最小化的一个体现。外界通过唯一public的API来获取数据。类本身将其具体的实现隐藏，这样内部的实现无论怎么改只要返回给外界他们期望的值即可。相对的，如果直接将属性提供给外界的话，那么在一个成型的代码系统中，这个属性就几乎没有再修改的余地了。 例外： 如果一个类是包级私有的或者是一个私有的内部类，这样写是被允许的。理由很简单，它们对外提供的属性的作用范围太小了，并不会出现上面提到的那种问题。而且这样写的可读性更强，不是吗？(手动斜眼) 17、最小化可变性关键字：可变性 首先我们给不可变的类一个基本的定义： 不提供任何修改对象状态的方法 不能被继承 所有的属性均为final。(即便这个属性是private的，因为你无法保证在编写逻辑的时候不修改某个属性的值，而设置为final后，当你不经意修改的时候会出现错误提醒你) 所有的属性应该是private的。（其实设置为public并不会出现任何问题，但是这违背了条目16的建议） 确保对任何可变组件的互斥访问。(这是什么意思呢？？？) 理解： 在创建的一开始它的状态就被确定了，状态在它存在的整个生命周期均不会发生任何改变。 线程安全的，不需要线程同步。因为不可变的对象的所有属性都是只读的，它并不会因为多线程的同时访问而出现同步问题。 可以自由的分享，也没有必要创建很多个副本或者考虑防御性拷贝。 缺点： 为每一个不同的值都需要创建一个单独的对象，导致性能问题。 总结： 除非有很好的理由能够说明一个类应该是可变的，否则尽量将其设置为不可变的。 18、组合由于继承关键词：组合 ，继承 跨越包级的继承很危险(对类来说)的。 破坏了封装的思想：子类有可能会依赖父类的一些实现细节，但是父类改变后，可能会导致子类无法使用。 重写父类的方法不一定有效：在出现了上面的问题的时候，一个解决方案就是重写父类的方法，但是如果这个逻辑涉及到一些父类中的私有属性的话，那么将无法实现。(子类并不能访问父类的私有属性) 随着父类新版本的发布，父类可能会提供新的方法。但是这可能会对子类进行破坏(如果正好子类拥有一个相同名字参数和返回类型的方法)，从而导致编译不通过。 组合： 不继承一个现有的类，而是在新的类里面持有一个私有的现有类的对象。对于现有类的一些实现，新的类实现一个同名方法并在内部调用现有类的方法。 优点： 新类并不依赖现有类的实现细节，所以现有类的修改并不会对新类产生影响。 理解： 这是一种基于包装类的思想，即设计模式中的装饰者模式。 这种设计模式并不等同于委托 注意： 包装类中不适合使用回调，因为某一些设置回调的方法对象会将自我的引用返回出来，但是被包装的对象是并不知道它的外界存在一个包装器，所以它仍然会返回一个自身的引用。 总结： 适合使用继承的情况：只有子类真的是父类的子类型的情况下才适合使用继承。即两者中存在”B is A”的关系，才应该让B继承A。 19、要么设计继承并提供文档说明，要么就禁用继承如题，字面意思。 可继承的类： 如果一个类是可以被继承的话，那么我们应该提供详细的文档说明 详细描述重写某一个方法会带来的影响。 应当说明可重写方法的自用性 应当详细的列出任何可能调用可重写方法的情况 测试一个为继承而设计的类的唯一方法是编写子类进行测试 构造方法里面不能直接或间接地调用可重写的方法 禁用继承： 如果无法提供很好的设计或文档，那么就将此类设置为final以禁用继承 总结： 设计一个可继承的类需要提供详细的文档，并且需要很大程度上限制这个类的功能。 如果不得不继承一个没有提供详细文档的类，最好的方法是不调用任何可重写的方法（消除父类自用可重写方法的可能性）。 20、接口优于抽象类关键字： 接口，抽象类 JAVA对于抽象类只允许单一继承，而对于接口来说可以多实现。 理解： JAVA对类的继承的结构是垂直的，也就是说一个类继承了它的父类，那么它就一定满足”A is B”的描述，也就是说，它的根源是被确定了的。 但是接口只是一种实现，它对外表述的是”A can be B”，这表示A是多变的，它强调了A是具有某一些行为是符合它被作为B的要求，所以它应该是有多种实现的。 抽象类过分的强调了层级关系，这对于我们并不能准确定义某一些类的层次。比如说一个程序员也可能是一个作家，但是如果使用抽象类我们就无法给它一个精确的定义。 实现了接口的类可以很方便的实现其他接口以更新功能，但是如果是实现了抽象类，那么就会比较麻烦。 接口是定义mixin（混合类型）的理想选择，它保证了一个类除了提供自身类型以外，还能够提供某些可以选择的行为。 相关链接：EffectiveJava笔记[一]EffectiveJava笔记[二]EffectiveJava笔记[三]","link":"/2019/07/24/EffectiveJava笔记4/"},{"title":"这是一篇非常详细的View事件分发机制的源码分析文章","text":"这是一篇带有非常详细注释的关于View事件分发机制的源码阅读笔记（onTouchEvent的坑还没有填，无配图） 我不管你看不看得懂，反正只要我看得懂就行了，手动斜眼 首先我们来看一看ViewGroup的onTouchEvent方法。 _ (:з)∠) _ 不要骂我懒哇，我也知道其他的大佬的blog又有图片流程，又有文字说明。主要是确实是没有办法嘛，时间有限，所以先挖个坑，以后有机会就补 （逃。 ViewGroup.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363public boolean dispatchTouchEvent(MotionEvent ev) { //省略掉开头的一些看不懂的代码... //dispathcTouchEvent的返回值 //用于表示当前的View(ViewGroup是否消耗了此次点击事件) boolean handled = false; //一个安全策略，主要用于过滤屏保的时候的点击事件的分发 //如果被拦截了，那么dispatchTouchEvent直接返回false if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // ACTION_DOWN的时候，会将之前的状态清理 if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); // FLAG_DISALLOW_INTERCEPT会被重置为空 // mFirstTouchTarget在这个方法中被重置为空 resetTouchState(); } // 用于判断此ViewGroup是否拦截这个事件 // 两种类情况 // (1)、MotionEvent.ACTION_DOWN,即这是一次点击的事件(按下去,还未抬手) // (2)、mFirstTouchTarget != null：首先说明，这种情况一定不是ActionDown(不考虑多点) // 有可能是ACTION_MOVE 或者 ACTIION_UP // 同时也表示了此ViewGroup在最近的一次ACTION_DOWN事件 // 所导致的dispatchTouchEvent返回的结果是true。 // (因为如果是False的话,那么DecorView的mFirstTouchTarget是空的,后续的点击事件就不会通过 // DecorView的mFirstTouchTarget传递下来，那么这个View就一定不会收到除了ACTION_DOWN外 // 的所有的事件。 // 同时因为mFirstTouchTarget不为空，即说明了此View的dispatchTouchEvent返回true是因为 // 此parent有child消耗了这个ACTION_DOWN // // // 同时这里也反应了另外一个策略， // (在一个事件序列中)parent的dispatchTouchEvent一旦返回了true // 那么在后续的事件序列中: // (1)、dispatchTouchEvent一定不会被再次调用 // (2)、后续的所有TouchEvent一定会被这个parent拦截， // (3)、后续的所有TouchEvent均会触发这个parent的消耗 // (4)、这个parent的mFirstTouchTarget链表会被移除 // (5)、这个parent的所有子View一定不会接受到后面传来的事件 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { intercepted = true; } //表示此View是否被Cancel掉了 //cancel的消息来自于其parent //当在处于非ACTION_DOWN的事件序列中的某一个事件，且被其parent拦截了 //那么其parent仍然会调用此View的dispatchTouchEvent,但是传递过来的 //event是ACTION_CANCEL, 通知此View清空自己的mFirstTouchTarget final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; //一个引用，用来指向在ACTION_DOWN事件来的时候 //新加入到mFirstTouchTarget链表中的节点 //同时会用于一些在多点触控中的判断 TouchTarget newTouchTarget = null; //防止消耗了ACCTION_DOWN的child在添加到了 //mFirstTouchTarget之后再次被调用 //dispatchTouchEvent这个方法的一个标志 boolean alreadyDispatchedToNewTouchTarget = false; //注意：这里的代码块的执行和actionDown没有说明关系！！！ //actionMove 和 actionUp 均会进入这个代码块 //内部有一个单独的关于ActionDown的判断 if (!canceled &amp;&amp; !intercepted) { //省略部分(或许)无用(主要是看不懂)的代码 //用于找出能够消耗点击事件的子View //并通过调用子View的DispatchTouchEvent方法 //来判断子View是否会消耗会这个点击事件 //注意：遍历会一直持续到有子View返回了它将消耗此事件结束。 //也就是说，对于哪些Z轴在上但是并不打算消耗点击事件的子View //它们的dispatchTouchEvent均会被调用 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; final int childrenCount = mChildrenCount; //这里的newTouchTarget一定为null //单点的情况下mFirstTouchTarget一定为空 //因为前面的ActionDown把mFirstTouchTarget重置了 if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); //将所以的child按照Z轴的顺序，创建一个List //z值越大的在越上面 final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); //这里的cutomeOrder并不是说子View的顺序就是按照人为自定义的 // //这里有一个先前条件，就是preorderList == null //在内部代码里面我们可以看到，如果所有的child的Z均是0的话 //那么preorderList就是null，这种情况下子View会根据 //draw的顺序去拿 //这里我们推测，当用户设置了setChildrenDrawingOrderEnabled(true) //的时候，所有的子View的Z轴均是0 final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); //所有的子View构成的数组 final View[] children = mChildren; //遍历整个childList //其实不是childList,而是将child通过z轴的值进行排序的一个List //就是上面提到的preoderList // //然后从上至下寻找能够接受整个点击事件的child //再调用child的dispatchTouchEvent //判断child是否消耗这个点击事件 for (int i = childrenCount - 1; i &gt;= 0; i--) { //因为有上面的customer标志位，所以实际上遍历的子View的顺序 //并不一定是按照Z轴，也就是说在这个方法里才会真正拿到 //子View的位置，即确定子View的遍历顺序 //(1)、preorderList重前至后的顺序 //(2)、View的绘制顺序 //(3)、mChildren的逆序，及child被add的顺序 final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); //获取这个child final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); //这个方法会判断子View是否能接收到这个点击事件 //这里还没有调用子View的dispatchTouchEvent //如果子view不能够接受的话，就说明这个点击的点在子View的范围外 //直接continue // //同理，只有下面的代码块只有能够接受到点击事件的child才能够被执行 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } //注意：能接触到此代码块的child一定能够接受点击事件 //遍历整个mFirstTouchTarget,寻找child是否在mFirstTouchTarget //中出现过。 // //这里在单点的情况下一定是没有的,所以这个方法的针对的是多点的情景。 //可能是防止多点的时候多个ACTION_DOWN作用到了同一个View上 //导致被多次调用了dispatchTouchEvent的情况 //到目前 mFirstTouchTarget 还是null newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { newTouchTarget.pointerIdBits |= idBitsToAssign; break; } //调用dispatchTransformedTouchEvent // // 这里注意一下，上面传下来的child一定是非空且能够接受点击事件的 // //因为进入方法块的条件是mChildren.length &gt; 0, //且不能接受点击的被continue了 // //这里的主要作用是调用Child的dispatchToucEvent方法 // // 调用自己onTouchEvent(super.dispatchToucEvent())方法是在下面 // //这个判断条件进入了之 //也就是说dispatchTransformedTouchEvent返回了true就直接break了 //可能后面也有子View能够接受点击事件,但是均不会被调用 //dispatchTouchEvent方法了 // //如果返回了false,只有一种条件，有child能够接受这个点击事件，但是child不 //打算消耗它(比如说child实际也是一个ViewGroup) //所以这种情况下，继续遍历寻找其他能够接受点击事件的child，看他们 //是否打算消耗这个点击事件 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { mLastTouchDownTime = ev.getDownTime(); //进入了这个方法块其实就已经表示了child能够接受这个点击事件了 //这里需要遍历一波children，来标志最后一个被点击的child //注意，这里的Index是指的在chidren数组中的index if (preorderedList != null) { for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } //记录一下最后一次TouchDown的位置 //猜测和多点触控有关 mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //这个方法会将child添加到mFirstTouchTarget链表中 //这会使得newTouchTarget和mFirstTouchTarget都不为空 // //注意这里的break： //也就是说，只要有一个child消耗了点击事件，这个循环就已经退出了 //即：对于任何(单)点击事件来说，mFirtTouchTarget中只可能存在 //一个元素，就是消耗actionDown的那一个child newTouchTarget = addTouchTarget(child, idBitsToAssign); //这个标志位用于后面防止再调用一次dispatchTransformedTouchEvent alreadyDispatchedToNewTouchTarget = true; break; } } //preorderList已经没有用了,释放内存 if (preorderedList != null) preorderedList.clear(); } //考虑到这个代码块是处于ACTION_DOWN的前置条件的 //这里实在想不到newTouchTarget == null但是 mFirstTouchTarget 不是 null //的场景，猜测可能和多点触控有关，这里我们就先不管 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } //如果有子View消耗了点击事件的话，mFirstTouchTarget会指向消耗事件的child //此时child的dispatchTouchEvent方法已经被调用了 // //ViewGroup自身的super.dispatchTouchEvent方法是在这里被调用的 //即：ViewGroup自身的onTouchEvent是在这里被调用的 // //对于ViewGroup，如果其子View消耗了这个点击事件，那么它将不会被调用onTouchEvent //但是它仍然会对其上级ViewGroup表示它已经消耗了这个点击事件(尽管是它的child消耗的) if (mFirstTouchTarget == null) { // //mFirstTouchTarget 是空就说明这个ViewGroup的所有child均没有消耗这个点击事件 //强调：不是说child接受不到，只是说child没有消耗. //即: 能接受点击事件的child的dispatchTouchEvent方法,返回的是false // //注意，这里所说的消耗是dispatchTouchEvent(onTouchEvent)向上级返回的结果 //而默认情况下(对于ViewGroup来说)，这个方法的返回值是false //这里要排除一个情况，就是clickable的情况 //补充：如果view是clickable的话，就要单独考虑 // //以下为调用自己的super.dispatchTouchEvent --&gt; onTouchEvent handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // //遍历整个mFirstTouchTarget链表 //一般来说这里的链表应该只有一个元素，就是之前能够接受点击事件的元素 //在这个链表的遍历中，只要有一个child的onTouchEvent返回了true,那么此方法就会返回true // TouchTarget predecessor = null; // &lt;--指向链表的前驱 TouchTarget target = mFirstTouchTarget; // //注意这里是一个while，会被调用多次的 //下面会提到，如果parent打算拦截child的话，会将TouchTarget移除 //也就是说，parent打算拦截，整个接受传递事件的序列均会被移除 //(先不管resetCancelNextUpFlag 这个方法) while (target != null) { final TouchTarget next = target.next; // //可以看到，前面创建的newTarget是用来暂存那个消耗了点击事件的child的 //这个判断只会针对actionDown,因为在任何的非down的action,newtarget都是null if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { // //ActionDown的后续事件序列将会进入这个代码块 //因为newTouchTarget为空，并且mFirstTouchTarget非空 // //前面提到了onInterceptTouchEvent是在整个事件序列中均进行判断的 //也就是说在后续的事件序列中onInterceptTouchEvent仍然会被多次调用 //只要有一次onInterceptTouchEvent方法返回了true，那么后面的整个事件序列 //均会被整个ViewGroup所消耗了,并且在这一次事件中会把所有的能够接受事件的child //移除，也就是说，即使这个事件序列后面parent不拦截了(比如说滑动) //这些事件仍然不会被分发给这些child(因为mFirstTouchEvent已经被移除了) //注意，这里会调用child的dispatchTouchEvent //但是会给child传递一个cancel事件 // //!!!!!!注意一下这里的resetCancelNextUpFlag方法 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { //前面提到touchTarget是一个链表的结构 //如果一个点击事件被ViewGroup拦截了的话 //ViewGroup会把链表中的这个touchTarget节点移除掉 //如果是第一个节点，就直接把mFirstTouchTarget移除 if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } //被发送cancel的TouchTraget，直接被recycle了 //即被发送了cancel事件的子view会从TouchTarget链表中移除 target.recycle(); target = next; continue; } } predecessor = target; target = next; } } //三种情景 //(1)、接受到了Parent传来的cancelEvent //(2)、此次事件是ACTION_UP //(3)、此次事件是ACTION_HOVER_MOVE // //此ViewGroup会清空其mFirstTouchTarget //并且会把FLAG_DISALLOW_INTERCEPT也重置 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); // //看不懂。。。。。 } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } // //看不懂。。。 //大概就是通知该事件被忽略掉了 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled;} 相比ViewGroup，View的onTouchEvent方法就相对来说简单很多了。我们只需要注意一下这个方法对于onTouchEvent的判断逻辑就行了。 View.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public boolean dispatchTouchEvent(MotionEvent event) { //省掉一些看不懂的代码 boolean result = false; //mInputEventConsistencyVerifier用于检测这个输入的 //事件序列是否完整和Log通知用户的 //比如说用户点击事件的ActionDown被此View消耗 //但是因为开发者在自定义ViewGroup中错误的拦截逻辑 //导致了ActionUP事件未传递到这里来 //那么这个类将会检测到这种问题，并且在Log中通知 if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } //如果是ACTION_DOWN的话，会尝试停止嵌套滚动 //由于本人对嵌套滚动的原理并不太熟悉 //但是点进去可以看到，里面其实就是把嵌套滚动的相关标志清除了 //这里可以联想ViewGroup的dispatchTouchEvent方法 //在ACTION_DOWN的时候，也会重置整个View的事件序列 final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { stopNestedScroll(); } //同ViewGroup一样，onFilterTouchEventForSecurity 是一个安全策略 //主要是用来拦截屏保下用户的误触 // //先宏观的看一下这个代码块 //(1)、几乎所有的判断逻辑都是返回的true //(2)、onTouchListener的onTouch方法在这里被调用 //(3)、onTouchEvent 方法在这里被调用 // //也就是说ViewGroup只有调用了super.onInterceptTouchEvent //才会调用onTouchEvent方法 // //这里有一个要注意的地方，就是第一、二个判断条件 //和第三个判断条件，也就是调用onTouchEvent的方法是互斥的 //也就是说，只要View设置onTouchListener并且返回了true //的话，View的onTouchEvent方法是不会被调用的 if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } //如果不进入安全策略才可能会进入这个代码块 //这个代码块其实没啥用，就是Log通知一下 //这个Event并没有被这个View消耗 //前面提到已经谈了InputEventConsistencyVerifier的功能 //这里就不在赘述 if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } //同ViewGroup一样，在ACTION_UP的时候 //View自身也会尝试清理View事件序列的状态 if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result;}","link":"/2019/09/16/ViewEvent/"}],"tags":[{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"SourceCode","slug":"SourceCode","link":"/tags/SourceCode/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"源码阅读","slug":"源码阅读","link":"/categories/源码阅读/"}]}