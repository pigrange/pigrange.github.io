{"pages":[{"title":"About Me","text":"Hello Traveler我是 johnPig 你也可以叫我pigrange。UESTC 信息安全大三狗一枚(截至2019年)，典型的理工男，白日梦想家，人形自走BUG(哦不，状态)机。爱听音乐，爱追番，也喜欢阅读。 误入歧途的Android程序员，梦想是成为懂全栈的Advanced Android System Engineer。虽然很遥远，但是好在并未打算放弃，目前正朝着目标一步一个脚印的前进(emmm 先把Cpp的坑填了再说_ (:з)∠) _ )。 我并不打算将此个人博客做大做好或者做出名，搭建此博客发布文章的唯一目的在Android学习生涯中留下一些足迹。所以如果你偶然发现了这里，那必定是我们的缘分。另外，我也不打算开启评论功能，所以如果你发现文章的内容的错误或者有什么问题的话，都可以通过jiangpigcheng@gmail.com和我联系。当然我也很希望能够通过这个渠道接触到一起探索Android开发的朋友。 如果我的文章对你有用，那么我深表荣幸。","link":"/about/index.html"}],"posts":[{"title":"View的事件体系基础","text":"这里整理了一些关于View事件体系的一些基础的知识点，而有关View事件分发机制的部分，我单独攥写了一篇关于事件分发源码阅读的文章，所以这里就不再进行总结归纳。 1、View的基础知识什么是View： Android所有的控件的父类，是界面层的一种抽象 View的结构和前端的DOM相似，View也可以有一组控件组成 View的位置参数： 四个顶点： top : 上边界的y左边 left ：左边界的x坐标 right：右边界的x坐标 bottom：下边界的y坐标 注意： 四个顶点的位置是相对于父容器来说的，如果还需要获取一个View的绝对坐标的话，需要代入它所有的parent的四个顶点的坐标来进行计算。 View如果是通过设置translationX/Y来改变View的位置坐标的话，其四个顶点的位置并不会发生改变。 坐标与宽高的关系： width = right - left height = bottom - top 其它位置参数： y = top + translationY x = left + translationX 滚动位置参数： scrollX = getScrollX scrollY = getScrollY 注意：滚动位置参数并不会修改View的实际位置。此参数平移的是View的内容，而View本身并不会被修改 点击的位置参数：对于一个点击事件，使用x 、y 或 rawX 、rawY 来实现View的点击位置的获取 getX() : 返回点击事件距离(消耗此点击事件的)控件左边的距离 getY() : 返回点击事件距离(消耗此点击事件的)控件上面的距离 getRawX() : 返回点击事件距离整个屏幕左边的距离 getRawY() : 返回点击事件距离整个屏幕顶上的距离 2、View交互相关的一些类 MotionEvent ： 封装了点击事件的类 TouchSlop ：系统能够识别的滑动的最小距离，是一个常量 获取方式：ViewConfiguration.get(getContext().getScaledTouchSlop()) VelocityTracker : 用于计算滑动速度的，作用的单位是MotionEvent GestureDector：一个手势检测的工具类。可以用来在TouchEvent中实现一些较为复杂的收拾的检测。 这个类会拦截View的监听操作，所以如果使用这个类的话，监听器要单独注册。 推荐用于监听双击操作 Scroller： 一个用于View弹性滑动的对象 本质上是一个封装好了的插值器。 3、实现View滑动的方式Layout： Layout方法最终会调用onLayout来设置View的位置 故可以在View滑动的过程中，不断的调用Layout方法来更新View的位置 LayoutParamas： 在LayoutParams中通过设置LayoutParams的LeftMargin属性和TopMargin属性来更新View的位置 设置后调用setLayoutParams方法实现重绘(内部封装了requestLayout方法，并且做了相关判断) scrollTo 注意，这个方法改变的是View内容的内容而非View本身的位置 此方法是不会导致View重新绘制的,所以需要对View使用invalidate方法 使用动画 XML动画：控制View的translationX 和 translationY 属性 ObjectAnimator：相对稍微复杂一点，需要对View的动画属性设置getter和setter ValueAnimatior：使用简单，兼容性强，本质上也是一个插值器，需要手动更新View的位置坐标 各种滑动方式的对比： scrollTo/scrollBy : 操作简单，适合对View的内容进行滑动 动画：操作简单，适合对没有交互的View和实现复杂的动画效果 改变布局参数：操作稍复杂，但是适合有交互的View","link":"/2019/09/15/Android2/"},{"title":"EffectiveJava笔记[一]","text":"EffectiveJAVA的读书笔记 [一] _ (:з)∠) _ 1、考虑使用静态工厂方法代替构造方法：静态工厂方法的优点： 拥有名字，更加容易阅读 不需要每一次调用的时候都创建一个对象，可以对实例的数量进行严格的控制 可以返回其返回类型的任何子类型的对象 可以根据传入参数的不同而返回不同类型的对象，（构造方法只能返回自己的对象） 在编写包含该方法的类的时候，返回的对象的类不需要存在。 缺点： 如果只提供静态工厂方法，那么它就有可能没有public或者private的构造方法，也就是说无法被子类化。 没有一个统一的对静态构造方法的命名的规范，导致可能很难找到他们。 2、当构造方法的参数过多的时候，使用Builder模式:静态工厂方法和普通的构造方法都无法很好的解决构造方法中参数很多且可选的参数很多的问题。 使用构造方法的缺点： 过多的方法重载，导致非常的繁琐 并且在获取类的实例的时候可选(参数)的构造方法太多，以至于降低可读性 1、JavaBean模式： 通过一个无参数(这里指可选参数)的构造方法来创建对象，然后调用一系列setter方法来设置参数 缺点： 代码较为冗余 由于是实现创建好了对象在设置值，所以在多线程的情况下无法保证对象参数的一致性（也就是说先创建好了对象再去设置参数，无法保证在创建过程中对象的不可变的） 2、Builder模式： 客户端不直接创建对象，而是通过一个builder预先配置好对象的每一个可选参数，然后通过builder的build方法来生成对象，这样产生的对象就是不可改变的，Builder通常是它所构建的类的一个静态的成员。 3、使用私有构造方法或枚举来实现单例单例通常表示的是无状态的对象。比如说一个只提供函数功能的对象或者一个系统组件。 1、实现单例的方式： 创建一个静态final的自身引用，并私有构造方法 提供一个公共静态方法用于返回自身的单例。 注意，对于构造方法，应当在请求创建第二个实例的时候抛出异常，因为Java的反射机制可以调用private的构造方法。 2、单例与序列化： 如果单例的对象需要支持序列化的话，那么仅仅将这个类直接实现Serializable接口是不行的，这个问题正好是前面应该注意的点的良好反应。 当使用ObjectInuptStream对对象进行反序列化的时候，Java会通过反射去调用类的无参构造方法(尽管它是私有的)，当然如果按照我们前面的实现，那么很有可能在反序列化的时候直接抛出了异常(因为请求创建了第二个实例) 解决方案： 在单例类中提供一个readResolve方法，并在这个方法中返回我们的单例对象。 4、使用私有构造方法来执行非实例化这个条目是直接基于EffectiveJava直译而来。通俗来讲就是对于那些只用于提供静态方法或者静态属性的类(比如某些Util工具类或者config配置文件)，我们应该避免他们被创建实例或者继承，因为并没有任何意义。 采取的操作： 将类设置为final，避免被继承 将类的构造方法设置为私有，并在代码块里面抛出异常(防止别人通过反射来创建实 5、依赖注入优于硬连接资源这个又是显得异常的高大上。至少对于我来说，看见依赖注入就觉得这个是高大上且较难的东西，并且第一遍读这个条目的时候也没有搞明白这个到底是啥。 其实弄明白了什么是依赖注入，这个条目就非常的简单了。 依赖注入： 依赖：举个比较普遍的例子。我把我自己比作对象a，我的电脑比作对象b。如果我需要写这篇blog，我就需要我的电脑，也就是说a依赖于b。 依赖注入：对于a依赖的对象b，我们不应该在a的类中直接创建b的实例，而是提供b的设置api或者通过构造方法将b的引用传入。也就是说将a的依赖b注入给了b。 这样做有两个好处，一是b的生命周期并不用需要a来进行管理。二是对于多个依赖b的对象，如果b是不可变的，那么可以实现b的复用。 虽然通过接口传递依赖也是一种实现，不过不推荐这么做，因为在并发的环境中，这是非常容易出错的。除非我们的对象非得支持多种依赖，那么最好的解决方式还是将其设置为final然后再通过构造方法传入。 依赖注入的有用变体： 将资源工厂传递给构造方法。","link":"/2019/07/24/EffectiveJava笔记1/"},{"title":"EffectiveJava笔记[四]","text":"EffectiveJAVA的读书笔记[四] _ (:з)∠) _ 16、在公共类中使用访问方法而不是公共属性关键字：public类，访问方法，public属性 在JAVA里面，对于那些需要对外提供某些属性的类。比较建议的一种写法是对外提供访问方法(getter和setter)而不直接将这些属性设置为public的。曾经有人问过我这个问题，为什么要这么做，我并不知道，只觉得这是封装思想的一种体现。 如下（例子源于书上）: 123456789101112131415161718192021222324252627//不建议这样写class Point { public double x; public double y;}//建议这样写class Point { private double x; private double y; public double getX() { return x; } public void setX(double x) { this.x = x; } public double getY() { return y; } public void setY(double y) { this.y = y; }} 理解： 这其实是类和成员可访问性最小化的一个体现。外界通过唯一public的API来获取数据。类本身将其具体的实现隐藏，这样内部的实现无论怎么改只要返回给外界他们期望的值即可。相对的，如果直接将属性提供给外界的话，那么在一个成型的代码系统中，这个属性就几乎没有再修改的余地了。 例外： 如果一个类是包级私有的或者是一个私有的内部类，这样写是被允许的。理由很简单，它们对外提供的属性的作用范围太小了，并不会出现上面提到的那种问题。而且这样写的可读性更强，不是吗？(手动斜眼) 17、最小化可变性关键字：可变性 首先我们给不可变的类一个基本的定义： 不提供任何修改对象状态的方法 不能被继承 所有的属性均为final。(即便这个属性是private的，因为你无法保证在编写逻辑的时候不修改某个属性的值，而设置为final后，当你不经意修改的时候会出现错误提醒你) 所有的属性应该是private的。（其实设置为public并不会出现任何问题，但是这违背了条目16的建议） 确保对任何可变组件的互斥访问。(这是什么意思呢？？？) 理解： 在创建的一开始它的状态就被确定了，状态在它存在的整个生命周期均不会发生任何改变。 线程安全的，不需要线程同步。因为不可变的对象的所有属性都是只读的，它并不会因为多线程的同时访问而出现同步问题。 可以自由的分享，也没有必要创建很多个副本或者考虑防御性拷贝。 缺点： 为每一个不同的值都需要创建一个单独的对象，导致性能问题。 总结： 除非有很好的理由能够说明一个类应该是可变的，否则尽量将其设置为不可变的。 18、组合由于继承关键词：组合 ，继承 跨越包级的继承很危险(对类来说)的。 破坏了封装的思想：子类有可能会依赖父类的一些实现细节，但是父类改变后，可能会导致子类无法使用。 重写父类的方法不一定有效：在出现了上面的问题的时候，一个解决方案就是重写父类的方法，但是如果这个逻辑涉及到一些父类中的私有属性的话，那么将无法实现。(子类并不能访问父类的私有属性) 随着父类新版本的发布，父类可能会提供新的方法。但是这可能会对子类进行破坏(如果正好子类拥有一个相同名字参数和返回类型的方法)，从而导致编译不通过。 组合： 不继承一个现有的类，而是在新的类里面持有一个私有的现有类的对象。对于现有类的一些实现，新的类实现一个同名方法并在内部调用现有类的方法。 优点： 新类并不依赖现有类的实现细节，所以现有类的修改并不会对新类产生影响。 理解： 这是一种基于包装类的思想，即设计模式中的装饰者模式。 这种设计模式并不等同于委托 注意： 包装类中不适合使用回调，因为某一些设置回调的方法对象会将自我的引用返回出来，但是被包装的对象是并不知道它的外界存在一个包装器，所以它仍然会返回一个自身的引用。 总结： 适合使用继承的情况：只有子类真的是父类的子类型的情况下才适合使用继承。即两者中存在”B is A”的关系，才应该让B继承A。 19、要么设计继承并提供文档说明，要么就禁用继承如题，字面意思。 可继承的类： 如果一个类是可以被继承的话，那么我们应该提供详细的文档说明 详细描述重写某一个方法会带来的影响。 应当说明可重写方法的自用性 应当详细的列出任何可能调用可重写方法的情况 测试一个为继承而设计的类的唯一方法是编写子类进行测试 构造方法里面不能直接或间接地调用可重写的方法 禁用继承： 如果无法提供很好的设计或文档，那么就将此类设置为final以禁用继承 总结： 设计一个可继承的类需要提供详细的文档，并且需要很大程度上限制这个类的功能。 如果不得不继承一个没有提供详细文档的类，最好的方法是不调用任何可重写的方法（消除父类自用可重写方法的可能性）。 20、接口优于抽象类关键字： 接口，抽象类 JAVA对于抽象类只允许单一继承，而对于接口来说可以多实现。 理解： JAVA对类的继承的结构是垂直的，也就是说一个类继承了它的父类，那么它就一定满足”A is B”的描述，也就是说，它的根源是被确定了的。 但是接口只是一种实现，它对外表述的是”A can be B”，这表示A是多变的，它强调了A是具有某一些行为是符合它被作为B的要求，所以它应该是有多种实现的。 抽象类过分的强调了层级关系，这对于我们并不能准确定义某一些类的层次。比如说一个程序员也可能是一个作家，但是如果使用抽象类我们就无法给它一个精确的定义。 实现了接口的类可以很方便的实现其他接口以更新功能，但是如果是实现了抽象类，那么就会比较麻烦。 接口是定义mixin（混合类型）的理想选择，它保证了一个类除了提供自身类型以外，还能够提供某些可以选择的行为。 相关链接：EffectiveJava笔记[一]EffectiveJava笔记[二]EffectiveJava笔记[三]","link":"/2019/07/24/EffectiveJava笔记4/"},{"title":"寄夏予你","text":"这是一篇回忆暑期时间管理的文章，本来打算是用作综合实践课程用的，不过可能用不上了，干脆就收录到这里吧。 TO-DO task is not a shcedule task 你最终因为leetCode某道题卡了太久，导致下午至晚上一直在做，所以你后面的事情都没有做完. 你非常不情愿的给自己打上了11分的低分, 抱怨第一次尝试就没有及格. 你很快发现这个问题是显著又普遍的，因为大多数时间是无法确切的, 所以你难预测道明天会发生的突发事件.于是翻看了知乎,查阅了各种大佬的成功案例 , 发现原来是自己太不自律了, 明明todo-list都著名了不能超时做leetCode但是还是深陷其中不能自拔, 于是你在今天的todoList上把不要超时几个字写的更大,并在睡觉之前把这几个字又默念了几遍. 第二天,前面看书你都非常严格的遵守了, 但是唯一的问题是leetCode还是没有在限定的时间内想出解法 , 于是你非常不情愿的准备切换至下一个任务(尽管现在的问题还未得到解决)，并且尝试在本子上记录下现在自己的思路，保留一波现场.但是这样做并没有任何用. 到了第三天, 你尝试回到昨天的现场解决那个还没被填上的坑. 当你翻回昨天的那一页的时候 , 你朝着作业本上那一堆自己也看不懂的公式摇了摇头, 想了想今天有限的作业时间, 默默的将作业本翻到了下一页. 第四天,你大刀阔斧的开始休整自己的todo-list , 删掉了自己的运动 , 压缩了自己的阅读.再来一个弹性日程安排 , 把各种详细的task划分到一起 , 然后 , 你的todo-list 变成了这样. 然后,很快你就发现了新的问题 , 你发现你和平时做着同样的事情 , todo-list并没有给你带来任何作用. 因为对于一个又不玩游戏, 假期闲的要死的你来说, 你的日常就是这样的. 不仅如此, 你也再也无法对今天的任务进行评估和打分,除了吃饭的两分稳稳到手外, 其他都是大大的问号. 于是你开始回忆你昨天做了哪些事情, 然而你发现 , 你似乎确实做了很多事情 , 但是始终有一种空虚感 , 因为说不清楚你到底干了什么… 另外,你开始逐渐意识到,你在一些琐事上面花了非常多的时间: 比如你花了55分钟吃饭，中午花了1个半小时睡觉，但是你睡午觉的大多数时间是用来躺在床上玩手机的, 又比如, 你明明是早上7点就起床了, 本来计划8点抵达图书馆, 但是当你到达图书馆的时候, 你手机上面的时间8 后面 已经四十好几了. 你告诉自己, 我应该严格管理我的时间分配 , 让我的每一段时间都过的有价值. 转眼道到了开学，你把你的todo-list改成了这样 (详细估算各种事情了时间的花费, 计算出了明天大致的空闲时间,并给自己提供了一些时间来解决意外情况 , 同时将你的一天化为了很多时间段 , 并且不对详细的时间段指明确切的任务) 即使是忙碌的周四,我们也有至少7个半小时的时间用于自有安排 忙碌的一天终于结束了, 但是你却丝毫没有一丝惬意 , 你觉得你早上一大早跑去图书馆却在那一小时无所事事, 因为才刚开学, 虽然有课 但是 却没有作业, 于是你在早上那一个小时简单的看了一下go语言的官方文档 , 但是到了晚上你质问自己为什么要去看现在并用不到的东西 , 你便开始后悔 , 为什么我那一个小时不用来记一记单词. 照着这份todo-list 你坚持了几天 感觉每天都过的非常的充实. 但是 , 很快你又发现了新的问题: 效率 , 你恍然大悟 , 你似乎明白了为什么感觉每天做了很多事情却似乎又觉得没有什么收获 , 你似乎也明白了为什么暑假天天做这么多事情却还是每天觉得很空虚. 你从操作系统系统老师那里得知了并发切换CPU状态会消耗资源.你学以致用 , 发现 , 你每天这样频繁的切换自己的任务不就是处于一个高并发的状态吗? 于是你又回想起了你暑假的某一个下午… Focus on one thing8月的某一天上午 , 你在图书馆 , simply repeat what you did yesterday. 突然接到了家住郫县亲戚的电话. 于是你心想给自己放个假也不错, 就背着电脑驱车前往. 但是亲戚家里实在是太无聊了, 你便拿出了电脑, 继续看 &lt;&lt;java多线程核心技术&gt;&gt;. 很快你看书犯困的老毛病就又犯了, 于是你打算小憩一会. 2个小时过去了… 你睁眼一看 , 已经下午三点了, 我天 , 怎么睡了这么久? 你慌了, 觉得自己虚度了光阴. 于是你非常懊悔, 关掉了手机 , 掏出了ipad , 打开了电脑. 定位到了pdf第53页, 一遍做笔记一边啃. 5个小时过去了… 你离开了亲戚家回到了学校 . 你又打开了电脑, 掏出ipad , 继续啃&lt;&lt;java多线程核心技术&gt;&gt;… 3个小时过去了… 你长舒一口气 , 终于把第三章看完了. 什么! 把第三章都看完了! 你才缓过神来. 你注意了一下书的目录 , 你居然看到了第199页, 你感觉难以置信 , 又看了看你的ipad , 发现你做了31页的笔记! Core task and Non-core task你回到了现实. 意志坚定, 思考片刻 , 参照java的线程池 , 给自己设计了两个todo-list, 一个core-todo-list , 用于缓存要做长期要做且要做很久任务, 一个non-core-todo-list 用于缓存短期要做且能短时间就昨晚的任务. 回到现在,屏幕前的你终于在第1777个字处结束了自己的回忆. 你思考了一下,觉得这个文案写的还算可以,打算将他交给你的组长审阅. 但是跳跃的思维又让你想到了昨天, 你为了准备后面实习的面试 , 从昨天早上到深夜11点都在写一篇技术博客. 你感叹那篇仅仅一小时就能读完的7477字的源码分析竟然写了整整一天, 你也感慨自己居然就用了一天就把它写出来了. 你又满意了打开了自己的blog , 对着那篇文章浏览了一遍, 你觉的无比充实 .对于读者, 那7477个字可能显得普通还缺乏文采甚至略微晦涩, 但是对于你来说, 那是无尽的财富, 因为你已不再迷失方向. —–不愿透露姓名但乐于分享自己经历的吃瓜群众","link":"/2019/09/22/寄夏予你/"},{"title":"Activity的生命周期与启动模式","text":"这是这个系列的开篇，主要内容是Android相关知识点的整理。其内容内容来自于《Android开发艺术探索》的整理，故我也把它当作是复习开发艺术探索的读书笔记。 一、Activity的生命周期1、正常情况下Activity的什么周期:正常情况下，Activity经历的生命周期如下： onCreate() 表示Activity正在启动，这里编写用户的逻辑，比如数据的准备，视图的创建，Listener的注册。 这个方法调用的时候，Activity还未被创建好，也不可见。 onStart() 在perfromStart中调用 callActivityOnstart方法 &lt;— final 方法 表示当前的Activity正在被启动，on starting的意思。 在这个状态下，Activity已经可见了，但是由于没有出现在前台，所以不可见。 这个方法会在onCreate之后执行，所以这个时候Activity已经被创建好了 这个方法会将onStart指令分发给所有的子Fragment。(fragmentActivity中) onRestart Activity没有被完全销毁，重启的过程。 这种情况下，一般是用户的Activity离开前台退回到后台所导致的。 这个方法是在onStart()之前调用的。 补充：这个方法实际上是在performResume中调用的，performResume会首先调用perfromRestart，由于才创建的Activity的mStoped是false，所以perfromRestart直接return了，而performRestart里面会调用perfromStart来间接调用onStart方法。 performStart方法最终会将View变得可见(目前还不清楚具体的实现在哪里) onResume() Activity在onStart之后就已经创建完成。onResume是将其添加到window上，让其可见。 也就说onResume的时候Activity才正式显示到前台。 onPause() 表示Activity正在停止，这个方法是在onStop之前被调用的。 这个方法里面应该做一些停止动画的操作，但是不能太耗时。 这个方法会在新的Activity的onCreate方法调用之前被执行，所以如果这个方法耗时的话，新的Activity会被强制等待。 onStop() 表示Activity即将被停止，这个方法也同样不能太耗时。但是这个方法会在新的Activity的onResume之后才被调用。所以在调用这个方法的时候Activity已经变得不可见了。 说明：因为这个方法是在performStop里面调用的，而performStop里面会WindowManager将View从Window中移除了，onStop是在移除RootView之后被调用的。 onDestory() 表示Activity即将被销毁。用于做一些资源的释放。 注意：在内存不足的情况下从而导致Activity的非正常结束，这个方法是不会被回调的。 对应关系： onCreate -&gt; onDestory onStart -&gt; onStop onResume -&gt; onPause 注：对应关系并不是完全对应的，只是说宏观的流程下，这几个方法有如下的对应关系。 2、异常情况下Activity的生命周期异常情况下Activity的生命周期如下： 资源相关的系统配置发生改变导致Activity被杀死并重新创建 资源内存不足导致低优先级的Activity被杀死 （1）配置改变的情况(注意，这种情况activity算异常终止)： Activity会依赖于系统资源，如果系统的状态发生了改变会导致Activity所依赖的系统资源发生改变，因此Activity会进行重建。 手机的屏幕进行了旋转，Activity会进行重建(完全的重建)。 这种情况下Activity会被销毁，其onPause , onStop , onDestory均会被调用。 这种情况会调用activity的onSaveInstanceState方法 此方法会保存window的层级状态(通过调用window的saveHierarchyState方法) —&gt; Activity的视图结构 此方法会保存所有的fragment状态 此方法会保存所有的outfill状态（这个是什么东西？ 当系统重建的时候Activity会调用onSaveInstanceState方法。 因此，也可以在这个方法里面对保存的状态进行恢复 注意：这里保存的状态是是Boundle，故需要用Parceble来进行状态的保存。 （2）内存资源不足导致的Activity被重建的情况： 注意：在这种情况下，Activity的onSaveInstanceState方法也是会被调用的 Activity的优先级： 前台 可见但是并非前台：onStop没有被调用 后台：onStop方法被调用了 Avtivity脱离了四大组件很容易被杀死 对于Activity的配置发生了改变的情况，可以强制指定onConfigChange来拒绝系统重建Activity 在Manifast中指定configChange这个属性即可 注意：对于屏幕发生改变的情况，还需要指定screenSize属性 二、Avtivity的启动模式：任务栈：(1)任务栈是和App(包名)相绑定的 (2)注意任务栈是有前台和后台之分的。 (3)Activity不可见并不等于Activity就在后台的任务栈中。 一个Activity可能会有多个任务栈 任务栈通过taskAffinity进行指定 (4)出现前后台两个任务栈的例子： App1启动，打开了Activity A和Activity B 用户点击了Home，返回了主界面，此时App的所有任务栈回归后台。 用户启动了App2，并且通过App2的Activity启动了App1的Activity C Acitivity C是 singleTask，并且没有指定taskAffinity(即默认的) Activity C在前台任务栈，Activity A B 在后台任务栈。 四种启动模式： Standard: 标准模式，谁启动这个Activity，就压进启动者的任务栈，无复用机制，不绑定taskAffinity，始终创建新的实例。 SingleTop: 栈顶复用模式，有栈顶复用机制，其他的和Standard一样，不绑定taskAffinity SingleTask：栈内复用模式，绑定taskAffinity，三个强调点，如下： 系统会在指定的Task栈中创建新的Activity，并且在这个Task栈中实现单例，如果不指定Task栈的话，那就是默认的任务栈 (taskAffinity为包名) 尽管可能会在新的任务栈中创建Activity，但是点击返回会将焦点转移至原来的Activity，而不是这个Activity栈的下一个(当然也可能是，这个得看启动它的Activity所在的栈)。 这个Activity会在这个任务栈中实现单例，并且被赋予焦点的时候会将上面的所有Activity全部出栈。 如果前台任务栈启动了后台任务栈的方法，会把整个后台任务栈搬到前台来 这种情况，点击返回就会将此栈一一退出，因为后台栈已经和前台栈合并了 SingleInstance：全局单例的模式，Activity会维护一个自己的栈，并且这个栈中就只有这一个Activity。 android:taskAffinity属性：用于标记Activity所属的Task，默认的情况下值为应用的包名。 LaunchMode 为 singleTask的Activity LaunchMode为singleInstance的Activity 使用flag＝Intent.FLAG_ACTIVITY_NEW_TASK启动的Activity LaunchMode和Intent Flag的对应关系： FLAG_ACTIVITY_NEW_TASK &lt;==&gt; SingleTask FLAG_ACTIVITY_SINGLE_TOP &lt;==&gt; SingleTop FLAG_ACTIVITY_CLEAR_TOP： SingleTask默认带有ClearTop标志 如果Standard/或者SingleTop设置了FLAG_ACTIVITY_CLEAR_TOP的话，如果栈内有，会将当前栈的上面的全部去掉(包括原有的Activity)，再创建一个新的实例。 启动模式的指定： 通过配置AndroidMenifest实现 通过在Intent中设立标志位来实现 比较： 第一种的优先级更低 第一种无法为Standard设置ClearTop 第二种无法实现SingleInstance 三、IntentFilter的匹配规则：IntentFiler 用于匹配隐式的Intent 三个匹配规则：注意：三个匹配规则需均满足才能匹配成功。 action 匹配规则 category 匹配规则 data 匹配规则 Action： Activity可以设置多个 Intent只有能够匹配让其中的一个即可 如果不设置的话，就永远匹配不上 对于Intent来说，Intent只能设置一个Action属性 category： Intent和Activity均能够设置多个 intent设置的categoriy需要均匹配上 如果intent不设置，则其会设置默认的DEFAUT 对于Activity，需要设置DEFAULT来接受Intent中DEAFULT的匹配条件 Data 实际上只需要匹配两个内容： URI MimeType 由于URI结构比较复杂，故在注册Activity的时候，需要对URI的每一个结构单独设置匹配条件 Activity的Data可以设置多个 Intent的Data需要完全匹配上Activity中的其中一个才能通过 Intent中通过Uri.parse(string) 指定Uri，指代MIME的string 指定MimeType setData 和 setType有冲突，如果都要匹配，需要调用setDataAndType方法 URI的schema必须指定此URI才有效(才能够接受匹配) 判断是否有Activity能够匹配Intent： PackgeManager.resolveActivity方法 Intent.resolveActivity方法(其实就是调用的PM的resolveActivity方法，只是做了封装)","link":"/2019/09/13/Android1/"},{"title":"EffectiveJava笔记[二]","text":"EffectiveJAVA的读书笔记 [二] _ (:з)∠) _ 6、避免创建不必要的对象此条目下作者有这个观点：当你应该重用现有对象的时候，请不要创建新的对象 最突出的就是字符串常量创建的例子： 1String str = new String(\"hello\"); 如上所述，本来在字符串常量池中就存在字符串”hello”，但是我们又创建了一个新的字符串”hello”的实例，显然，这个新的str实例是并不需要的。 使用静态工厂方法： 构造方法一定会创建一个新的对象，但是其实很多时候并没有这个必要。对于一些可以重用现有对象的情况，我们可以使用静态的工厂方法来获取实例（因为静态工厂方法是九二一对实例进行严格控制的）。 缓存创建昂贵的对象： 对于那些可以复用的但是创建昂贵的对象，我们可以将其设置为公共静态的，这样既可以避免重复创建带来的性能开销，也可以避免持有这个对象的容器对象在失去引用后被GC清理掉。 注意，这里很容易进入一个误区，就是对那些(可能)会重用的对象都进行缓存。 这个条目并不代表对象的创建是昂贵的。其实通过构造方法创建和回收对象的性能开销并不高。 作者在此条目的下面提到： 除非池(对象缓存)中的对象非常重量级，否则通过维护自己的对象池来避免创建对象其实并不太好，因为者会显著的加大内存的占用。 回到条目的开始，我们应该将重点放在重用和不要创建新的对象上面。也就是说，我们更多应该考虑的是在重用某个对象的时候，尽可能的去避免创建新(没有必要)的对象。 7、消除过期的对象引用：这里有一个误区，就是JAVA拥有垃圾收集机制，所以我们就不需要手动对内存进行管理了。 但是，其实这个是不一定正确的，内存泄漏在JAVA里面太频繁了。 作者在书中提到当一个类自己管理内存时，程序员应当警惕内存泄漏，书中举了一个栈弹出的例子： 12345public Object pop() { if (size == 0) { throw new EmptyStackException(); } return elements[--size]; 可以看到，这种实现实际上仅仅是将size的-1了。但是elements任然保留着对size外的元素的引用，也就是说那一部分的元素的内存并不会被GC释放掉。 解决方案： 12345678public Object pop() { if (size == 0) { throw new EmptyStackException(); } Object result = elements[--size]; elements[size] = null; return result;} 8、避免使用Finalizer和Cleaner机制这可能对JAVA新手来说一脸懵逼(没错，我就是这种。因为压根就不知道什么是Finalizer，这里就不谈Cleaner机制了，因为我现在还是不会，不过功能应该和finalizer差不多) 对于C++程序员，我们知道有一个析构函数用于回收资源。 Finalizer机制： GC在回收对象之前调用其finalize方法，但是这并不说明finalize就等于C++的析构函数。finalize方法的调用存在很大的不确定性，也就是说它的调用在不同设备上面的行为具有很大的差异。 当一个对象变得不可达一直到finalize方法的调用这一段时间是任意长的。所以我们千万不要在这个方法里面做一些关闭文件流这种释放非内存资源的操作。因为很有可能出现文件流没有被及时的关闭从而导致后面的文件流打开失败。 finalize机制已经被弃用了。 Java并不能保证Finalizer和Cleaner机制的及时运行，甚至不能够确保他们是否能够运行 System.gc和System.runFinalization 可能会增加finalize被执行的几率，但是不保证其一定被执行 在Finalizer机制中，未被捕获的异常会被忽略，cleaner机制不会有这个问题 Finalizer机制会严重影响垃圾收集的效率和性能 Finalizer机制的作用： 作为安全网，防止资源拥有者忽略了他的close方法。这个很好理解，当资源拥有者忘记close的时候，通过finalize至少可能会关闭资源，着总比不关闭好。也就是说，这个机制虽然不可信，但是聊胜于无。 finalize方法适用于释放一些通过native方法释放的对象(比如说通过JNI创建的对象) 9、使用try-with-resources语句替代try-finally语句可能你刚看到这个条目的时候会和我一样对于什么叫做try-with-resources语句一脸懵逼(本人太菜，之前确实没有见过) 书中举了这样一个例子： 12345678static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); }} 在上述的代码块中，有可能由于文件流的没有正常打开导致异常出现。同理，由于引用了空的对象，br无法正常调用close方法。那么在这次情况下第二个异常会完全覆盖掉第一个异常。如果使用了catch语句块捕获了异常，那么代码就会变成如下的样子： 123456789101112131415static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } catch (IOException e) { e.printStackTrace(); } finally { try { br.close(); } catch (Exception e) { e.printStackTrace(); } } return null;} 这种代码，写出来简直辣眼睛。反复的异常捕捉显著的降低了代码的可读性。 使用try-with-resources语句： 1234567static String firstLineOfFile(String path) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch (IOException e) { return defaultValue; }} 相较于之前的代码，显然可读性有所提高。 原理： 能够使用try-with-resources语句的资源类其实都自动实现了AutoCloseable接口这个接口提供了一个无参数的close方法。也就是说，使用了try-with-resources语句声明的资源只要实现了这个方法，那么都会在抛出异常之前调用close方法关闭资源。另外，用于资源对象的close方法是由其自己控制，所以我们也不需要考虑资源文件关闭所产生的异常。 10、重写euquals方法时应当遵守的通用约定不需要重写equals方法的条件： 每一个类的实例都是一个固有且唯一的。 类并不需要提供一个逻辑相等的测试功能。 父类已经重写了equals方法。一个设计良好的可继承的父类应保证其子类完全实用于父类的equals方法。 类是private修饰的或者default修饰的，那么这个类的equals方法应该永远不会被调用。 需要重写equals方法的条件： 一个类包含逻辑相等的概念，并且父类并没有提供equals方法。这里特指一些表示值的类，比如Ineger或者String类。 使用equals方法的时候应当比较的是对象逻辑上面的相等，而并不是比较是否引用的是相同的对象。 当某一个类需要作为Map的key的时候。 equals方法应当满足的属性： 自反性：一个对象必须和自身相等 对称性：a.equals(b) == b.equals(a) 传递性：a.equals(b)，b.equals(c)，则a.equals(c) 一致性：相等的对象永远相等，不相等的对象永远不相等 非空性：所有的对象都不等于null 编写高质量的equals方法： 首先使用==运算符检查参数是否为该对象的引用，如果成立直接返回true，这是一种性能优化。 应当使用instanceof检查传递参数是否有正确的类型，因为equals方法默认传递的参数是Object类型的 将参数进行强制类型转化 对于参数的每一个值属性，应当验证值属性是否相等，注意，对于float或者double类型，不要用==而是使用Float.compare或者Double.compare方法比较。 对于参数的对象属性，应当递归的对持有的对象进行equals比较，由于对象引用可能为空，所以对引用对象进行比较的时候，应当使用Object.compare方法 使用equals方法进行比较的时候，应当首先考虑最有可能不同的属性，这也是一种性能优化。 不要忘记验证自己实现的equals方法是否满足上面提到的5个属性。 注意事项： 重写equals方法的时候，应该重写hashCode方法 不要对equals方法太过于吹毛求疵，这可能会因为考虑因素太多导致实现非常困难。 重写equals方法的时候，参数是Object类型的，不要将参数替换成其他的类型。","link":"/2019/07/24/EffectiveJava笔记2/"},{"title":"View的工作原理","text":"前面整理总结了View的事件体系，那么接下来我们再来看看View的工作原理吧。和前面一样，这篇文章主要是对知识点进行一些总结归纳，而涉及源码的部分，我会单独写一篇文章来详细分析。 两个比较重要的类：ViewRootImpl:注意：这个类虽然名字和View有关，但是其并不继承自View，可以说在实现上和View没啥关系，整个ViewTree的根View是DecorView，而对DecorView的直接持有者又是PhoneWindow(这里我们不说parent，因为phoneWindow不是View的子类)。 这里要说明一点，虽然PhoneWindow直接持有了DecorView的引用，但是由于职能的限制(如果PhoneWondow再去管理View就太臃肿了)，PhoneWindow的实例并不直接对当前Activity的DecorView进行管理(PhoneWindow更多的是和Activity进行交互)，所以Android才引入了ViewRoot这个控制层(或者说叫handler？)，来使WindowManager间接的管理Windows下的View。 ViewRoot作为PhoneWindow和DecorView之间的桥梁，直接控制了DecorView以及整个ViewTree的测量、布局、绘制、以及事件分发的工作。另外，它还代理了WindowMnagerGlobal负责和WindowManagerSercvice进行直接通信来调整窗口位置的大小以及对来自于WMS的事件进行相应的处理。 整个View树的PerformTraversal是通过ViewRootImpl开始的，而ViewRoot的PerformTraversal内部会一次调用PerformMeasure，PerformLayout，PerformDraw三个方法，这三个方法将会对顶层的View即DecorView依次进行mesure，layout和draw，而mesure，layout，draw的内部又会调用View的onMeasure, onLayout , onDraw方法。而如果这个View是一个ViewGroup的话，其onMeasure, onLayout和Draw的dispatchDraw又会调用其子View的Measure , Layout , Draw 方法。在这个递归调用下。整个View树就完成了测量，定位，和绘制的工作。 DecorView:DecorView是View树中的顶层View，是ViewGroup的子类，是比ContentView还要顶层的视图。一般情况下，用户是不需要和DecorView进行交互。 DecorView的结构: TitleBar: 用于挂载Actionbar ContentPatent: 用于挂载ContentView ​ 注意：这里所说的挂载实际上是通过addView添加上去的，这里的ContentParent实际上是一个ContentFrameLayout，这里命名为ContentParent只是为了说明其地位的特殊，而不是说这就是一个特殊的类。我们可以通过在DecorView中调用findViewById(android.R.id.content)获取到它。 MesureSpecMesureSpec是一个32位的Int类型，用于表示一个父View对child的约束类型和能提供的最大的空间。也就是说，这一个int值表示了两个数据。其中它的高2位，用于表示测量的类型，而低30位用于表示测量的大小。这样做有一个好处，就是省掉了为了传递一组数据创建一个对象在内存上面的开销(光是对象头就占用了8个字节了，如果是用数组的话，对象头12个字节，更大)。 组成： MesureMode UNSPECIFIED: parent不约束child，child想要多大就给多大。 EXACTILY: parent确定child有多大了，child在拿到之后就是自己的最终大小。 AT_MOST: parent确定child的最大的大小，child拿到后再根据自己的需求设置自己的大小 注：这里为了便于理解，先暂时不考虑View有背景的情况 MesureSize parent 提供给child的尺寸的数值，用于建议child应该多大 谈一谈LayoutParamas和MesureSpec：可以说在View的测量这一块，LayoutParamas和MesureSpec的组合起到了决定性的作用。 LayoutParamas 是child告诉parent的 child通过LayoutParams告诉parent自己的dimension是什么(Android把matchParent和wrapcontent也算作dimension了，只不过是特殊的标志，前者为-1，后者为-2). MesureSpec 是从parent返回给child的 parent通过LayoutParamas获取了child的意图后，结合自生的情况(自身的MesureMode，MesureSize，margin，padding等)，计算出child的大小，并将其封装为MesureSpec后返回给child。 对于UNSPECIFIED我们一般不考虑，这个只有在多次测量的时候才会出现。 对于MesureMode是WrapContent的场景简单解释一下：这个时候parent是不知道child实际上应该是多大的(因为它并不知道child有哪些内容)，所以这个时候，提供给child一个最大的值，让child自己搞，只要不超过这个范围就行了。 可能有些人会说了，既然child能够通过LayoutParams知道自己的测量模式是啥，那为啥还需要MesureMode呢？这个问题我也考虑过，也想问，猜测有两个因素，一个是有UNSPECIFIED的存在那么MesureSpce必须再带一个附加信息，另外一点就是涉及LayoutParams的职能问题。Child确实可以通过LayoutParams获取，但是一旦这么做，就模糊了LayoutParams的概念。这显然是不太清真的(雾)。 注意：对于DecorView，其MesureSpec是在自身中创建的，而不是由parent分发下来的。因为它的parent就是phoneWindow了，大小是确定的。 对MesureSpec的一些总结：引用网络上的一张View 的MesureSpec创建规则的表 这个其实很好理解： 只要记住三点(这里我们就不考虑UNSPECIFIED了)： child指明了自己的大小是多少dp/sp的时候，parent不会对child做任何限制，mesureMode一定是EXACTLY，而measureSize一定是child在LayoutPrama中的大小。也就是说View的大小是在测量前就一定确定好了的，但是这了还是要强调一下，大小虽然确定的，但是位置是未知的，还是得在layout之后才知道。 child是MATCH_PARENT的时候，只要它的parent(向上递归)存在一个ViewGroup是WRAP_CONTENT，那么它的size就会变成(伪)WRAP_CONTENT。而其他情况，那么就是父View提供的measureMode就是EXACTLY. 这里做一下解释为什么是(伪)WRAP_CONTENT，因为如果子View不对WRAP_CONTEN做特殊处理的话，那么它的实际效果和MATCH_PARENT是一样的.(这个我们后面在源码里分析) child是WRAP_CONTENT的时候就很简单了，它从parent那里得到的mesureMode一定是AT_MOST。 (真)View的工作原理前面bb太久了，差点没有抓住重点。 因为后面打算单独做一起结合源码分析View的工作原理。因此，这里只对View的工作原理做一些步骤上的描述。 Msasure过程： 完成了View大小的测量 由Measure方法和onMeasure方法组成(实际上是在Measure方法里面调用了onMeasure方法) mesure方法是一个final的方法，而提供给开发者可以重写的是view的onMeasure方法。 onMeasure提供了parent传来的mesureSpec，View的实际的宽、高实际是在onMeasure里面设置的 如果这个View是一个ViewGroup，那么还会调用mesasureChildren这个方法去测量它的所有的child。 Layout过程： 完成了View位置的确定 由layout方法和onLayout方法组成(同上，实际上是在Layout中调用了onLayout) Layout方法不是一个final方法，可以被重写。View的具体位置是在layout中设置的 onLayout是用于ViewGroup来确定child的位置的 View的MeasuredWidth/Height是onMeasure时确定的 View的Width/Height是在layout时确定的，不过两者默认值是相同的，除非重写layout方法 Draw过程：draw的过程就比较简单了，这里我们只需要记住draw里面调用了onDraw即可，对于draw的源码内容的分析，后面我会在源码解读的文章里面进行阐述，下面我们简单看看Draw的具体流程。 绘制背景: drawBackground(canvas) 绘制自己: onDraw(canvas) 绘制自己的子View: dispatchDraw(canvas) 绘制装饰: onDrawForeground(canvas) 绘制焦点: drawDefaultFocusHighlight(canvas) View宽高的获取：这里我觉得有必要单独拿出来讲一讲，因为在我的开发经历中确实在这方面踩过不少的坑。 由于View的工作流程和Activity的生命周期里面是不相同的，所以我们无法在确保Activity生命周期里面的某一函数里面拿到View的宽高。如果你在View的measure或者layout之前尝试获取其宽高的话，那么始终得到的都是0。 下面是一些方法： Activity#onWindowFocusChanged方法 View#WindowonFocusChanged方法 当DecorView绘制完成Activity正准备显示出来的时候，会回调Activity#onWindowFocusChanged这个方法 view.post(runnable) 用的比较多，也是比较推荐的方法(因为写起来比较方便)。 使用ViewTreeObserver ViewTreeObserver可以注册GlobalLayoutListener , 当ViewTree的内部由一个View的可见性发现改变的时候 将会回调onGlobalLayout方法。但是要注意，这个方法会被调用很多次，所以这里只提一个思路，我本人并不推荐这个写法。","link":"/2019/09/18/Android3/"},{"title":"View工作流程[一]：Measure测量","text":"我不管你看不看得懂，反正只要我看得懂就行了 —— john pig 写在前面：哭了，本来打算想先了解了解setContentView，如果内容不多的话，就放在这里和View的measure(准确的说应该是ViewRootImpl#PerformTraversals) 一起来讲的，结果debug看了一晚上，发现AppCompactActivity在DecorView和FrameContent之间又加了2层，找了一晚上的PhoneWindow的setContentView，结果搞了个subDecor。难受得一批。 现在的心情就是填坑，填着填着发现这是一个无底洞。。。_ (:з)∠) _ 好吧，又挖一个坑。争取本周之前把ContentView和View的工作流程都撸出来吧…(得找个时间学一下UML图 本来打算把整个View的事件流程写到一篇文章的，但是工作量巨大，并且很有可能字数劝退。所以干脆分开，这样的话你们看起来也舒服，我写起来也高产(雾)，实不相瞒，还是因为这个坑太深了，不知道什么时候才填的完，所以能写一点是一点，一步一个脚印，做起来也更容易，看起来也更有成就感(嘿嘿嘿)。 我先说一个基本原则，对于普通的View它的measure方法一定是被其parent调用的(ViewTree的递归调用)，所以研究ViewTree的某一个节点的意义不大，所以我这里我贴一个DecorView的measure是如何被调用的，这样对于整个View工作流程的开端有一个较为准确的认识. ViewRootImpl#PerformTraversals() ViewRootImpl#measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight) ViewRootImpl#getRootMesasureSpec(windowSize,rootDimension) ViewRootImpl#performMeasure(childWidthMeasureSpec, childHeightMeasureSpec) DecorView#measure(childWidthMeasureSpec, childHeightMeasureSpec) View#measure(childWidthMeasureSpec, childHeightMeasureSpec) View.java#measure()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public final void measure(int widthMeasureSpec, int heightMeasureSpec) { // //判断当前View是否有光学边界 //我并不知道光学边界有什么用，但是这并不妨碍我们对源码的解读 boolean optical = isLayoutModeOptical(this); //对于DecorView，其ViewParent是PhoneWindow //这里对于DecorView和其Parent都是返回的false //所以下面的不等条件不成立，不进入下面代码块 // //这里判断一下parent是否和自己一样是使用了有光学边界的View if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } //讲widthMeasureSpec和heightMeasureSpec组合成一个64位长的数据 //用于键，后面我们可以看到，其实View是有缓存了measuredWidth和measuredHeight的 // //这里可以先说明一下 //key: widthMeasureSpec和heightMeasureSpec的组合 //value: measuredWidth 和 measureHeight的组合 long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; // //基于这个方法我们可以知道View的测量是有缓存机制的。 //如果mMeasureCache为空的话，就初始化一个长度是2的数组来缓存 //widthMeasureCache和heightMeasureCache if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); // // //强制Layout的一个标志位，字面意思。apib被隐藏了的 //不是很清楚这个标志位具体有什么作用 final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // //字面意思，判断View的spec是否改变。 //如果没有改变的话，应该会省不少事情 嘿嘿嘿 final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; // // 判断View的measureMode是否是EXACTLY //注意，对于DecorView，其MeasureSpec是在ViewRootImpl中产生的 final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; // // //判断当前的View的MeasuredSize时候和MeasureSpec传递下来的值是一样 //这个标志主要是用于在之后View树重绘的时判断View的大小是否改变 final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); // //根据前面的几个标志信息，判断这个View是否需要重新(被)布局 //对于第一次测量，这个标志位一定是返回的true final boolean needsLayout = specChanged &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); // //首先说明：View的onMeasure方法是在这个代码块里面被调用的 //通过上面的判断我们知道 //对于一个mesureMode是Exactly并且大小并没有改变的View //needsLayout是false, //也就是说其onMeasure方法并不会被再次调用 // //相反的，如果view需要layout的话，就进入此代码块 // //注意：这里是needLayout，而这里实际上是measure的方法块 //所以View本身的大小是没有改变的，对于非ForceLayout来说 //可以直接使用之前缓存了的结果 if (forceLayout || needsLayout) { // //清理掉之前的状态标志 mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; // //解析所有的RTL相关的属性 //RTL就是从右到左的意思，这里不用多管，好像有些国家对界面的使用习惯 //和我们是反的，所以对于布局需要修改一下 resolveRtlPropertiesIfNeeded(); // //如果是强制layout的话，会放弃缓存里的内容 //下面的代码我们可以看到，如果cacheIndex是-1那么就重新调用onMeasure //注意：View的setDimension是在onMeasure中完成的 int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); // // 这里解释一下sIgnoreMeasureCache标志 //当Android的版本小于19的话，这个标志就会被置为true //也就是api小于19的话，是不会使用缓存的宽高 if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { onMeasure(widthMeasureSpec, heightMeasureSpec); // //privateFlag我们不做详细了解 //但是这里需要明白：这里将PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT //这个标志清除了即可 mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { //获取缓存的measuredWidth和measuredHeight long value = mMeasureCache.valueAt(cacheIndex); // //直接使用缓存的measure来作为尺寸 //那么我们可以推测，这里缓存的并不是通过measureSpec计算出来的值 //而是通过调用setDimension的最终值 setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // //由于onMeasure方法会最终调用setMeasuredDimensionRaw //而上述方法一定会将PFLAG_MEASURED_DIMENSION_SET设置 //也就是这里的代码块是setMeasuredDimensionRaw失败调用时异常通知的 // （ 不过我想不到setMeasuredDimensionRaw会失败调用的场景 if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(\"View with id \" + getId() + \": \" + getClass().getName() + \"#onMeasure() did not set the\" + \" measured dimension by calling\" + \" setMeasuredDimension()\"); } mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } // //缓存measureSpec mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; // //缓存测量之后的宽和高 mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension} View.java#onMeasure()1234567891011121314protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //可以看到View的onMeasure方法里面很简单 //就调用了一个setMeasuredDimension方法 // //而setMeasuredDimension内部调用了setMeasuredDimensionRaw //所以我们暂时就认为View的宽高的设置就是通过setMeasureDimension完成的 // //这里我们重点分析一下getSuggestedMinimumWidth() //以及getDefaultSize() setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec) );} View.java#getSuggestedMinimumWidth()12345678910111213141516/*** 这里的代码写的比较的难读，所以我重写了一下* 不过这里建议不要太留意代码里面的内容* 而应该着重放法名的含义：获取此View能够接受的最小宽度*/protected int getSuggestedMinimumWidth() { int result; //如果有背景的话，那么宽度就是背景宽度和自己宽度的最大值 if (mBackground != null) { result = max(mMinWidth, mBackground.getMinimumWidth()); } else { //如果没有背景的话，那么能够接受的最小宽度就是mMinWidth res = mMinWidth; } return result;} View.java#getDefaultSize()1234567891011121314151617181920212223242526272829303132/** * View最终确定自己的大小的方法，这里返回的结果就是View在本次测量的最终大小了 * @param size : getSuggestedMinimumWidth返回的结果，也就是View能够接受的最小的大小 * @param measureSpec : parent传递下来的值，用于通知View最终的测量模式和parent建议的值 * * */public static int getDefaultSize(int size, int measureSpec) { // // size是getSuggestedMinimumWidth返回的结果 int result = size; int specMode = MeasureSpec.getMode(measureSpec); // // specSize是parent的建议值 int specSize = MeasureSpec.getSize(measureSpec); // //通过这里我们可以看到，一般来说，child是很听parent的建议的 //对于AT_MOST和EXACTLY都是直接设置parent建议的大小(注意这里我们不考虑ViewGroup) //只有在specMode是UNSPECIFIED的时候child才会采用自己的最小值 // //补充一下：子View的specMode的UNSPECIFIED只会继承自parent switch (specMode) { case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result;} 写到最后： 前面有提到，这些源码的阅读其实是同步《开发艺术探索的》的阅读的。我觉得有必要指出刚哥在书里面提到的 “ViewGroup提供了一个measureChildren方法来测量它的child” 这个观点，其实看了源码我们知道，虽然确实ViewGroup有提供此方法，但是它并没有调用此方法，并且对于ViewGroup的大多实现，它们都是直接在onMeasure里面实现了自己对于Child的测量措施。所以对于ViewGroup的实现，我们不应该刻意去强调它的存在，更多的是把它当作一个通用解决方案或者一种保守策略。比如说当我们自己实现ViewGroup的时候，可以考虑在onMeasure调用measureChildren，来降低我们直接实现的成本开销。 我其实有考虑补一个ViewGroup派生类的onMeasure方法，比如说LinearLayout或者ConstraintLayout，但是粗略看了一下，代码多得吓人，无奈本人时间有限外加这些特定ViewGroup的功能专一性，浪费时间在它们源码的解读上实在有点亏。(千真万确，逃~)","link":"/2019/09/19/View-process-1/"},{"title":"EffectiveJava笔记[三]","text":"EffectiveJAVA的读书笔记 [三] _ (:з)∠) _ 11、重写equals时重写hashCode方法在每一个重写了equals方法的类中，应当重写这个类的hashCode方法。如果不这么做，那么将会违背Object.hashCode的通用约定，从而导致某一些基于hash散列的集合无法正常运行，比如说HashSet， HashMap，HashTable。 规范： 在程序执行的这段时间，如果对象equals方法进行的比较信息没有被改变的话，那么这个对象的hashCode该返回同一个整数。 如果这个应用程序多次执行，那么没有必要保证每一次的hashCode都是一样的。 如果两个对象通过equals方法比较是相等的，那么他们的hashCode应该一样 如果两个对象通过equals方法比较是不相等的，那么他们的hashCode不应该一样。 对于基于hash散列的类来说，如果不重写hashCode方法的话，那么即便他们通过equals方法得到的结果是true，那么将他们作为hashMap的key也无法拿到正确的值，因为他们只是逻辑上相等，而hashMap是基于hashCode寻址的。 hashCode的计算： 为对象中的每一个关键域f，计算其散列码c 1result = 31 * result + c; 返回 result 注意： 如果一个域的值是由其他域演算出来的话，那么这个域不需要用于计算hashCode 如果一个域并没有在equals方法中使用，那么这个域不应该用于计算hashCode 不要排除一些关键的属性来提高hashCode的性能，这可能会降低这个方法的可靠性 在编写完hashCode之后，应当测试hashCode功能的正确性 如果一个对象计算hashCode的代价比较大的话，应当缓存这个hashCode 12、始终重写toString方法虽然Object类提供了toString方法的实现，但是在某些情况它返回的toString并没有什么乱用。提供一个良好的toString方法可以使类更易于使用和调试。 toString方法应当返回对象中包含的所有需要关注的信息 应当在文档中指定toString方法返回的格式 在静态工具类中，编写toString方法是没有任何意义的。 应当在任何抽象类型中定义toString方法，使得子类共享一个公共字符串表示形式 除非父类已经实现了toString方法，否则应该在每一个实例化的子类中重写toString方法。 13、谨慎地重写clone首先需要指出，这个条目是基于Cloneable接口或者说clone方法而列出的。Cloneable接口是一个空的接口，它仅仅用来表明这个对象是允许被克隆的。真正的clone方法的提供是在Object类中。这一点也被作者在书中描述为设计上面的缺陷。 Cloneable接口： 这是一个并未包含任何方法的接口，它的唯一作用就是决定Object类中clone方法实现的行为。换句话说，如果一个类实现了Cloneable接口，那么它就应该在clone方法里面返回对该对象的逐域拷贝，否则就会抛出CloneNotSupportedException异常。 这是一种比较极端的写法，因为它违背了定义接口的作用。 这是一种可以不调用构造器就创建对象的方法。 对于clone方法的一些约束： 1(x.clone() != x) == true 1(x.clone().getClass() == x.getClass()) == true 1x.clone().equals(x) == true 解读： 不得不说，这本书的翻译是真的烂。(:з)∠)_ 上面提到的不调用构造方法就可以创建对象的规定其实太过于强硬，或者享有了太大的特权，想象你好不容易实现了一个单例，并通私有构造方法并抛出异常，甚至提供了readResolve这个方法来保证反序列化也是单例。但是一旦你实现了Cloneable，接口并重写了clone方法，那么你好不容易设计的单例会因为clone而失效。作者指出行为良好的clone方法，应该是可以调用构造器来创建对象的，但是遗憾，clone并没有这么做。 作者强调（通常情况下）(x.clone().getClass() == x.getClass()) == true这个规定太过于软弱。这里我理解了半天。为什么叫过于软弱，因为它不是强制要求的，因为clone指出了不通过构造器就创建对象，但是却允许了(x.clone().getClass() == x.getClass()) != true。举个例子：比如我有一个child类，他继承了他的父类，但是并没有重写clone方法，那么这个方法将最终调用父类的clone。但是很遗憾，父类的设计者并未考虑到这个问题，因为他约定clone的一些约束，允许上面的不等条件出现，所以他使用了构造方法来clone了对象的副本。那么当子类调用clone方法的时候，你会惊讶的发现居然返回的是父类的对象，甚至你无法通过强制类型转化将其转化过来。 为了避免上面的情况，保证子类通过调用super.clone()也返回自己的实例。我们的父类也应该调用自己的super.clone()（父类的父类的clone方法）。在这种层层传递下，所有的super.clone()最终都会调用Object.clone()方法，这样就能保证在整个类的层级结构中，所有的子类的clone()方法最终均会返回Object的对象，由于 Objcet.clone()返回的是对象的逐域拷贝(也就是对整块内存的复制)，所以最终我们只需要进行强制类型转化即可。 很遗憾的是，Cloneable接口并没有清楚的指出一个类实现这个接口应该承担什么责任。 浅克隆： 这里作者列举了一个Stack类的例子： 12345678910111213141516171819202122232425262728public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { this.elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // Eliminate obsolete reference return result; } // Ensure space for at least one more element. private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); }} 我们可以看到，Stack类持有Object数组的应用。当我们克隆这个对象的时候，理想情况下，Stack的elements也会跟随一起被克隆，然而很遗憾，克隆出来的的对象和原来的对象持有相同element对象的引用，也就是说，克隆的时候，只传递了引用。 深克隆： 其实就是针对上面问题的一个解决方案罢了。 对于对象持有的对象引用，我们应当递归(或迭代)地调用这些对象的clone方法。 1234567891011121314151617181920@Override public HashTable clone() { try { HashTable result = (HashTable) super.clone(); result.buckets = new Entry[buckets.length]; for (int i = 0; i &lt; buckets.length; i++) if (buckets[i] != null) result.buckets[i] = buckets[i].deepCopy(); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); }}Entry deepCopy() { Entry result = new Entry(key, value, next); for (Entry p = result; p.next != null; p = p.next) p.next = new Entry(p.next.key, p.next.value, p.next.next); return result;} 克隆的替代方案： 对于那些确定是不可变的类，最好不要实现clone方法，因为这没有意义。 使用拷贝构造器或者拷贝工厂 使用基于接口的拷贝构造器(转换构造器)或者拷贝工厂(转换工厂)。 14、考虑实现Comparable接口compareTo方法并没有在Object类中声明，它是Comparable接口中的唯一方法，其实这个是很好理解的，因为我们并不需要每一个对象都是可以比较大小的。 compareT方法 1int compareTo(T t) 可以看到，这个方法是泛型的，并且返回的结果是int类型。其值和比较的结果关系如下： 负数：＜ 0：= 正数：&gt; 好处： 通过实现Comparable接口，可以让类与所有依赖此接口的通用算法和集合实现来进行相互操作。并且几乎所有的JAVA平台类库中的所有值类都实现了这个接口。 要求： sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) == true (x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) == (x.compareTo(z)&gt;0) == true x.compareTo(y) == 0 —&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z)) (x.compareTo(y) == 0) == (x.equals(y)) 注意，与equals方法不同的是，equals方法有可能花月不同类型的对象，而compareTo遇到不同类型的对象的时候，会直接抛出异常。 注意： 不要使用两个值之间的差值来返回compareTo的结果，这种写法可能会导致整数的最大长度溢出。 使用compareTo方法的时候，应当避免使用 “&lt;”(小于)或”&gt;”(大于)。在具体的值进行比较的时候，应当使用静态的compare或者Comparator接口中的构建方法。 15、使类和成员的可访问性最小化一个良好设计的类应该隐藏它的所有实现细节，仅仅对外暴露API，这样会比较干净。其他的组件，通过API和他们进行交互，并且对他们的内部工作应当一无所知。这个概念被称为封装。 封装的优势： 将组成系统的组件分开，允许他们被独立的开发，测试，优化。 拥有不同功能的组件可以并行开发。 可访问性最小化原则：让每一个类或成员尽可能的不可访问，即尽可能的降低访问级别。 一个顶级类(.java文件中的直接定义的类)或接口的访问级别只能是 default或者public的。如果没有必要将其设置为pubilic，那么我们就应该将其设置为default的。 当我们把一个类设置为public的时候，那么它就拥有导出API的功能，在这种情况下，我们应该有义务维护这个类，让其保持着API的兼容性。当然如果是default的话就没有这个必要，因为它是包级私有的，并不拥有到处API的功能，仅仅是组件实现的一部分。 如果一个default修饰的顶级类只被一个类使用的话，那么我们应该考虑将这个类作为其使用者的私有静态嵌套类。 对于一个public修饰的类，我们在设计其成员的时候，应该尽可能的将其成员设置为私有的。 注意： 如果一个类存在一个是public且非final的实例属性，那么我们就放弃了限制这个实例的属性被修改的能力，并且当这个实例的属性被修改的时候，我们也并没有解决的方案。 即便是类中的实例属性是final的，也只能保证它引用的对象无法改变而无法保证它引用的对象的属性保持不变。 对所有的静态属性也是如此。我们通过public static final 来表示一个常量。但是，如果其引用的是一个对象，虽然对象的引用无法被修改，但是我们我发保证对象的属性保持不变。 所有的public static final 修饰的长度不为0的数组，我们也应当注意，因为它是可变的。 相关链接：EffectiveJava笔记[一]EffectiveJava笔记[二]","link":"/2019/07/24/EffectiveJava笔记3/"},{"title":"View工作流程[二]：Measure布局","text":"我不管你看不看得懂，反正这一次我也没有看懂 😭 —— john pig Android太难了。我太南了。 ViewRootImpl#PerformTraversals()ViewRootImpl#performLayout(lp, mWidth, mHeight)DecorView#layout() 写在前面： 这真的是到目前看的最累的一次，我，真的是看不下去了(我指的是ViewRootImpt的performLayout方法)，太难了，debug跳过去调过来的，递归看着是真的恼火，所以对那里某一些源码的部分描述我就打算说一个大概了。真的是在这个上面熬了不少的时间，但是我特么真的是看不懂啊，递归过去递归过来我怎么知道递归到那里去了呢？ 其他的我也不做过多的描述了，个人觉得这篇文章长度虽然不多，但是内容信息量挺大，建议一遍DEBUG一边看。另外这篇文章的注释已经写的很详细了，就不做过多的文字描述了，后面如果有空的话，会补一个ViewGroup的onLayout方法的解析，今天太累了，就先🕊了。 performLayout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//ViewRootImpl#performLayoutprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { //这个标识符用于标识此View是否在进行Layout //因为下一步就是进行Layout了，所以这里将其设置为true mInLayout = true; //这里的Host就是我们的decorView final View host = mView; //调用host的layout方法，即在这里调用DecorView的layout方法 host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); //Lyout完后将其设置为false mInLayout = false; //判断是否有View在进行Layout的过程中调用了RequestLayout方法 int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) { //过滤一些已经被解决的child view ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) { //将这个标志位置为True，作为requestLayout的一个判断标识 //下面我们会调用缓存的View的requestLayout方法 //由于之前的ViewTree的整个Layout已经结束了 //所以Force_Layout标识已经被置为了0 //所以之后View调用requestLayout //条件判断mParent.isLayoutRequested()会返回false //这会导致整个ViewTree向上递归requestLayout //最终调用ViewRootImpl的requestLayout方法 //但是ViewRootImpl的requestLayout会导致 //其performTraversal的调用，也就是说会导致 //PerfromLayout这个方法被递归调用 //考虑到性能的问题，有很多逻辑是不需要的 // //所以这个标识的作用就是拦截ViewRootImpl接受layout的请求 //通过在performLayout中的某些逻辑来解决。 mHandlingLayoutInLayoutRequest = true; //遍历整个numValidRequests, 对每一个view调用requestLayout // //这里的requestLayout的作用是将其父View链的FORCE_LAYOUT标志位 //全部设置为1，但是并不会真正的在这里对其layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = validLayoutRequesters.get(i); view.requestLayout(); } //对ViewTree进行测量，注意，我们之前看过measure的代码知道 //这里只有被标志位FORCE_LAYOUT的View才会再次被测量 //也就是上面我们request的那个View链 measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); //将Layout标识置为True，标识即将进行Layout mInLayout = true; //进行ViewTree的再次Layout //这里如果child再次调用了requestLayout的话 //处理策略一样，只把当前调用requestLayout的View //加入到mLayoutRequesters中即可，不会影响parent host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); //将mHandlingLayoutInLayoutRequest置为false //这个时候前面的Layout已经完成了 mHandlingLayoutInLayoutRequest = false; //这里的代码是用来解决View出现无尽的递归调用requestLayout的 //比如上述layout中child又调用了requestLayout // //注释我看的不是很懂，主要是理解不到那个奇怪的 noop'd 是什么意思 //不过我们可以猜测，大概就是Android对于这个重复无意义的requestLayout有检测机制 //这里就是将这些View送给相关的判断逻辑 // //猜测用runnable queue的原因： //防止performLayout太耗时以至于系统卡顿或者长时间未响应 //也算是一种优化策略吧 // //这里我有试过直接在View的onLayout里调用requestLayout //最终发现ViewRootImpl的performLayout大概会在调用了3次后 //就不会再调用了，可见这种无效的方法系统是有检测机制的 //但是由于本人的能力有限，所以不做过多描述 validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) { final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; getRunQueue().post(new Runnable() { @Override public void run() { int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = finalRequesters.get(i); Log.w(\"View\", \"requestLayout() improperly called by \" + view + \" during second layout pass: posting in next frame\"); view.requestLayout(); } } }); } } }}//最后把mInLayout 置为falsemInLayout =false;} Layout12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//View#layoutpublic void layout(int l, int t, int r, int b) { // //PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT只有在之前的measure方法 //直接拿的缓存设置的measuredWidth和measuredHeight的时候才会使用 //这里不做过多的描述 if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } //记录之前的四个顶点 int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //根据View是否具有光学边界，调用不同类型的setFrame方法 // //强调：View的四个顶点就是在这里面被确定的 //但是这里面设置的此View的四个顶点的位置 //对于哪些包含有child的View，可能还需要设置child的位置 //而对child四个顶点位置的确定，我们就写在onLayout里面 // //这里返回的值是新的四个顶点是否和之前的四个顶点一样 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); //这里我们先不管后面的标志 //但是可以这么记一下，就是只要View被调用了measure //那么后面的条件就一定成立 //而这里的changed主要是用来解决View仅改变了位置的情况 if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { //View里面什么都没有，但是个人觉得来说其实是比较重要的方法 // //对于自定义ViewGroup来说，这个方法是用于确定其child的位置 //唯二实现方法，当然也可以重写layout（难度较大） //这里传入的四个参数是，ViewGroup的最新的四个顶点的位置 //和它希望通知child自己是否位置改变的一个标识 //~~后面想怎么搞child的位置就是开发者自己的事情了 // //补充：不建议在onLayout方法里面通过手动调用setFrame来让View //基于某一个初始位置有一个偏移量,虽然这样View的位置确实没有问题 //但是会导致后面listener监听的位置有误 // //个人觉得比较理想的实现是在View的构造方法里手动加一个margin //这样才能从根本上(从通知parent上)解决问题 onLayout(changed, l, t, r, b); //移除PFLAG_LAYOUT_REQUIRED标识 mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; //回调一些Listener的onLayoutChange方法 //所以这里也可以拿得到View的坐标，宽高等属性 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;) li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } // //...删掉了大量和View焦点有关的代码 //反正我又看不懂，放在那里凑字数吗？} 再探RequestLayout1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//ViewParent#requestLayoutpublic void requestLayout() { // //首先，前面说过，这个方法在第一次performTraversal的时候一定不会被调用 //这里说一下mViewRequestingLayout这个标识符 //它用来标识整个ViewTree真正调用requestLayout的那个View //这里是true的话，就说明此次调用requestLayout的是整个 //requestLayout事件链的罪魁祸首，需要对它进行一些特殊的处理 if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) { ViewRootImpl viewRoot = getViewRootImpl(); //只要ViewRoot调用了layou方法，而child在layout中又调用了 //requestLayout,那么这里的判断就是true，就会调用下面的 //viewRoot.requestLayoutDuringLayout(this)方法 //而这个方法的就是将这个view加入到mLayoutRequesters中的 if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) { if (!viewRoot.requestLayoutDuringLayout(this)) { return; } } //因为上面有可能会return,这段语句和上面本来是没有关联的 //但是如果上面return的话，可能会引起错误，所以就放下面 mAttachInfo.mViewRequestingLayout = this; } //将View的PFLAG_FORCE_LAYOUT置为1 //将View的PFLAG_INVALIDATED置为1 // //INVALIDATED标识暂时还不清楚，不过猜测和View的重新绘制有关 //FORCE_LAYOUT十分重要，它是这个View在后面的重新measure和layout //中是否真的需要被测量的定位的标识 mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; //这里的代码块是View递归向上传递requestLayout的关键 //而这里的判断语句又是是否使得view向上传递事件的核心 // //isLayoutRequested 方法会判断其parent的FORCE_LAYOUT是否是1 //如果其PARENT是在进行layout的话，那么FORCE_LAYOUT将会是1 //这个标志位会在onLayout之后被重置为0，但是对child的layout是在 //onLayout中实现的，所以这个时候FORCE_LAYOUT仍然是1 if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) { mParent.requestLayout(); } //这里很好理解，把罪魁祸首的标识取消了，不做多的解释 if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) { mAttachInfo.mViewRequestingLayout = null; }} 补一个requetLayout方法的流程图：","link":"/2019/09/23/View-process-2/"},{"title":"View工作流程[零]：从setContentView到measure","text":"我不管你看不看得懂，反正只要我看得懂就行了 —— john pig 这篇文章按道理来说是不应该存在于这里的，但是出于总总原因，我不得不在这里插入这篇文章以作为后面需要了解内容的预备知识。 大量文字预警！！！ 目录： setContentView DecorView的初始化 ContentView的添加 Activity的resume View的工作流程 补充 Choreographer.postCallback ViewParent#requestLayout 写在前面： 在学习View的工作流程的时候，很多人都是直接从measure方法开始讲，或者稍微提到了从ViewRootImpl的performTraversal开始就不在详细说明了。确实Android源码是一个无底洞，深入进去往往无法自拔，很多东西抓住重点学习，可以快速熟悉整个系统的生态，不会在某些细枝末节的地方花上太多的时间。但是我始终觉得，这样学到的知识是零散的，导致我们很多时候很难将某些内容联系起来，这样显然对于Android的更加深入的理解是不利的。 为什么我要将setContenView和measure一起讲： 首先我要说明，这两者是没有关系的。setContentView方法是在Activity的onCreate中被调用的。我一直觉得Google的开发者真的是命名鬼才，对于方法的命名是非常精准的，所以我正好可以借助google的思路所作出强调：setContentView就只做了setContentView，仅此而已 (所以千万不要像我一样在那里死磕setContentView在AppcompactActivity中的实现, 它其实对于View的工作流程没有任何关联。而整个ViewTree的测量，定位，绘制是在Activity的onResume方法之后的某一个时刻被调用的，为什么是某一个时刻呢？因为这里用到了Handler，我们并不能确定handler具体处理整个message的时刻。 但是! ! !，我在学习的过程中发现有不少blog是误导性或者甚至是有错的。他们都过多强调了Window.addView方法的功能，导致一些没有搞清Window和WindowManager的同学很容易在这里去纠结这个方法的具体实现，因为它们会觉得只要View和Window关联起来了，那么contentView在这里就成功的添加到了屏幕上了，所以可能会和我一样，傻乎乎的在setContentView里面去找半天ViewRootImpl的performTraversal方法，然而in vain。 我的理解： JAVA的锅。很大一部分原因是因为JAVA面向对象的语义太强了，导致开发者很容易沉迷于某一个封装好的类的功能中去。然而实际上对于对象来说，我们应重其成员而轻其方法，因为对于类结构，它的所有实例都是共享运行时常量池里方法的引用的。那么对于对象这个数据结构来说，其本质就是运行在堆空间的一块存放数据的内存。那么回到我之前谈的话题，setContentView做了什么事情？其实很简单，就是把ContentView这棵ViewTree挂载到了另一棵ViewTree上，组建成了我们最终需要的ViewTree（这里我们把所有的View就当作数据结构中树的最基本节点），那么核心方法是什么呢？两步： parentView-&gt;child = contentLayout contentLayout-&gt;parent = parentView Android View 设计的锅。先声明，我不是说View设计得不好哇，但是不得不吐槽，View实在是太臃肿了。一个最基本的控件居然有27753行代码，这也间接或直接得导致了许多人对其闻之色变，觉得View是一个又难又高深莫测的存在。个人觉得还是因为View的设计者太省事了，把一大堆方法都往View里面丢(虽然确实和View有关，但是个人觉得拆分成多个类的话可以更加凸显出View的职责)，这也直接导致我在学习整个Android的过程中一直认为View就是一个能够显示的控件，至于它如何被显示，因为它有draw方法，能够在canvas上面画它。其实这种解释是说的过去的，但是不严谨的，因为这会让人把屏幕上的显示的东西和View这个类(或者其实例)绑定在一起。但是，事实是View的显示或者如何做到在屏幕上显示和View的对象本身半毛钱关系的没有，View对象就是一个巨大（成员很多）的数据结构，存放了我们约定的那个逻辑上的视图的一堆信息，这些数据有也好，没有也罢，其实都不会对屏幕上的图像如何显示产生影响(这里要搞明白，我是指图像的产生的过程，也就是到底是怎么被绘制的，不是说图像的大小形状这些最终显现出来的特征)，因为View如何在屏幕上显示(绘制)是通过调用底层的Skia API实现的。 回到最初的问题：在讲setContentView的具体实现之前，我们可以先给其一个不怎么准确但是比较好理解的定义：创建了contentView对象节点和其子View对象节点组成的一个树，(我们就把它们当作View类型的对象的数据结构)，并和PhoneWindow对象进行了关联（这里我刻意说明了对象这两个字，是想强调对象就是一块内存这个基本原则）。 好了，不BB了，上代码。 SetContentView我们先来康康AppCompactActivity的SetContentView做了什么： setContentView (1)12345//AppCompactActivity#setContentView@Overridepublic void setContentView(@LayoutRes int layoutResID) { getDelegate().setContentView(layoutResID);} 是不是一脸蒙蔽，这个Delegate是啥？管它是啥，咱们继续往下看。getDelegate最终返回了mDelegate，而这里的delegate的实际类型是AppCompactDelegateImpl，我们再康康它的setContentView setContentView (2)12345678910111213// AppCompactDelegateImpl#setContentView@Overridepublic void setContentView(int resId) { ensureSubDecor(); #(1) ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); //注意: 这个变量的名字为虽然叫contentParent //但是和后面提到的DecorView持有的contentParent并不是一个东西 //为了防止和后面搞混，我在这里先统一规定contentParent为DecorView的child //而setContentView挂载的parent，我们将其称为ContentFrameLayout contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); #(2) mAppCompatWindowCallback.getWrapped().onContentChanged();} 如果有看过activity的setContentView的朋友可能会觉得这里的代码似曾相识，但是我需要说明appCompactActivity远比ActivityView复杂，通过后面的分析，我们可以了解到，它其实在contentFrameLayout和DecorView之间还引入了两层ViewGroup，其分别是FrameLayout (就是我们后面会提到的subDecor)，和FitWindowsLimearLayout，也就是说，从AppComactActivity开始，我们的ContentFrameLayout并不是直接挂载到DecorView上的，而是挂载在FitWindowsLimearLayout上面的。 另外，为了便于读者理解上面两个比较重要的方法的具体功能，我将下面的内容分成了DecorView的初始化和ContentView的挂载两个小标题。 DeocrView的初始化：扯远了，我们着重康康ensureSubDecor的实现。 ensureSubDecor123456789//AppCompactDelegateImpl#ensureSubDecorprivate void ensureSubDecor() { if (!mSubDecorInstalled) { //ensureSubDecor的核心是createSubDecor这个方法 mSubDecor = createSubDecor(); //...下面的代码都是subDecor创建好了之后才有用的 //不是重点，我们这里不做研究 }} 可以看到，里面调用了createSubDecor这个方法。(哈？为什么是subDecor，那我的DecorView呢？啥时候创建呢? )前面括号里的内容是我第一次看到这里时内心的感受，想必大多朋友和我一样蒙蔽，但是不要慌，咋们继续往下看。 说明一下，这个createSubDecor是一个长达222行代码超长方法，为了阅读体验和文章篇幅，我删掉了大量无关代码，并且对相关方法做了较为详细的描述。 createSubDecor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//AppCompactDelegateImpl#createSubDecorprivate ViewGroup createSubDecor() { // //这里的ensureWindow我们不用多管，对于普通的启动 //我们默认Activity的phoneWindow在这之前就已经创建好了 // //PhoneWindow对象的创建是在Actvity的attach方法里面的 //具体见ActivityThread#performLaunchActivity //里面调用了activity.attatch ensureWindow(); mWindow.getDecorView(); final LayoutInflater inflater = LayoutInflater.from(mContext); ViewGroup subDecor = null; // //下面的这整个代码块都是对subDecor进行创建的 //本质是inflater解析xml文件生成View对象的过程 //因为涉及到很多种场景，所以有很多判断逻辑 if (!mWindowNoTitle) { if (mIsFloating) { subDecor = (ViewGroup) inflater.inflate( R.layout.abc_dialog_title_material, null); mHasActionBar = mOverlayActionBar = false; } else if (mHasActionBar) { // //...删了很多无关代码 subDecor = (ViewGroup) LayoutInflater.from(themedContext) .inflate(R.layout.abc_screen_toolbar, null); mDecorContentParent = (DecorContentParent) subDecor .findViewById(R.id.decor_content_parent); mDecorContentParent.setWindowCallback(getWindowCallback()); // //...删了很多无关代码 } } else { if (mOverlayActionMode) { subDecor = (ViewGroup) inflater.inflate( R.layout.abc_screen_simple_overlay_action_mode, null); } else { subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null); } // //...删了很多无关代码 } // //...这里删除了大量的无关代码 //但是我觉得有必要说一下 //前面不是提到了AppCompatctActivtity在原来的基础上面又多了两层结构吗 //subDecor是多的那一个FrameLayout，而真正持有contentFrameLayout的 //是FitWindowsLinearLayout //这里删掉的代码就是和FitWindowsLinearLayout初始化有关的 // //将subDecor挂载在mWindow上 //这里我并不想分析PhoneWindow的代码 //因为转过去转过来很容易将人转晕 // //只是强调一下，mWindow本质上并不是View //而其setContentView会调用它持有的mContentParent的addView //而mWindow持有的mContentParent是我们在上面创建的DecorView的 //一个名为contentParent的成员，其本身就是DecorView的一个child // //复习一下：DecorView有两个child，一个是titleView，一个是contentParent //我们把SubDecor挂在DecorView上，实际上是把subDecor添加到了contentParent //这个FrameLayout里面 mWindow.setContentView(subDecor); // //...删掉一些没用的代码 return subDecor;} 通过上面的代码，我们可以知道，通过调用了mWindow.getDecorView()创建了DecorView的对象，同时通过ViewInflater创建了subDecor的对象。subDecor的工作流程在这里已经讲的特别清楚了(其实大多数都被我删掉了hhhh)，所以我们着重康康mWindow.getDecorView()这个方法。 再次强调：上述方法完成很重要的两个任务： 创建了DecorView的对象 创建了subDecor的对象 getDecorView12345678//PhoneWindow#getDecorView@Overridepublic final View getDecorView() { if (mDecor == null || mForceDecorInstall) { installDecor(); } return mDecor;} 其实就是做了一层封装，我们在康康installDecor方法。（又是一个200多行的方法，不过被删的只有3行，hhh installDecor12345678910//PhoneWindow#installDecorprivate void installDecor() { // //..删掉了大量的没啥卵用的代码 // //创建DecorView的对象 mDecor = generateDecor(-1); //创建contentParent的对象 mContentParent = generateLayout(mDecor);} 经过重重删减后，可以看到，只剩下了俩方法了，通过名字我们可以了解到，这两个方法主要干了两件事情。 生成了我们的DecorView的实例 生成了ContentParent的实际 我们接下来就来康康generateDecor()到底是如何创建了DecorView的，同样为了阅读体验，我将代码中没有用的部分都删除了。 generateDecor1234567//PhoneWindow#generateDecorprotected DecorView generateDecor(int featureId) { Context applicationContext = getContext().getApplicationContext(); //...删掉了大量没啥用的代码 context = new DecorContext(applicationContext, getContext()); return new DecorView(context, featureId, this, getAttributes());} 好了，找了半天，我们终于找到了DecorView的创建了。挖了这么深，我们也该回头了，要不又得绕晕了hhhh。这个时候我们应该保持头脑清醒，告诉自己，这一切都是在AppCompactActivity的setContentView中被调用的。并且！，到目前为止，我们所作的一切工作都还是在为添加contentView做准备，而我们的主角 — contentView 还没有正式登场。 先别急，都走到这一步了，回头之前，我们还是把最后一个坑填了，简单看看DecorView的contenParent是咋创建的，和前面一样，删掉大量无关代码。 generateLayout1234567891011121314151617181920//PhoneWindow#generateLayoutprotected ViewGroup generateLayout(DecorView decor) { // //...删掉了大量无关代码 //emmm 其实有关的，上面的代码会决定下面会用到的layoutResource具体为 //哪一个ID, 但是这里我们就不深入研究了，假装上面返回的是一个固定的值 // //contentParent实际产生的方法 //具体的实现在DecorView内部，实际上就是通过layoutInflater //去解析xml构建了这个View实例,并且将其和DecorView进行关联 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); ViewGroup contentParent = (ViewGroup) findViewById(ID_ANDROID_CONTENT); // //...删掉了大量有关contentParent初始化的代码 // return contentParent;} 通过上面的代码我们可以发现，contentParent的实际创建是在DecorView的onResourcesLoaded回调中完成的，既然都走到这一步了，我们干脆一气呵成，刨根问底，康康onResourcesLoaded是如何实现的。 onResourcesLoaded12345678//DecorView#onResourcesLoadedvoid onResourcesLoaded(LayoutInflater inflater, int layoutResource) { // //...删掉了多余的代码 final View root = inflater.inflate(layoutResource, null); addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) root;} 好了，看到这里，我们的思路就非常清晰了，其实就是在这个里面通过LayoutInflater 构建了我们的contentParent的实例，并且将其和DecorView关联。 走到这一步，我们对整个DecorView的初始化就非常清楚了，接下来我们就需要具体康康contentView是如何挂载到我们的ContentFrameLayout上的，但是在这之前，我必须强调一下：我在上面的代码分析其实是有错误的，错误的位置是在DecorView的onResourcesLoaded中，实际上这里通过inflater产生的View并不是我们的contentParent，而是一个LinearLayout，我们所说的contentParent实际上是这个LinearLayout的child，但是为了便于大家理解，我在上面的描述中就刻意隐藏这个LinearLayout的存在。 补充说明：在这篇文章中我并不打算谈论ActionBar或者ToolBar的存在。所以我这里的描述是有残缺的，主要还是怕一下子信息量太多难以理解，还有就是ActionBar的工作流程也比较复杂，值得单独写一篇文章来分析它的创建。 这里给一个网上找到的比较准确的View层级关系的图，图中是给出了ActionBar的位置的(黄色框框)，大家选择性忽略就好。(补充一个地方，图里FitWindowsLinearLayout外层的深色框框就是subDecorView没有标注出来，本质是一个FrameLayout)。 ContentView的添加：再次回到AppCompactDelegateImpl的setContentView方法 123456789//AppCompactDelegateImpl#setContentView@Overridepublic void setContentView(int resId) { //ensureSubDecor();已经被调用了，我们不看了 ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mAppCompatWindowCallback.getWrapped().onContentChanged();} 可以看到，这里通过调用了LayoutInflater的inflate方法构建了我们的contentView(及其子View)的对象，并且将其添加到了我们的contentParent上，而这里的contentParent就是我们前面提及到的ContentFrameLayout.(注意这里的其实是给的contentView的xml的id)。 由于上面就是一个很朴实的inflate方法，所以这里我就不多讲了。感兴趣的可以自己去了解一下inflate方法的具体实现。 再多BB一句，setContentView虽然初始化了，DecorView，但是ViewRootImpl还并未被初始化，并且这个时刻AttachInfo也是null. View的工作流程(Activity#Resume)：这里的View工作机制就是我们所说的测量，定位，以及绘制的流程，但是这里我并不会去讲那三大方法，接下来我会单独写文章去研究它们的代码。前面的文章(View工作流程[一])以及说明了这三大方法会在ViewRootImpl的performTraversal调用，那么这里我们就继续追根溯源，康康ViewRootImpl到底是在什么时候被创建的，它的performTraversal又是在啥时候被调用的呢？这些时间点又处于Activity生命周期的哪个时刻呢？ 首先说明，和前面刨根问底不同，接下来我们要做的是追根溯源，所以这里我们是向上层层递归，去寻找performTraversal的最初调用，这个其实很容易，debug观察内存栈帧就明白了。为了方便起见，我还是自顶向下的讲解。 handleResumeActivity1234567891011//ActivityThread#handleResumeActivitypublic void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); // //...删掉了大量没有用的代码 // //...并且，先不要管后面的代码！！！ // //强调：实际上ViewRootImpl就是在这后面被创建的，但是我们先不忙看} 如果有留意我注释的朋友一定会说：“你这不坑我吗？前面没有用的你让我看，后面有用的你告诉我现在不看？” 先不要激动，没看到我上面写了个大大的Activity#Resume吗？如果你不耐烦的话，可以点击这里跳转到和View工作流程直接相关的内容。这里，我主要还是想顺带的复习一下Activity的onResume的具体调用逻辑(因为都是在一起的，顺带一起复习了，这样也能加深印象，对View的工作流程的开始位置有一个更加深入的了解，嘿嘿嘿)。 performResumeActivity123456789//ActivityThread#performResumeActivitypublic ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest, String reason) { final ActivityClientRecord r = mActivities.get(token); //...删除了大量没啥关联的代码 r.activity.performResume(r.startsNotResumed, reason); // return r;} performResume1234567891011121314//Activity#performResumefinal void performResume(boolean followedByPause, String reason) { //这个方法我没有删，主要是觉得有必要留意一些 //没错它就是第一个被调用的。。。 //而在performRestart里面，又依次调用了 //(1)、mInstrumentation.callActivityOnRestart() --&gt; onRestart //(2)、performStart() --&gt; onStart // performRestart(true /* start */, reason); // mInstrumentation.callActivityOnResume(this); // //...删掉了大量的无关的代码} callActivityOnResume123456//Instrmentation#callActivityOnResume()public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); //... 删掉大量无关代码} 好了，到目前位置，Activity的onResume如何被调用的我们也了解了。那么接下来，我们正式的康康handleResumeActivity中被抹去的代码吧。 View的工作流程(真)：源码分析：handleResumeActivity1234567891011121314151617181920212223242526272829303132333435363738394041//ActivityThread#handleResumeActivitypublic void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); // //获取DecorView并设置相关属性 View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // //获取WindowManager ViewManager wm = a.getWindowManager(); // //准备将decorView添加到windowManger中 //所以这里要创建一个WindowManager.LayoutParams //并设置相关的属性 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; // //...删掉了大量无关的代码 // // //将decorView添加到WindowManager中 if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; wm.addView(decor, l); } } // //...删掉了大量无关的代码 // } 在上述的代码块中出现了WindowManager，并且将我们的decorView添加到了WindowManager里，那你肯定想问: “妈的，那我的phoneWindow就这样不管了吗？“ 我只能这么回答，是的，因为后面真的就没有它什么事情了。View层级结构的PhoneWindow是一个很抽象的概念它始终给我们一种可有可无的感觉。 如果你要问PhoneWindow有什么作用，我可以这么回答：给整个ViewTree(注意这里不指某个节点，研究对象是整个ViewTree)提供了一个对外统一的API(再次注意，这里是面向用户对ViewTree的操作，) ，换句话说就是PhoneWindow是对整个View的层级结构的一层封装(隐藏了内部实现)，它本身不可见，也不是View层级结构中的一员。 我再举一个更详细的例子，比如JAVA中的LinkedList。我们知道LinkedList内部是由链表实现的，但是我们把它当集合框架的时候只会去研究某一个具体的节点或者整个链表整体的属性，对于大多数人，它们不会关心整个链表的逻辑结构(对应这里的ViewTree)，也不会去关系链表的头节点(对应这里的DecorView)，它们只会使用LinkedList这个类的实例(对应这里的phoneWindow)，或者研究某一个节点的属性或值(LinkedList的第 i 个元素)。 插入中断：谈一谈WindowManager 因为个人觉得在描述了PhoneWindow的作用后再去看WindowManager的职责就很清晰了，所以决定在这里强行插入关于WindowManger的解释。 前面提到，我们可以把PhoneWindow类别成一个LinkedList。然后我们再回到Android里，显然每一个Acitivity都会有这么一个PhoneWindow与之对应。但是我们的应用有可能会由很多个Activity哇，也就是说会有很多个PhoneWindow哇，所以是不是又需要一个组件来存储和管理这一系列的PhoneWindow呢，而提供这个功能的组件就是我们的WindowManager，（这也是为什么对于一个Application，WindowManager是一个全局的单例，因为只会用的到一个呀😂）。 另外再解释一下为什么这里WindowManger添加的是DecorView，还是基于上面链表的例子，对于一个存放所有链表的数据结构，它里面存放所有链表封装的抽象(LinkedList)或者第一个元素(DecorView)本质是一样的。但是上面我也说了，WindowManger不仅仅只是存储，它也有管理的功能，而它对ViewTree的管理肯定是依附于其节点的，通过查看PhoneWindow的API我们知道其实PhoneWindow的功能是很受限制的，所以要实现更多的功能，肯定还是直接管理节点更加方便，而WindowManger对ViewTree的管理，就是通过ViewRootImpl来实现的，或者说WindowManager把ViewTree的管理托付给了ViewRootImpl来替它完成。 我们再审视一下ViewRootImpl和PhoneWindow的功能： 本质都是对ViewTree进行管理的类 ViewRootImpl是面向WindowManager的 PhoneWindow是面向用户的 ViewRootImpl倾向于对ViewTree的工作流程的管理 PhoneWindow倾向于对ViewTree的信息的管理 又扯远了 addView (1)123456//WindwowManager#addView@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);} 到这里，我们可以看到，WindowManager的addView，内部调用了WindowManagerGlobal的addView方法。 addView (2)123456789101112131415161718192021222324252627282930313233//WindwowManagerGlobal#addViewpublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; //...删掉了大量无关代码 ViewRootImpl root; View panelParentView = null; //...删掉了大量无关代码 synchronized (mLock) { // //...删掉了大量无关代码 //初始化ViewRootImpl的对象 root = new ViewRootImpl(view.getContext(), display); //将DecorView的LayoutParams设置为WindowManager关联的LayoutParams view.setLayoutParams(wparams); //将DecorView添加到WindowManager的mView中 mViews.add(view); //将和此DecorView关联的ViewRootImpl添加到mRoots中 mRoots.add(root); //将和此DecorView关联的LayoutParams添加到mParams中 mParams.add(wparams); //将DecorView与ViewRootImpl进行关联 root.setView(view, wparams, panelParentView); // //...删掉了大量无关的代码 }} 这里的内容也是十分清晰，其实mViews , mRoots , mParams 都是数组，所以我们暂时不管。需要留意的是ViewRootImpl是在这里被初始化的，而ViewRootImpl的构造方法到底干了什么事情我们先不管，但是可以了解一点，和此Activity关联的attachInfo是在ViewRootImpl的构造方法里面被创建的。 然后我们着重来看看ViewRootImpl的setView方法。 setView123456789101112131415161718192021//ViewRootImpl#setView/*** We have one child &lt;--- 我觉得这个注释很有意思，就保留了*/public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { synchronized (this) { if (mView == null) { mView = view; // //...省略了大量无关(其实很重要的)代码 //主要是对View的AttachInfo进行相关属性的初始化 // //注意：！！！ //这个方法就是整篇文章的重点了 requestLayout(); //...后面的代码就先不管了 } }} 终于看到了一个我们非常熟悉的方法了，似乎也开始有头绪了，那么我们就再来康康ViewRootImpl的reuestLayout()到底做了什么吧。 requestLayout123456789//ViewRootImpl#requestLayout@Overridepublic void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; scheduleTraversals(); }} 线索越来越清晰了！！！，我们继续康康 scheduleTraversals 方法。 scheduleTraversals12345678910//ViewRootImpl#scheduleTraversalsvoid scheduleTraversals() { if (!mTraversalScheduled) { mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); // //...省略没有必要的代码 }} 仿佛失去方向了，但是注意看mChoreographer，它调用了一个postCallBack方法，而这个方法里面的参数有一个名字带有runnable关键字的变量，那么它是什么呢？ mTraversalRunnable12345678//ViewRootImpl#mTraversalRunnablefinal TraversalRunnable mTraversalRunnable = new TraversalRunnable();final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); }} 原来这家伙是就是一个封装了doTraversal方法的runnable哇 , 是不是线索又变得清晰了起来~ doTraversal123456789101112void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); //小老弟，看这里。是不是横竖都写着call me here. 😁 performTraversals(); //...省略一些代码 } }} ok，总算是找到了。 这样一来，我们的整个逻辑就被打通了，也就是说从这里开始，就进入了View真正的工作流程。 (累死了，这里我就先不忙画流程图了，真的是没时间哇，挖个坑，以后填。) 补充：Choreographer.postCallback1234//Choreographer#postCallBackpublic void postCallback(int callbackType, Runnable action, Object token) { postCallbackDelayed(callbackType, action, token, 0);} 我们可以看到postCallback内部调用了postCallbackDelayed() , 是不是感觉似曾相识？没错我就是说的Handler！我们继续来康康postCallbackDelayed的实现。 12345//Choreographer#postCallbackDelayedpublic void postCallbackDelayed(int callbackType,Runnable action, Object token, long delayMillis) { //...删掉部分没啥用的代码 postCallbackDelayedInternal(callbackType, action, token, delayMillis);} postCallbackDelayed内部又调用了postCallbackDelayedInternal。emmm 没啥，这种写法谁没见过，咋们继续往下看，再来研究研究postCallbackDelayedInternal。 12345678910111213141516//Choreographer#postCallbackDelayedInternalprivate void postCallbackDelayedInternal(int callbackType,Object action, Object token, long delayMillis) { //...删掉一些没啥用的判断 synchronized (mLock) { final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); //...删掉一些没啥用的判断 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); }} 是不是觉得柳暗花明了，如果你还没有明白的话，请注意上面代码的下部分，那可是handler呀！！ 好了，我也不多BB了，这段代码其实很简单，虽然Choreographer这个类做了很好的封装，但是其实本质上还是通过Handler实现的，只不过这里并没有直接把runnable封装到msg中，而是单独搞了一个mCallbackQueue，将runnable缓存在里面，然后让handler获取到MSG_DO_SCHEDULE_CALLBACK这个消息的时候，就去队列里面取出来运行… 至于为什么要这么做，我们这里就不多做研究了(坑是填不完的 _ (:з)∠) _ )… ViewParent#requestLayout我觉得很有必要把requestLayout拿出来讲一讲，因为看书学习的时候，我们会被灌输requestLayout将会导致整个ViewTree重新绘制的观点，而由于我们并不是很了解其实现，所以往往会对其功能产生固化的观点，甚至会情不自禁将其和View的三大工作流程联系起来。虽然事实是这样没错，但是在某一些场景下，这种惯性思维将会使我们误入歧途。 比如：在setContentView中，我们其实是可以发现内部实现是由多次调用requestLayout这个方法的，如果你对这个方法了解不够具体，仅仅知道它会导致ViewTree的重新绘制，那么你可能就会像我一样拼命的去寻找它是在哪里让View重绘的，或者去思考它到底在哪里调用ViewRootImpl的方法。诚然，这种思路是一点问题的都没有的，但是我们犯了一个原则性的错误，就是在Activity的onCreate方法里面ViewRootImpl其实是还并未被初始化的(惊不惊喜，意不意外！)。所以在这里调用的requestLayout方法根本就不会导致整个ViewTree的重绘！！！ 所以：requestLayout导致ViewTree重绘一定是建立在DecorView被添加到WindowManagerGlobal之后这个前提条件的。 最后，我们再来分析一些下requestLayout的实现： 1234567891011121314151617//ViewParent#requestLayoutpublic void requestLayout() { // //...删掉这里用不到的代码块 //这里的逻辑很简单，向上递归调用parent的requestLayout //但是我们要注意，这里的mParent并不是View //而是一个ViewParent的接口，所有的View和ViewRootImpl都实现了它 //这也是为什么DecorView能够调用ViewRootImpl的requestLayout的原因 // //在Activity的onCreate方法里，由于ViewRootImpl为空 //所以这个方法的递归掉用都会在DecorView处终止 //所以，(在这种情况下)并不会导致ViewTree的重绘 if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) { mParent.requestLayout(); }}","link":"/2019/09/21/View-process-0/"},{"title":"这是一篇非常详细的View事件分发机制的源码分析文章","text":"我不管你看不看得懂，反正只要我看得懂就行了 —— john pig 为了准备接下来的面试，这几天又在看《开发艺术探索》，老觉得View的事件流程看的不是很明白，索性干脆直接上源码刨根问底，肝了两天，终于是对View的事件流程有一个详细的了解。 本来打算像其他的大佬一样把源码拆开，结合图文描述关键方法的。但是发现这样做很难弄清整个流程的具体逻辑，脑子里可能就一个大致的流程图，也就逮住几个关键方法侃侃而谈。这样做或许可以快速了解，但是由于没有深入，始终不能留下深刻的印象。并且对于我自己来说，本来就对着整个流程了解不够清晰，一口气看完来写想必会忘记不少细节；而一边看一边写又容易分心，并且很容易纠结某一个细枝末节的东西而失去整体的框架。 好了，废话不多说。请慢慢 read the fucking code 吧 ViewGroup的dispatchTouchEvent()ViewGroup.java#dispatchTouchEvent() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363public boolean dispatchTouchEvent(MotionEvent ev) { //省略掉开头的一些看不懂的代码... //dispathcTouchEvent的返回值 //用于表示当前的View(ViewGroup是否消耗了此次点击事件) boolean handled = false; //一个安全策略，主要用于过滤屏保的时候的点击事件的分发 //如果被拦截了，那么dispatchTouchEvent直接返回false if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // ACTION_DOWN的时候，会将之前的状态清理 if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); // FLAG_DISALLOW_INTERCEPT会被重置为空 // mFirstTouchTarget在这个方法中被重置为空 resetTouchState(); } // 用于判断此ViewGroup是否拦截这个事件 // 两种类情况 // (1)、MotionEvent.ACTION_DOWN,即这是一次点击的事件(按下去,还未抬手) // (2)、mFirstTouchTarget != null：首先说明，这种情况一定不是ActionDown(不考虑多点) // 有可能是ACTION_MOVE 或者 ACTIION_UP // 同时也表示了此ViewGroup在最近的一次ACTION_DOWN事件 // 所导致的dispatchTouchEvent返回的结果是true。 // (因为如果是False的话,那么DecorView的mFirstTouchTarget是空的,后续的点击事件就不会通过 // DecorView的mFirstTouchTarget传递下来，那么这个View就一定不会收到除了ACTION_DOWN外 // 的所有的事件。 // 同时因为mFirstTouchTarget不为空，即说明了此View的dispatchTouchEvent返回true是因为 // 此parent有child消耗了这个ACTION_DOWN // // // 同时这里也反应了另外一个策略， // (在一个事件序列中)parent的dispatchTouchEvent一旦返回了true // 那么在后续的事件序列中: // (1)、dispatchTouchEvent一定不会被再次调用 // (2)、后续的所有TouchEvent一定会被这个parent拦截， // (3)、后续的所有TouchEvent均会触发这个parent的消耗 // (4)、这个parent的mFirstTouchTarget链表会被移除 // (5)、这个parent的所有子View一定不会接受到后面传来的事件 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { intercepted = true; } //表示此View是否被Cancel掉了 //cancel的消息来自于其parent //当在处于非ACTION_DOWN的事件序列中的某一个事件，且被其parent拦截了 //那么其parent仍然会调用此View的dispatchTouchEvent,但是传递过来的 //event是ACTION_CANCEL, 通知此View清空自己的mFirstTouchTarget final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; //一个引用，用来指向在ACTION_DOWN事件来的时候 //新加入到mFirstTouchTarget链表中的节点 //同时会用于一些在多点触控中的判断 TouchTarget newTouchTarget = null; //防止消耗了ACCTION_DOWN的child在添加到了 //mFirstTouchTarget之后再次被调用 //dispatchTouchEvent这个方法的一个标志 boolean alreadyDispatchedToNewTouchTarget = false; //注意：这里的代码块的执行和actionDown没有说明关系！！！ //actionMove 和 actionUp 均会进入这个代码块 //内部有一个单独的关于ActionDown的判断 if (!canceled &amp;&amp; !intercepted) { //省略部分(或许)无用(主要是看不懂)的代码 //用于找出能够消耗点击事件的子View //并通过调用子View的DispatchTouchEvent方法 //来判断子View是否会消耗会这个点击事件 //注意：遍历会一直持续到有子View返回了它将消耗此事件结束。 //也就是说，对于哪些Z轴在上但是并不打算消耗点击事件的子View //它们的dispatchTouchEvent均会被调用 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; final int childrenCount = mChildrenCount; //这里的newTouchTarget一定为null //单点的情况下mFirstTouchTarget一定为空 //因为前面的ActionDown把mFirstTouchTarget重置了 if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); //将所以的child按照Z轴的顺序，创建一个List //z值越大的在越上面 final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); //这里的cutomeOrder并不是说子View的顺序就是按照人为自定义的 // //这里有一个先前条件，就是preorderList == null //在内部代码里面我们可以看到，如果所有的child的Z均是0的话 //那么preorderList就是null，这种情况下子View会根据 //draw的顺序去拿 //这里我们推测，当用户设置了setChildrenDrawingOrderEnabled(true) //的时候，所有的子View的Z轴均是0 final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); //所有的子View构成的数组 final View[] children = mChildren; //遍历整个childList //其实不是childList,而是将child通过z轴的值进行排序的一个List //就是上面提到的preoderList // //然后从上至下寻找能够接受整个点击事件的child //再调用child的dispatchTouchEvent //判断child是否消耗这个点击事件 for (int i = childrenCount - 1; i &gt;= 0; i--) { //因为有上面的customer标志位，所以实际上遍历的子View的顺序 //并不一定是按照Z轴，也就是说在这个方法里才会真正拿到 //子View的位置，即确定子View的遍历顺序 //(1)、preorderList重前至后的顺序 //(2)、View的绘制顺序 //(3)、mChildren的逆序，及child被add的顺序 final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); //获取这个child final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); //这个方法会判断子View是否能接收到这个点击事件 //这里还没有调用子View的dispatchTouchEvent //如果子view不能够接受的话，就说明这个点击的点在子View的范围外 //直接continue // //同理，只有下面的代码块只有能够接受到点击事件的child才能够被执行 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } //注意：能接触到此代码块的child一定能够接受点击事件 //遍历整个mFirstTouchTarget,寻找child是否在mFirstTouchTarget //中出现过。 // //这里在单点的情况下一定是没有的,所以这个方法的针对的是多点的情景。 //可能是防止多点的时候多个ACTION_DOWN作用到了同一个View上 //导致被多次调用了dispatchTouchEvent的情况 //到目前 mFirstTouchTarget 还是null newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { newTouchTarget.pointerIdBits |= idBitsToAssign; break; } //调用dispatchTransformedTouchEvent // // 这里注意一下，上面传下来的child一定是非空且能够接受点击事件的 // //因为进入方法块的条件是mChildren.length &gt; 0, //且不能接受点击的被continue了 // //这里的主要作用是调用Child的dispatchToucEvent方法 // // 调用自己onTouchEvent(super.dispatchToucEvent())方法是在下面 // //这个判断条件进入了之 //也就是说dispatchTransformedTouchEvent返回了true就直接break了 //可能后面也有子View能够接受点击事件,但是均不会被调用 //dispatchTouchEvent方法了 // //如果返回了false,只有一种条件，有child能够接受这个点击事件，但是child不 //打算消耗它(比如说child实际也是一个ViewGroup) //所以这种情况下，继续遍历寻找其他能够接受点击事件的child，看他们 //是否打算消耗这个点击事件 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { mLastTouchDownTime = ev.getDownTime(); //进入了这个方法块其实就已经表示了child能够接受这个点击事件了 //这里需要遍历一波children，来标志最后一个被点击的child //注意，这里的Index是指的在chidren数组中的index if (preorderedList != null) { for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } //记录一下最后一次TouchDown的位置 //猜测和多点触控有关 mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //这个方法会将child添加到mFirstTouchTarget链表中 //这会使得newTouchTarget和mFirstTouchTarget都不为空 // //注意这里的break： //也就是说，只要有一个child消耗了点击事件，这个循环就已经退出了 //即：对于任何(单)点击事件来说，mFirtTouchTarget中只可能存在 //一个元素，就是消耗actionDown的那一个child newTouchTarget = addTouchTarget(child, idBitsToAssign); //这个标志位用于后面防止再调用一次dispatchTransformedTouchEvent alreadyDispatchedToNewTouchTarget = true; break; } } //preorderList已经没有用了,释放内存 if (preorderedList != null) preorderedList.clear(); } //考虑到这个代码块是处于ACTION_DOWN的前置条件的 //这里实在想不到newTouchTarget == null但是 mFirstTouchTarget 不是 null //的场景，猜测可能和多点触控有关，这里我们就先不管 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } //如果有子View消耗了点击事件的话，mFirstTouchTarget会指向消耗事件的child //此时child的dispatchTouchEvent方法已经被调用了 // //ViewGroup自身的super.dispatchTouchEvent方法是在这里被调用的 //即：ViewGroup自身的onTouchEvent是在这里被调用的 // //对于ViewGroup，如果其子View消耗了这个点击事件，那么它将不会被调用onTouchEvent //但是它仍然会对其上级ViewGroup表示它已经消耗了这个点击事件(尽管是它的child消耗的) if (mFirstTouchTarget == null) { // //mFirstTouchTarget 是空就说明这个ViewGroup的所有child均没有消耗这个点击事件 //强调：不是说child接受不到，只是说child没有消耗. //即: 能接受点击事件的child的dispatchTouchEvent方法,返回的是false // //注意，这里所说的消耗是dispatchTouchEvent(onTouchEvent)向上级返回的结果 //而默认情况下(对于ViewGroup来说)，这个方法的返回值是false //这里要排除一个情况，就是clickable的情况 //补充：如果view是clickable的话，就要单独考虑 // //以下为调用自己的super.dispatchTouchEvent --&gt; onTouchEvent handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // //遍历整个mFirstTouchTarget链表 //一般来说这里的链表应该只有一个元素，就是之前能够接受点击事件的元素 //在这个链表的遍历中，只要有一个child的onTouchEvent返回了true,那么此方法就会返回true // TouchTarget predecessor = null; // &lt;--指向链表的前驱 TouchTarget target = mFirstTouchTarget; // //注意这里是一个while，会被调用多次的 //下面会提到，如果parent打算拦截child的话，会将TouchTarget移除 //也就是说，parent打算拦截，整个接受传递事件的序列均会被移除 //(先不管resetCancelNextUpFlag 这个方法) while (target != null) { final TouchTarget next = target.next; // //可以看到，前面创建的newTarget是用来暂存那个消耗了点击事件的child的 //这个判断只会针对actionDown,因为在任何的非down的action,newtarget都是null if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { // //ActionDown的后续事件序列将会进入这个代码块 //因为newTouchTarget为空，并且mFirstTouchTarget非空 // //前面提到了onInterceptTouchEvent是在整个事件序列中均进行判断的 //也就是说在后续的事件序列中onInterceptTouchEvent仍然会被多次调用 //只要有一次onInterceptTouchEvent方法返回了true，那么后面的整个事件序列 //均会被整个ViewGroup所消耗了,并且在这一次事件中会把所有的能够接受事件的child //移除，也就是说，即使这个事件序列后面parent不拦截了(比如说滑动) //这些事件仍然不会被分发给这些child(因为mFirstTouchEvent已经被移除了) //注意，这里会调用child的dispatchTouchEvent //但是会给child传递一个cancel事件 // //!!!!!!注意一下这里的resetCancelNextUpFlag方法 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { //前面提到touchTarget是一个链表的结构 //如果一个点击事件被ViewGroup拦截了的话 //ViewGroup会把链表中的这个touchTarget节点移除掉 //如果是第一个节点，就直接把mFirstTouchTarget移除 if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } //被发送cancel的TouchTraget，直接被recycle了 //即被发送了cancel事件的子view会从TouchTarget链表中移除 target.recycle(); target = next; continue; } } predecessor = target; target = next; } } //三种情景 //(1)、接受到了Parent传来的cancelEvent //(2)、此次事件是ACTION_UP //(3)、此次事件是ACTION_HOVER_MOVE // //此ViewGroup会清空其mFirstTouchTarget //并且会把FLAG_DISALLOW_INTERCEPT也重置 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); // //看不懂。。。。。 } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } // //看不懂。。。 //大概就是通知该事件被忽略掉了 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled;} View的dispatchTouchEvent()相比ViewGroup，View的onTouchEvent方法就相对来说简单很多了。我们只需要注意一下这个方法对于onTouchEvent的判断逻辑就行了。 View.java#dispatchTouchEvent() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public boolean dispatchTouchEvent(MotionEvent event) { //省掉一些看不懂的代码 boolean result = false; //mInputEventConsistencyVerifier用于检测这个输入的 //事件序列是否完整和Log通知用户的 //比如说用户点击事件的ActionDown被此View消耗 //但是因为开发者在自定义ViewGroup中错误的拦截逻辑 //导致了ActionUP事件未传递到这里来 //那么这个类将会检测到这种问题，并且在Log中通知 if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } //如果是ACTION_DOWN的话，会尝试停止嵌套滚动 //由于本人对嵌套滚动的原理并不太熟悉 //但是点进去可以看到，里面其实就是把嵌套滚动的相关标志清除了 //这里可以联想ViewGroup的dispatchTouchEvent方法 //在ACTION_DOWN的时候，也会重置整个View的事件序列 final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { stopNestedScroll(); } //同ViewGroup一样，onFilterTouchEventForSecurity 是一个安全策略 //主要是用来拦截屏保下用户的误触 // //先宏观的看一下这个代码块 //(1)、几乎所有的判断逻辑都是返回的true //(2)、onTouchListener的onTouch方法在这里被调用 //(3)、onTouchEvent 方法在这里被调用 // //也就是说ViewGroup只有调用了super.onInterceptTouchEvent //才会调用onTouchEvent方法 // //这里有一个要注意的地方，就是第一、二个判断条件 //和第三个判断条件，也就是调用onTouchEvent的方法是互斥的 //也就是说，只要View设置onTouchListener并且返回了true //的话，View的onTouchEvent方法是不会被调用的 if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } //如果不进入安全策略才可能会进入这个代码块 //这个代码块其实没啥用，就是Log通知一下 //这个Event并没有被这个View消耗 //前面提到已经谈了InputEventConsistencyVerifier的功能 //这里就不在赘述 if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } //同ViewGroup一样，在ACTION_UP的时候 //View自身也会尝试清理View事件序列的状态 if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result;} OnTouchEvent()然后我们再来看一看View的onTouchEvent方法。我发现很多人的博客对于onTouchEvent的描述都是比较少的，确实也应该这样，因为onTouchEvent方法不像ViewGroup的dispatchTouchEvent那么复杂，并且相对来说对整个View的事件机制也没有这么重要(我的意思是逻辑比较固化 ， 不算是一个难点，一般来说了解一下流程就可以了)。 View.java#onTouchEvent() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322public boolean onTouchEvent(MotionEvent event) { //获取点击的x坐标和y坐标 final float x = event.getX(); final float y = event.getY(); //前面提到了viewFlag是用来存放View状态的一个标志位 final int viewFlags = mViewFlags; //获取点击事件的种类 final int action = event.getAction(); //判断这个View是否是可以点击的 //可以看到，实际上View是否可以点击是通过viewFlags的某一个标志位来获取到的 // //注意：这里无论是CLICKABLE 还是 LONG_CLICKABLE 均被视为可点击的 //不过Android实际上对于长按的检测和onLongClick的调用 //是在ACTION_DOWN的判断逻辑中而onClick是在ACTION_UP // //补充： //(1)、如果一个View同时设置了onLongClickListener和clickListener时 //如果onLongClick返回了false,那么mHasPerformedLongPress是为false的 //也就是说，在ACTION_UP的场景View还是会调用onClick //(2)、如果onLongClick返回了true,也就是说长按消耗了这个点击事件 //那么mHasPerformedLongPress就是true,这个时候onClick是不会执行的 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //如果这个View是不可触摸的话 //按道理就应该直接返回false了,因为disable的View不应该能够消耗这个事件 // //但是看下面的注释我们知道 //对于一个被disabled的View如果设置了clickable //逻辑判断它会消耗这个事件(虽然什么事情都没有做,只是返回true了而已) // if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; //clickable是False返回false //clickable是True返回true return clickable; } //这个Delegate是用来扩大一个View的点击范围的 //所以在这里我(们)就不研究它了 //只需要注意一下，只要有Delegate的话，此View //的onTouchEvent方法就会返回True if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //如果这个View是可以点击的或这个设置了TOOLTIP的话，就进入下面的代码块 //TOOLTIP是指这个View可以被长按弹出一个小小的提示 // //只要View是clickable的，那么它的onToucEvent就一定会返回true // if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: //privateFlag这里是非公开API的内容,这里我们不管 mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; //点进去我们可以看到，ACTION_UP的的时候 //View会把ToolTip隐藏,并且将TOOLTIP的callback移除 if ((viewFlags &amp; TOOLTIP) == TOOLTIP) { handleTooltipUp(); } //在只有设置了TOOLTIP的情况下才会进入这个代码块 //也就是说, 设置了TOOLTIP并不代表View可以点击 //同样,这里做了一堆把CallBack移除的操作 // //注意下面，直接就break了, 即后续的判断都不考虑 //也就是说，对于ToolTip，在ACTION_UP的时候 //所做的操作是清理状态和标志的 if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } //一个表示prepressed的标志位 //prepressed是一个不可描述的奇怪的标志位 //表示的是在ACRION_DOWN和pressed之间的状态 //大概就是如果按压的时间在115ms之内 //那么这个较短的按压不会被算作press //而是被称为prepress的状态 boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; // //注意这里的代码段是基于ACTION_UP的 //下面的代码段的场景描述的是在pressed状态或者prepressed //状态下用户手指抬起来了,即ACTION_UP的时候的场景 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // //注意： //对于View，只有满足clickable才能够获取到焦点， //但是这并不代表满足clickable就一定能获取到焦点 //即：clickable是获取焦点的必要条件 // //所以前面直接break也是有原因的(因为根本就进不来 //同理可知：能够进入下面这一部分的这一段代码 //View一定是能够被点击的 // //由于在ACTION_UP的时候， //View会响应一些用户交互，比如editText弹出键盘 //所以View会尝试获取focus // //注意： // (1)、isFocusable的意思是这个View可以获取焦点，而不是已经获取了 // (2)、对于触摸屏的情况，我们只需要考虑isFocusableInTouchMode， // 前者是针对的是键盘或者遥控器的场景 // (3)、requestFocus()会返回这个View是否成功的获取了焦点 boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } // //前面提到prepress是115ms之内的一个预判定的状态 //由于用户在很短的时间内手指离开了屏幕 //115ms的press判定还没有开始 //即：drawableHotspotChanged这个方法还未调用 //drawableHotspotChanged 会记录手指的位置 //用于后面涟漪动画播放的中心位置的选择 // //但是这里drawableHotspotChanged还未调用 //而这次ACTION_UP很有可能是一次点击事件 //而点击需要播放动画，所以这里强制执行一次setPressed //用于记录pressed的位置 if (prepressed) { setPressed(true, x, y); } //mHasPerformedLongPress是一个用于记录是否出现了longPress的标志位 //View的在ACTION_DOWN持续了一段时间后，就会把这个标志位设置为true //这种情况，从第一个ACTION_DOWN至ACTION_UP是不会被判断为tap事件的 // if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // //移除掉LongPress的CallBack //因为ACTION_UP就已经表示这个事件序列已经结束了 removeLongPressCallback(); //这里做一下解释： //view的点击事件和获取焦点(这个行为)是互斥的 //也就是说一个View能够获取焦点的话，那么它将优先获取焦点 //而不会触发点击事件，在上面的判断逻辑中，如果view能够 //获取焦点的话，就会调用requestFocus方法，并且把结果返回给 //focusTaken，获取成功了的话，下面的代码块就不会被执行。 // //不过这里需要留意，如果一个View已经获取了焦点的话， //focusTaken的返回结果是false，这里参考上面的判断逻辑 // //如果还是不能理解的话，可以结合一下editText设置了onClickListener //之后的行为，会发现点击第一次的时候是不会出发onClick的 if (!focusTaken) { // //mPerformClick是一个Runnable的的实现 //内部封装了mListenerInfo的onClick的方法 if (mPerformClick == null) { mPerformClick = new PerformClick(); } //通过handler将onClick方法丢到消息队列中执行 //如果post(就是将mPerformClick往小修队列丢)失败的话 //那么就立即执行performClickInternal方法 //OnClickListener的onClick方法是在 //performClickInternalf方法里面被调用的 if (!post(mPerformClick)) { performClickInternal(); } } } //在事件是ACTION_UP但是判定标志是prepress的状态的时候 //会将unSetPressState这个接口的实现丢到消息队列 //内部封装了setPress(false)方法，并且会把这个setPress(false) //通过dispatchSetPressed方法传递下去 if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } // //注意，这里的实际作用就是重置press的状态 //前面我们可以看到，View的press状态会在 //ACTION_DOWN的时候重新设置，所以在ACTION_UP //的时候需要将前面事件序列的press清理掉 // //补充一下这里为什么要对prepress进行一个判断 //考虑到用户有可能在115ms之内出现ACTION_UP //而通过下面的代码我们可以看到对于prepress的状态 //会115ms之后延迟执行setPress(true) //所以显然这里设置press为false的时候也需要115ms执行 if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; //这里留意一下press标志位和prepress标志位 // //(1)、当一个View是不在可滚动的容器中的话 //那么从用户的ACTION_DOWN一直到用户ACTION_UP //的整个事件序列中,pressed一直是true // //(2)、当一个View在一个滚动的容器中的话 //那么会在前115ms设置此View为prepress状态 //115ms之后才会被设置为pressed case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } //在ACTION_DOWN的时候把已经长按的标识重置了 //注意：这个表示是提供给onClick参考的 mHasPerformedLongPress = false; //如果是不是Clickable调用一次checkForLongClick //在内部检测是否是TOOLTIP的情况 //因为TOOLTIP本质上也是一种长按 //但是为了和View本身的长按不冲突 //所以被设置为了一种单独的情况进行考虑 if (!clickable) { checkForLongClick(0, x, y); break; } //这个一般情况下都是返回false, 所以我们不管它 //因为这个好像是用来处理鼠标的右键点击的 if (performButtonActionOnTouchDown(event)) { break; } //遍历View层级，判断是否是在一个能够滚动的容器中 boolean isInScrollingContainer = isInScrollingContainer(); //如果上面的标志返回是true的话， //下面的代码块会让View延迟处理长按的检测 //也就是说会在115ms之后才检测用户是否处于长按状态 //并且把现在的事件状态设置成prepressed if (isInScrollingContainer) { // //立即设置状态为prepress mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); // //可以看到，这里往消息对立里面丢了一个CheckForTap的Runnable //作用是在115ms后调用setPressed(true)再检测是否是长按 postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { //否则，直接设置Pressed, 并且检测长按 setPressed(true, x, y); checkForLongClick(0, x, y); } break; //ACTION_CANCEL比较好理解，就是parent拦截了 //传递下来的ACTION,同时向此View传递一个ACTION_CANCLE // //可以看到ACTION_CANCEL的判断逻辑里面 //主要是做一些资源的清理和标志的移除 //这里就不做过多的赘述了。 case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: // // 再一次看到了drawableHotspotChanged这个方法 // 这个很容易理解，因为View的点击动画的的播放位置 // 应该是在手指离开的位置的，而对于手指移动的场景 // ACTION_UP的位置就是最后一次ACTION_MOVE的位置 if (clickable) { drawableHotspotChanged(x, y); } //用于判断我们当前手指的移动有没有移除这个View的范围之外 //如果手指移除了范围之外的话，就将部分的资源清理(状态重置) //并且重新设置press为false if (!pointInView(x, y, mTouchSlop)) { removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; } break; } return true; } //默认是返回False的 return false;}","link":"/2019/09/16/ViewEvent/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Review","slug":"Review","link":"/tags/Review/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"you","slug":"you","link":"/tags/you/"},{"name":"SourceCode","slug":"SourceCode","link":"/tags/SourceCode/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"开发艺术探索","slug":"读书笔记/开发艺术探索","link":"/categories/读书笔记/开发艺术探索/"},{"name":"EffectiveJava","slug":"读书笔记/EffectiveJava","link":"/categories/读书笔记/EffectiveJava/"},{"name":"日常","slug":"随笔/日常","link":"/categories/随笔/日常/"},{"name":"源码阅读","slug":"源码阅读","link":"/categories/源码阅读/"},{"name":"View工作流程","slug":"源码阅读/View工作流程","link":"/categories/源码阅读/View工作流程/"},{"name":"View事件分发机制","slug":"源码阅读/View事件分发机制","link":"/categories/源码阅读/View事件分发机制/"}]}