{"pages":[{"title":"about","text":"Hello Traveler 我是 johnPig 你也可以叫我pigrange。目前UESTC 信息安全大三狗一枚，典型的理工男，白日梦想家，人形自走BUG(哦不，状态)机。爱听音乐，爱追番，也喜欢阅读。 误入歧途的Android程序员，梦想是成为懂全栈的Advanced Android System Engineer。虽然很遥远，但是好在并未打算放弃，目前正朝着目标一步一个脚印的前进(emmm 先把Cpp的坑填了再说_ (:з)∠) _ )。 我并不打算将此个人博客做大做好或者做出名，搭建此博客发布文章的唯一目的在Android学习生涯中留下一些足迹。所以如果你偶然发现了这里，那必定是我们的缘分。另外，我也不打算开启评论功能，所以如果你发现文章的内容的错误或者有什么问题的话，都可以通过jiangpigcheng@gmail.com和我联系。当然我也很希望能够通过这个渠道接触到一起探索Android开发的朋友。 如果我的文章对你有用，那么我深表荣幸。","link":"/about/index.html"}],"posts":[{"title":"View的事件体系基础","text":"这里整理了一些关于View事件体系的一些基础的知识点，而有关View事件分发机制的部分，我单独攥写了一篇关于事件分发源码阅读的文章，所以这里就不再进行总结归纳。 1、View的基础知识什么是View： Android所有的控件的父类，是界面层的一种抽象 View的结构和前端的DOM相似，View也可以有一组控件组成 View的位置参数： 四个顶点： top : 上边界的y左边 left ：左边界的x坐标 right：右边界的x坐标 bottom：下边界的y坐标 注意： 四个顶点的位置是相对于父容器来说的，如果还需要获取一个View的绝对坐标的话，需要代入它所有的parent的四个顶点的坐标来进行计算。 View如果是通过设置translationX/Y来改变View的位置坐标的话，其四个顶点的位置并不会发生改变。 坐标与宽高的关系： width = right - left height = bottom - top 其它位置参数： y = top + translationY x = left + translationX 滚动位置参数： scrollX = getScrollX scrollY = getScrollY 注意：滚动位置参数并不会修改View的实际位置。此参数平移的是View的内容，而View本身并不会被修改 点击的位置参数：对于一个点击事件，使用x 、y 或 rawX 、rawY 来实现View的点击位置的获取 getX() : 返回点击事件距离(消耗此点击事件的)控件左边的距离 getY() : 返回点击事件距离(消耗此点击事件的)控件上面的距离 getRawX() : 返回点击事件距离整个屏幕左边的距离 getRawY() : 返回点击事件距离整个屏幕顶上的距离 2、View交互相关的一些类 MotionEvent ： 封装了点击事件的类 TouchSlop ：系统能够识别的滑动的最小距离，是一个常量 获取方式：ViewConfiguration.get(getContext().getScaledTouchSlop()) VelocityTracker : 用于计算滑动速度的，作用的单位是MotionEvent GestureDector：一个手势检测的工具类。可以用来在TouchEvent中实现一些较为复杂的收拾的检测。 这个类会拦截View的监听操作，所以如果使用这个类的话，监听器要单独注册。 推荐用于监听双击操作 Scroller： 一个用于View弹性滑动的对象 本质上是一个封装好了的插值器。 3、实现View滑动的方式Layout： Layout方法最终会调用onLayout来设置View的位置 故可以在View滑动的过程中，不断的调用Layout方法来更新View的位置 LayoutParamas： 在LayoutParams中通过设置LayoutParams的LeftMargin属性和TopMargin属性来更新View的位置 设置后调用setLayoutParams方法实现重绘(内部封装了requestLayout方法，并且做了相关判断) scrollTo 注意，这个方法改变的是View内容的内容而非View本身的位置 此方法是不会导致View重新绘制的,所以需要对View使用invalidate方法 使用动画 XML动画：控制View的translationX 和 translationY 属性 ObjectAnimator：相对稍微复杂一点，需要对View的动画属性设置getter和setter ValueAnimatior：使用简单，兼容性强，本质上也是一个插值器，需要手动更新View的位置坐标 各种滑动方式的对比： scrollTo/scrollBy : 操作简单，适合对View的内容进行滑动 动画：操作简单，适合对没有交互的View和实现复杂的动画效果 改变布局参数：操作稍复杂，但是适合有交互的View","link":"/2019/09/15/Android2/"},{"title":"EffectiveJava笔记[一]","text":"EffectiveJAVA的读书笔记 [一] _ (:з)∠) _ 1、考虑使用静态工厂方法代替构造方法：静态工厂方法的优点： 拥有名字，更加容易阅读 不需要每一次调用的时候都创建一个对象，可以对实例的数量进行严格的控制 可以返回其返回类型的任何子类型的对象 可以根据传入参数的不同而返回不同类型的对象，（构造方法只能返回自己的对象） 在编写包含该方法的类的时候，返回的对象的类不需要存在。 缺点： 如果只提供静态工厂方法，那么它就有可能没有public或者private的构造方法，也就是说无法被子类化。 没有一个统一的对静态构造方法的命名的规范，导致可能很难找到他们。 2、当构造方法的参数过多的时候，使用Builder模式:静态工厂方法和普通的构造方法都无法很好的解决构造方法中参数很多且可选的参数很多的问题。 使用构造方法的缺点： 过多的方法重载，导致非常的繁琐 并且在获取类的实例的时候可选(参数)的构造方法太多，以至于降低可读性 1、JavaBean模式： 通过一个无参数(这里指可选参数)的构造方法来创建对象，然后调用一系列setter方法来设置参数 缺点： 代码较为冗余 由于是实现创建好了对象在设置值，所以在多线程的情况下无法保证对象参数的一致性（也就是说先创建好了对象再去设置参数，无法保证在创建过程中对象的不可变的） 2、Builder模式： 客户端不直接创建对象，而是通过一个builder预先配置好对象的每一个可选参数，然后通过builder的build方法来生成对象，这样产生的对象就是不可改变的，Builder通常是它所构建的类的一个静态的成员。 3、使用私有构造方法或枚举来实现单例单例通常表示的是无状态的对象。比如说一个只提供函数功能的对象或者一个系统组件。 1、实现单例的方式： 创建一个静态final的自身引用，并私有构造方法 提供一个公共静态方法用于返回自身的单例。 注意，对于构造方法，应当在请求创建第二个实例的时候抛出异常，因为Java的反射机制可以调用private的构造方法。 2、单例与序列化： 如果单例的对象需要支持序列化的话，那么仅仅将这个类直接实现Serializable接口是不行的，这个问题正好是前面应该注意的点的良好反应。 当使用ObjectInuptStream对对象进行反序列化的时候，Java会通过反射去调用类的无参构造方法(尽管它是私有的)，当然如果按照我们前面的实现，那么很有可能在反序列化的时候直接抛出了异常(因为请求创建了第二个实例) 解决方案： 在单例类中提供一个readResolve方法，并在这个方法中返回我们的单例对象。 4、使用私有构造方法来执行非实例化这个条目是直接基于EffectiveJava直译而来。通俗来讲就是对于那些只用于提供静态方法或者静态属性的类(比如某些Util工具类或者config配置文件)，我们应该避免他们被创建实例或者继承，因为并没有任何意义。 采取的操作： 将类设置为final，避免被继承 将类的构造方法设置为私有，并在代码块里面抛出异常(防止别人通过反射来创建实 5、依赖注入优于硬连接资源这个又是显得异常的高大上。至少对于我来说，看见依赖注入就觉得这个是高大上且较难的东西，并且第一遍读这个条目的时候也没有搞明白这个到底是啥。 其实弄明白了什么是依赖注入，这个条目就非常的简单了。 依赖注入： 依赖：举个比较普遍的例子。我把我自己比作对象a，我的电脑比作对象b。如果我需要写这篇blog，我就需要我的电脑，也就是说a依赖于b。 依赖注入：对于a依赖的对象b，我们不应该在a的类中直接创建b的实例，而是提供b的设置api或者通过构造方法将b的引用传入。也就是说将a的依赖b注入给了b。 这样做有两个好处，一是b的生命周期并不用需要a来进行管理。二是对于多个依赖b的对象，如果b是不可变的，那么可以实现b的复用。 虽然通过接口传递依赖也是一种实现，不过不推荐这么做，因为在并发的环境中，这是非常容易出错的。除非我们的对象非得支持多种依赖，那么最好的解决方式还是将其设置为final然后再通过构造方法传入。 依赖注入的有用变体： 将资源工厂传递给构造方法。","link":"/2019/07/24/EffectiveJava笔记1/"},{"title":"EffectiveJava笔记[四]","text":"EffectiveJAVA的读书笔记[四] _ (:з)∠) _ 16、在公共类中使用访问方法而不是公共属性关键字：public类，访问方法，public属性 在JAVA里面，对于那些需要对外提供某些属性的类。比较建议的一种写法是对外提供访问方法(getter和setter)而不直接将这些属性设置为public的。曾经有人问过我这个问题，为什么要这么做，我并不知道，只觉得这是封装思想的一种体现。 如下（例子源于书上）: 123456789101112131415161718192021222324252627//不建议这样写class Point { public double x; public double y;}//建议这样写class Point { private double x; private double y; public double getX() { return x; } public void setX(double x) { this.x = x; } public double getY() { return y; } public void setY(double y) { this.y = y; }} 理解： 这其实是类和成员可访问性最小化的一个体现。外界通过唯一public的API来获取数据。类本身将其具体的实现隐藏，这样内部的实现无论怎么改只要返回给外界他们期望的值即可。相对的，如果直接将属性提供给外界的话，那么在一个成型的代码系统中，这个属性就几乎没有再修改的余地了。 例外： 如果一个类是包级私有的或者是一个私有的内部类，这样写是被允许的。理由很简单，它们对外提供的属性的作用范围太小了，并不会出现上面提到的那种问题。而且这样写的可读性更强，不是吗？(手动斜眼) 17、最小化可变性关键字：可变性 首先我们给不可变的类一个基本的定义： 不提供任何修改对象状态的方法 不能被继承 所有的属性均为final。(即便这个属性是private的，因为你无法保证在编写逻辑的时候不修改某个属性的值，而设置为final后，当你不经意修改的时候会出现错误提醒你) 所有的属性应该是private的。（其实设置为public并不会出现任何问题，但是这违背了条目16的建议） 确保对任何可变组件的互斥访问。(这是什么意思呢？？？) 理解： 在创建的一开始它的状态就被确定了，状态在它存在的整个生命周期均不会发生任何改变。 线程安全的，不需要线程同步。因为不可变的对象的所有属性都是只读的，它并不会因为多线程的同时访问而出现同步问题。 可以自由的分享，也没有必要创建很多个副本或者考虑防御性拷贝。 缺点： 为每一个不同的值都需要创建一个单独的对象，导致性能问题。 总结： 除非有很好的理由能够说明一个类应该是可变的，否则尽量将其设置为不可变的。 18、组合由于继承关键词：组合 ，继承 跨越包级的继承很危险(对类来说)的。 破坏了封装的思想：子类有可能会依赖父类的一些实现细节，但是父类改变后，可能会导致子类无法使用。 重写父类的方法不一定有效：在出现了上面的问题的时候，一个解决方案就是重写父类的方法，但是如果这个逻辑涉及到一些父类中的私有属性的话，那么将无法实现。(子类并不能访问父类的私有属性) 随着父类新版本的发布，父类可能会提供新的方法。但是这可能会对子类进行破坏(如果正好子类拥有一个相同名字参数和返回类型的方法)，从而导致编译不通过。 组合： 不继承一个现有的类，而是在新的类里面持有一个私有的现有类的对象。对于现有类的一些实现，新的类实现一个同名方法并在内部调用现有类的方法。 优点： 新类并不依赖现有类的实现细节，所以现有类的修改并不会对新类产生影响。 理解： 这是一种基于包装类的思想，即设计模式中的装饰者模式。 这种设计模式并不等同于委托 注意： 包装类中不适合使用回调，因为某一些设置回调的方法对象会将自我的引用返回出来，但是被包装的对象是并不知道它的外界存在一个包装器，所以它仍然会返回一个自身的引用。 总结： 适合使用继承的情况：只有子类真的是父类的子类型的情况下才适合使用继承。即两者中存在”B is A”的关系，才应该让B继承A。 19、要么设计继承并提供文档说明，要么就禁用继承如题，字面意思。 可继承的类： 如果一个类是可以被继承的话，那么我们应该提供详细的文档说明 详细描述重写某一个方法会带来的影响。 应当说明可重写方法的自用性 应当详细的列出任何可能调用可重写方法的情况 测试一个为继承而设计的类的唯一方法是编写子类进行测试 构造方法里面不能直接或间接地调用可重写的方法 禁用继承： 如果无法提供很好的设计或文档，那么就将此类设置为final以禁用继承 总结： 设计一个可继承的类需要提供详细的文档，并且需要很大程度上限制这个类的功能。 如果不得不继承一个没有提供详细文档的类，最好的方法是不调用任何可重写的方法（消除父类自用可重写方法的可能性）。 20、接口优于抽象类关键字： 接口，抽象类 JAVA对于抽象类只允许单一继承，而对于接口来说可以多实现。 理解： JAVA对类的继承的结构是垂直的，也就是说一个类继承了它的父类，那么它就一定满足”A is B”的描述，也就是说，它的根源是被确定了的。 但是接口只是一种实现，它对外表述的是”A can be B”，这表示A是多变的，它强调了A是具有某一些行为是符合它被作为B的要求，所以它应该是有多种实现的。 抽象类过分的强调了层级关系，这对于我们并不能准确定义某一些类的层次。比如说一个程序员也可能是一个作家，但是如果使用抽象类我们就无法给它一个精确的定义。 实现了接口的类可以很方便的实现其他接口以更新功能，但是如果是实现了抽象类，那么就会比较麻烦。 接口是定义mixin（混合类型）的理想选择，它保证了一个类除了提供自身类型以外，还能够提供某些可以选择的行为。 相关链接：EffectiveJava笔记[一]EffectiveJava笔记[二]EffectiveJava笔记[三]","link":"/2019/07/24/EffectiveJava笔记4/"},{"title":"View的工作原理","text":"前面整理总结了View的事件体系，那么接下来我们再来看看View的工作原理吧。和前面一样，这篇文章主要是对知识点进行一些总结归纳，而涉及源码的部分，我会单独写一篇文章来详细分析。 两个比较重要的类：ViewRootImpl:注意：这个类虽然名字和View有关，但是其并不继承自View，可以说在实现上和View没啥关系，整个ViewTree的根View是DecorView，而对DecorView的直接持有者又是PhoneWindow(这里我们不说parent，因为phoneWindow不是View的子类)。 这里要说明一点，虽然PhoneWindow直接持有了DecorView的引用，但是由于职能的限制(如果PhoneWondow再去管理View就太臃肿了)，PhoneWindow的实例并不直接对当前Activity的DecorView进行管理(PhoneWindow更多的是和Activity进行交互)，所以Android才引入了ViewRoot这个控制层(或者说叫handler？)，来使WindowManager间接的管理Windows下的View。 ViewRoot作为PhoneWindow和DecorView之间的桥梁，直接控制了DecorView以及整个ViewTree的测量、布局、绘制、以及事件分发的工作。另外，它还代理了WindowMnagerGlobal负责和WindowManagerSercvice进行直接通信来调整窗口位置的大小以及对来自于WMS的事件进行相应的处理。 整个View树的PerformTraversal是通过ViewRootImpl开始的，而ViewRoot的PerformTraversal内部会一次调用PerformMeasure，PerformLayout，PerformDraw三个方法，这三个方法将会对顶层的View即DecorView依次进行mesure，layout和draw，而mesure，layout，draw的内部又会调用View的onMeasure, onLayout , onDraw方法。而如果这个View是一个ViewGroup的话，其onMeasure, onLayout和Draw的dispatchDraw又会调用其子View的Measure , Layout , Draw 方法。在这个递归调用下。整个View树就完成了测量，定位，和绘制的工作。 DecorView:DecorView是View树中的顶层View，是ViewGroup的子类，是比ContentView还要顶层的视图。一般情况下，用户是不需要和DecorView进行交互。 DecorView的结构: TitleBar: 用于挂载Actionbar ContentPatent: 用于挂载ContentView ​ 注意：这里所说的挂载实际上是通过addView添加上去的，这里的ContentParent实际上是一个FrameLayout，这里命名为ContentParent只是为了说明其地位的特殊，而不是说这就是一个特殊的类。我们可以通过在DecorView中调用findViewById(android.R.id.content)获取到它。 MesureSpecMesureSpec是一个32位的Int类型，用于表示一个父View对child的约束类型和能提供的最大的空间。也就是说，这一个int值表示了两个数据。其中它的高2位，用于表示测量的类型，而低30位用于表示测量的大小。这样做有一个好处，就是省掉了为了传递一组数据创建一个对象在内存上面的开销(光是对象头就占用了8个字节了，如果是用数组的话，对象头12个字节，更大)。 组成： MesureMode UNSPECIFIED: parent不约束child，child想要多大就给多大。 EXACTILY: parent确定child有多大了，child在拿到之后就是自己的最终大小。 AT_MOST: parent确定child的最大的大小，child拿到后再根据自己的需求设置自己的大小 注：这里为了便于理解，先暂时不考虑View有背景的情况 MesureSize parent 提供给child的尺寸的数值，用于建议child应该多大 谈一谈LayoutParamas和MesureSpec：可以说在View的测量这一块，LayoutParamas和MesureSpec的组合起到了决定性的作用。 LayoutParamas 是child告诉parent的 child通过LayoutParams告诉parent自己的dimension是什么(Android把matchParent和wrapcontent也算作dimension了，只不过是特殊的标志，前者为-1，后者为-2). MesureSpec 是从parent返回给child的 parent通过LayoutParamas获取了child的意图后，结合自生的情况(自身的MesureMode，MesureSize，margin，padding等)，计算出child的大小，并将其封装为MesureSpec后返回给child。 对于UNSPECIFIED我们一般不考虑，这个只有在多次测量的时候才会出现。 对于MesureMode是WrapContent的场景简单解释一下：这个时候parent是不知道child实际上应该是多大的(因为它并不知道child有哪些内容)，所以这个时候，提供给child一个最大的值，让child自己搞，只要不超过这个范围就行了。 可能有些人会说了，既然child能够通过LayoutParams知道自己的测量模式是啥，那为啥还需要MesureMode呢？这个问题我也考虑过，也想问，猜测有两个因素，一个是有UNSPECIFIED的存在那么MesureSpce必须再带一个附加信息，另外一点就是涉及LayoutParams的职能问题。Child确实可以通过LayoutParams获取，但是一旦这么做，就模糊了LayoutParams的概念。这显然是不太清真的(雾)。 注意：对于DecorView，其MesureSpec是在自身中创建的，而不是由parent分发下来的。因为它的parent就是phoneWindow了，大小是确定的。 对MesureSpec的一些总结：引用网络上的一张View 的MesureSpec创建规则的表 这个其实很好理解： 只要记住三点(这里我们就不考虑UNSPECIFIED了)： child指明了自己的大小是多少dp/sp的时候，parent不会对child做任何限制，mesureMode一定是EXACTLY，而measureSize一定是child在LayoutPrama中的大小。也就是说View的大小是在测量前就一定确定好了的，但是这了还是要强调一下，大小虽然确定的，但是位置是未知的，还是得在layout之后才知道。 child是MATCH_PARENT的时候，只要它的parent(向上递归)存在一个ViewGroup是WRAP_CONTENT，那么它的size就会变成(伪)WRAP_CONTENT。而其他情况，那么就是父View提供的measureMode就是EXACTLY. 这里做一下解释为什么是(伪)WRAP_CONTENT，因为如果子View不对WRAP_CONTEN做特殊处理的话，那么它的实际效果和MATCH_PARENT是一样的.(这个我们后面在源码里分析) child是WRAP_CONTENT的时候就很简单了，它从parent那里得到的mesureMode一定是AT_MOST。 (真)View的工作原理前面bb太久了，差点没有抓住重点。 因为后面打算单独做一起结合源码分析View的工作原理。因此，这里只对View的工作原理做一些步骤上的描述。 Msasure过程： 完成了View大小的测量 由Measure方法和onMeasure方法组成(实际上是在Measure方法里面调用了onMeasure方法) mesure方法是一个final的方法，而提供给开发者可以重写的是view的onMeasure方法。 onMeasure提供了parent传来的mesureSpec，View的实际的宽、高实际是在onMeasure里面设置的 如果这个View是一个ViewGroup，那么还会调用mesasureChildren这个方法去测量它的所有的child。 Layout过程： 完成了View位置的确定 由layout方法和onLayout方法组成(同上，实际上是在Layout中调用了onLayout) Layout方法不是一个final方法，可以被重写。View的具体位置是在layout中设置的 onLayout是用于ViewGroup来确定child的位置的 View的MeasuredWidth/Height是onMeasure时确定的 View的Width/Height是在layout时确定的，不过两者默认值是相同的，除非重写layout方法 Draw过程：draw的过程就比较简单了，这里我们只需要记住draw里面调用了onDraw即可，对于draw的源码内容的分析，后面我会在源码解读的文章里面进行阐述，下面我们简单看看Draw的具体流程。 绘制背景: drawBackground(canvas) 绘制自己: onDraw(canvas) 绘制自己的子View: dispatchDraw(canvas) 绘制装饰: onDrawForeground(canvas) 绘制焦点: drawDefaultFocusHighlight(canvas) View宽高的获取：这里我觉得有必要单独拿出来讲一讲，因为在我的开发经历中确实在这方面踩过不少的坑。 由于View的工作流程和Activity的生命周期里面是不相同的，所以我们无法在确保Activity生命周期里面的某一函数里面拿到View的宽高。如果你在View的measure或者layout之前尝试获取其宽高的话，那么始终得到的都是0。 下面是一些方法： Activity#onWindowFocusChanged方法 View#WindowonFocusChanged方法 当DecorView绘制完成Activity正准备显示出来的时候，会回调Activity#onWindowFocusChanged这个方法 view.post(runnable) 用的比较多，也是比较推荐的方法(因为写起来比较方便)。 使用ViewTreeObserver ViewTreeObserver可以注册GlobalLayoutListener , 当ViewTree的内部由一个View的可见性发现改变的时候 将会回调onGlobalLayout方法。但是要注意，这个方法会被调用很多次，所以这里只提一个思路，我本人并不推荐这个写法。","link":"/2019/09/18/Android3/"},{"title":"Activity的生命周期与启动模式","text":"这是这个系列的开篇，主要内容是Android相关知识点的整理。其内容内容来自于《Android开发艺术探索》的整理，故我也把它当作是复习开发艺术探索的读书笔记。 一、Activity的生命周期1、正常情况下Activity的什么周期:正常情况下，Activity经历的生命周期如下： onCreate() 表示Activity正在启动，这里编写用户的逻辑，比如数据的准备，视图的创建，Listener的注册。 这个方法调用的时候，Activity还未被创建好，也不可见。 onStart() 在perfromStart中调用 callActivityOnstart方法 &lt;— final 方法 表示当前的Activity正在被启动，on starting的意思。 在这个状态下，Activity已经可见了，但是由于没有出现在前台，所以不可见。 这个方法会在onCreate之后执行，所以这个时候Activity已经被创建好了 这个方法会将onStart指令分发给所有的子Fragment。(fragmentActivity中) onRestart Activity没有被完全销毁，重启的过程。 这种情况下，一般是用户的Activity离开前台退回到后台所导致的。 这个方法是在onStart()之前调用的。 补充：这个方法实际上是在performResume中调用的，performResume会首先调用perfromRestart，由于才创建的Activity的mStoped是false，所以perfromRestart直接return了，而performRestart里面会调用perfromStart来间接调用onStart方法。 performStart方法最终会将View变得可见(目前还不清楚具体的实现在哪里) onResume() Activity在onStart之后就已经创建完成。onResume是将其添加到window上，让其可见。 也就说onResume的时候Activity才正式显示到前台。 onPause() 表示Activity正在停止，这个方法是在onStop之前被调用的。 这个方法里面应该做一些停止动画的操作，但是不能太耗时。 这个方法会在新的Activity的onCreate方法调用之前被执行，所以如果这个方法耗时的话，新的Activity会被强制等待。 onStop() 表示Activity即将被停止，这个方法也同样不能太耗时。但是这个方法会在新的Activity的onResume之后才被调用。所以在调用这个方法的时候Activity已经变得不可见了。 说明：因为这个方法是在performStop里面调用的，而performStop里面会WindowManager将View从Window中移除了，onStop是在移除RootView之后被调用的。 onDestory() 表示Activity即将被销毁。用于做一些资源的释放。 注意：在内存不足的情况下从而导致Activity的非正常结束，这个方法是不会被回调的。 对应关系： onCreate -&gt; onDestory onStart -&gt; onStop onResume -&gt; onPause 注：对应关系并不是完全对应的，只是说宏观的流程下，这几个方法有如下的对应关系。 2、异常情况下Activity的生命周期异常情况下Activity的生命周期如下： 资源相关的系统配置发生改变导致Activity被杀死并重新创建 资源内存不足导致低优先级的Activity被杀死 （1）配置改变的情况(注意，这种情况activity算异常终止)： Activity会依赖于系统资源，如果系统的状态发生了改变会导致Activity所依赖的系统资源发生改变，因此Activity会进行重建。 手机的屏幕进行了旋转，Activity会进行重建(完全的重建)。 这种情况下Activity会被销毁，其onPause , onStop , onDestory均会被调用。 这种情况会调用activity的onSaveInstanceState方法 此方法会保存window的层级状态(通过调用window的saveHierarchyState方法) —&gt; Activity的视图结构 此方法会保存所有的fragment状态 此方法会保存所有的outfill状态（这个是什么东西？ 当系统重建的时候Activity会调用onSaveInstanceState方法。 因此，也可以在这个方法里面对保存的状态进行恢复 注意：这里保存的状态是是Boundle，故需要用Parceble来进行状态的保存。 （2）内存资源不足导致的Activity被重建的情况： 注意：在这种情况下，Activity的onSaveInstanceState方法也是会被调用的 Activity的优先级： 前台 可见但是并非前台：onStop没有被调用 后台：onStop方法被调用了 Avtivity脱离了四大组件很容易被杀死 对于Activity的配置发生了改变的情况，可以强制指定onConfigChange来拒绝系统重建Activity 在Manifast中指定configChange这个属性即可 注意：对于屏幕发生改变的情况，还需要指定screenSize属性 二、Avtivity的启动模式：任务栈：(1)任务栈是和App(包名)相绑定的 (2)注意任务栈是有前台和后台之分的。 (3)Activity不可见并不等于Activity就在后台的任务栈中。 一个Activity可能会有多个任务栈 任务栈通过taskAffinity进行指定 (4)出现前后台两个任务栈的例子： App1启动，打开了Activity A和Activity B 用户点击了Home，返回了主界面，此时App的所有任务栈回归后台。 用户启动了App2，并且通过App2的Activity启动了App1的Activity C Acitivity C是 singleTask，并且没有指定taskAffinity(即默认的) Activity C在前台任务栈，Activity A B 在后台任务栈。 四种启动模式： Standard: 标准模式，谁启动这个Activity，就压进启动者的任务栈，无复用机制，不绑定taskAffinity，始终创建新的实例。 SingleTop: 栈顶复用模式，有栈顶复用机制，其他的和Standard一样，不绑定taskAffinity SingleTask：栈内复用模式，绑定taskAffinity，三个强调点，如下： 系统会在指定的Task栈中创建新的Activity，并且在这个Task栈中实现单例，如果不指定Task栈的话，那就是默认的任务栈 (taskAffinity为包名) 尽管可能会在新的任务栈中创建Activity，但是点击返回会将焦点转移至原来的Activity，而不是这个Activity栈的下一个(当然也可能是，这个得看启动它的Activity所在的栈)。 这个Activity会在这个任务栈中实现单例，并且被赋予焦点的时候会将上面的所有Activity全部出栈。 如果前台任务栈启动了后台任务栈的方法，会把整个后台任务栈搬到前台来 这种情况，点击返回就会将此栈一一退出，因为后台栈已经和前台栈合并了 SingleInstance：全局单例的模式，Activity会维护一个自己的栈，并且这个栈中就只有这一个Activity。 android:taskAffinity属性：用于标记Activity所属的Task，默认的情况下值为应用的包名。 LaunchMode 为 singleTask的Activity LaunchMode为singleInstance的Activity 使用flag＝Intent.FLAG_ACTIVITY_NEW_TASK启动的Activity LaunchMode和Intent Flag的对应关系： FLAG_ACTIVITY_NEW_TASK &lt;==&gt; SingleTask FLAG_ACTIVITY_SINGLE_TOP &lt;==&gt; SingleTop FLAG_ACTIVITY_CLEAR_TOP： SingleTask默认带有ClearTop标志 如果Standard/或者SingleTop设置了FLAG_ACTIVITY_CLEAR_TOP的话，如果栈内有，会将当前栈的上面的全部去掉(包括原有的Activity)，再创建一个新的实例。 启动模式的指定： 通过配置AndroidMenifest实现 通过在Intent中设立标志位来实现 比较： 第一种的优先级更低 第一种无法为Standard设置ClearTop 第二种无法实现SingleInstance 三、IntentFilter的匹配规则：IntentFiler 用于匹配隐式的Intent 三个匹配规则：注意：三个匹配规则需均满足才能匹配成功。 action 匹配规则 category 匹配规则 data 匹配规则 Action： Activity可以设置多个 Intent只有能够匹配让其中的一个即可 如果不设置的话，就永远匹配不上 对于Intent来说，Intent只能设置一个Action属性 category： Intent和Activity均能够设置多个 intent设置的categoriy需要均匹配上 如果intent不设置，则其会设置默认的DEFAUT 对于Activity，需要设置DEFAULT来接受Intent中DEAFULT的匹配条件 Data 实际上只需要匹配两个内容： URI MimeType 由于URI结构比较复杂，故在注册Activity的时候，需要对URI的每一个结构单独设置匹配条件 Activity的Data可以设置多个 Intent的Data需要完全匹配上Activity中的其中一个才能通过 Intent中通过Uri.parse(string) 指定Uri，指代MIME的string 指定MimeType setData 和 setType有冲突，如果都要匹配，需要调用setDataAndType方法 URI的schema必须指定此URI才有效(才能够接受匹配) 判断是否有Activity能够匹配Intent： PackgeManager.resolveActivity方法 Intent.resolveActivity方法(其实就是调用的PM的resolveActivity方法，只是做了封装)","link":"/2019/09/13/Android1/"},{"title":"EffectiveJava笔记[二]","text":"EffectiveJAVA的读书笔记 [二] _ (:з)∠) _ 6、避免创建不必要的对象此条目下作者有这个观点：当你应该重用现有对象的时候，请不要创建新的对象 最突出的就是字符串常量创建的例子： 1String str = new String(\"hello\"); 如上所述，本来在字符串常量池中就存在字符串”hello”，但是我们又创建了一个新的字符串”hello”的实例，显然，这个新的str实例是并不需要的。 使用静态工厂方法： 构造方法一定会创建一个新的对象，但是其实很多时候并没有这个必要。对于一些可以重用现有对象的情况，我们可以使用静态的工厂方法来获取实例（因为静态工厂方法是九二一对实例进行严格控制的）。 缓存创建昂贵的对象： 对于那些可以复用的但是创建昂贵的对象，我们可以将其设置为公共静态的，这样既可以避免重复创建带来的性能开销，也可以避免持有这个对象的容器对象在失去引用后被GC清理掉。 注意，这里很容易进入一个误区，就是对那些(可能)会重用的对象都进行缓存。 这个条目并不代表对象的创建是昂贵的。其实通过构造方法创建和回收对象的性能开销并不高。 作者在此条目的下面提到： 除非池(对象缓存)中的对象非常重量级，否则通过维护自己的对象池来避免创建对象其实并不太好，因为者会显著的加大内存的占用。 回到条目的开始，我们应该将重点放在重用和不要创建新的对象上面。也就是说，我们更多应该考虑的是在重用某个对象的时候，尽可能的去避免创建新(没有必要)的对象。 7、消除过期的对象引用：这里有一个误区，就是JAVA拥有垃圾收集机制，所以我们就不需要手动对内存进行管理了。 但是，其实这个是不一定正确的，内存泄漏在JAVA里面太频繁了。 作者在书中提到当一个类自己管理内存时，程序员应当警惕内存泄漏，书中举了一个栈弹出的例子： 12345public Object pop() { if (size == 0) { throw new EmptyStackException(); } return elements[--size]; 可以看到，这种实现实际上仅仅是将size的-1了。但是elements任然保留着对size外的元素的引用，也就是说那一部分的元素的内存并不会被GC释放掉。 解决方案： 12345678public Object pop() { if (size == 0) { throw new EmptyStackException(); } Object result = elements[--size]; elements[size] = null; return result;} 8、避免使用Finalizer和Cleaner机制这可能对JAVA新手来说一脸懵逼(没错，我就是这种。因为压根就不知道什么是Finalizer，这里就不谈Cleaner机制了，因为我现在还是不会，不过功能应该和finalizer差不多) 对于C++程序员，我们知道有一个析构函数用于回收资源。 Finalizer机制： GC在回收对象之前调用其finalize方法，但是这并不说明finalize就等于C++的析构函数。finalize方法的调用存在很大的不确定性，也就是说它的调用在不同设备上面的行为具有很大的差异。 当一个对象变得不可达一直到finalize方法的调用这一段时间是任意长的。所以我们千万不要在这个方法里面做一些关闭文件流这种释放非内存资源的操作。因为很有可能出现文件流没有被及时的关闭从而导致后面的文件流打开失败。 finalize机制已经被弃用了。 Java并不能保证Finalizer和Cleaner机制的及时运行，甚至不能够确保他们是否能够运行 System.gc和System.runFinalization 可能会增加finalize被执行的几率，但是不保证其一定被执行 在Finalizer机制中，未被捕获的异常会被忽略，cleaner机制不会有这个问题 Finalizer机制会严重影响垃圾收集的效率和性能 Finalizer机制的作用： 作为安全网，防止资源拥有者忽略了他的close方法。这个很好理解，当资源拥有者忘记close的时候，通过finalize至少可能会关闭资源，着总比不关闭好。也就是说，这个机制虽然不可信，但是聊胜于无。 finalize方法适用于释放一些通过native方法释放的对象(比如说通过JNI创建的对象) 9、使用try-with-resources语句替代try-finally语句可能你刚看到这个条目的时候会和我一样对于什么叫做try-with-resources语句一脸懵逼(本人太菜，之前确实没有见过) 书中举了这样一个例子： 12345678static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); }} 在上述的代码块中，有可能由于文件流的没有正常打开导致异常出现。同理，由于引用了空的对象，br无法正常调用close方法。那么在这次情况下第二个异常会完全覆盖掉第一个异常。如果使用了catch语句块捕获了异常，那么代码就会变成如下的样子： 123456789101112131415static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } catch (IOException e) { e.printStackTrace(); } finally { try { br.close(); } catch (Exception e) { e.printStackTrace(); } } return null;} 这种代码，写出来简直辣眼睛。反复的异常捕捉显著的降低了代码的可读性。 使用try-with-resources语句： 1234567static String firstLineOfFile(String path) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch (IOException e) { return defaultValue; }} 相较于之前的代码，显然可读性有所提高。 原理： 能够使用try-with-resources语句的资源类其实都自动实现了AutoCloseable接口这个接口提供了一个无参数的close方法。也就是说，使用了try-with-resources语句声明的资源只要实现了这个方法，那么都会在抛出异常之前调用close方法关闭资源。另外，用于资源对象的close方法是由其自己控制，所以我们也不需要考虑资源文件关闭所产生的异常。 10、重写euquals方法时应当遵守的通用约定不需要重写equals方法的条件： 每一个类的实例都是一个固有且唯一的。 类并不需要提供一个逻辑相等的测试功能。 父类已经重写了equals方法。一个设计良好的可继承的父类应保证其子类完全实用于父类的equals方法。 类是private修饰的或者default修饰的，那么这个类的equals方法应该永远不会被调用。 需要重写equals方法的条件： 一个类包含逻辑相等的概念，并且父类并没有提供equals方法。这里特指一些表示值的类，比如Ineger或者String类。 使用equals方法的时候应当比较的是对象逻辑上面的相等，而并不是比较是否引用的是相同的对象。 当某一个类需要作为Map的key的时候。 equals方法应当满足的属性： 自反性：一个对象必须和自身相等 对称性：a.equals(b) == b.equals(a) 传递性：a.equals(b)，b.equals(c)，则a.equals(c) 一致性：相等的对象永远相等，不相等的对象永远不相等 非空性：所有的对象都不等于null 编写高质量的equals方法： 首先使用==运算符检查参数是否为该对象的引用，如果成立直接返回true，这是一种性能优化。 应当使用instanceof检查传递参数是否有正确的类型，因为equals方法默认传递的参数是Object类型的 将参数进行强制类型转化 对于参数的每一个值属性，应当验证值属性是否相等，注意，对于float或者double类型，不要用==而是使用Float.compare或者Double.compare方法比较。 对于参数的对象属性，应当递归的对持有的对象进行equals比较，由于对象引用可能为空，所以对引用对象进行比较的时候，应当使用Object.compare方法 使用equals方法进行比较的时候，应当首先考虑最有可能不同的属性，这也是一种性能优化。 不要忘记验证自己实现的equals方法是否满足上面提到的5个属性。 注意事项： 重写equals方法的时候，应该重写hashCode方法 不要对equals方法太过于吹毛求疵，这可能会因为考虑因素太多导致实现非常困难。 重写equals方法的时候，参数是Object类型的，不要将参数替换成其他的类型。","link":"/2019/07/24/EffectiveJava笔记2/"},{"title":"EffectiveJava笔记[三]","text":"EffectiveJAVA的读书笔记 [三] _ (:з)∠) _ 11、重写equals时重写hashCode方法在每一个重写了equals方法的类中，应当重写这个类的hashCode方法。如果不这么做，那么将会违背Object.hashCode的通用约定，从而导致某一些基于hash散列的集合无法正常运行，比如说HashSet， HashMap，HashTable。 规范： 在程序执行的这段时间，如果对象equals方法进行的比较信息没有被改变的话，那么这个对象的hashCode该返回同一个整数。 如果这个应用程序多次执行，那么没有必要保证每一次的hashCode都是一样的。 如果两个对象通过equals方法比较是相等的，那么他们的hashCode应该一样 如果两个对象通过equals方法比较是不相等的，那么他们的hashCode不应该一样。 对于基于hash散列的类来说，如果不重写hashCode方法的话，那么即便他们通过equals方法得到的结果是true，那么将他们作为hashMap的key也无法拿到正确的值，因为他们只是逻辑上相等，而hashMap是基于hashCode寻址的。 hashCode的计算： 为对象中的每一个关键域f，计算其散列码c 1result = 31 * result + c; 返回 result 注意： 如果一个域的值是由其他域演算出来的话，那么这个域不需要用于计算hashCode 如果一个域并没有在equals方法中使用，那么这个域不应该用于计算hashCode 不要排除一些关键的属性来提高hashCode的性能，这可能会降低这个方法的可靠性 在编写完hashCode之后，应当测试hashCode功能的正确性 如果一个对象计算hashCode的代价比较大的话，应当缓存这个hashCode 12、始终重写toString方法虽然Object类提供了toString方法的实现，但是在某些情况它返回的toString并没有什么乱用。提供一个良好的toString方法可以使类更易于使用和调试。 toString方法应当返回对象中包含的所有需要关注的信息 应当在文档中指定toString方法返回的格式 在静态工具类中，编写toString方法是没有任何意义的。 应当在任何抽象类型中定义toString方法，使得子类共享一个公共字符串表示形式 除非父类已经实现了toString方法，否则应该在每一个实例化的子类中重写toString方法。 13、谨慎地重写clone首先需要指出，这个条目是基于Cloneable接口或者说clone方法而列出的。Cloneable接口是一个空的接口，它仅仅用来表明这个对象是允许被克隆的。真正的clone方法的提供是在Object类中。这一点也被作者在书中描述为设计上面的缺陷。 Cloneable接口： 这是一个并未包含任何方法的接口，它的唯一作用就是决定Object类中clone方法实现的行为。换句话说，如果一个类实现了Cloneable接口，那么它就应该在clone方法里面返回对该对象的逐域拷贝，否则就会抛出CloneNotSupportedException异常。 这是一种比较极端的写法，因为它违背了定义接口的作用。 这是一种可以不调用构造器就创建对象的方法。 对于clone方法的一些约束： 1(x.clone() != x) == true 1(x.clone().getClass() == x.getClass()) == true 1x.clone().equals(x) == true 解读： 不得不说，这本书的翻译是真的烂。(:з)∠)_ 上面提到的不调用构造方法就可以创建对象的规定其实太过于强硬，或者享有了太大的特权，想象你好不容易实现了一个单例，并通私有构造方法并抛出异常，甚至提供了readResolve这个方法来保证反序列化也是单例。但是一旦你实现了Cloneable，接口并重写了clone方法，那么你好不容易设计的单例会因为clone而失效。作者指出行为良好的clone方法，应该是可以调用构造器来创建对象的，但是遗憾，clone并没有这么做。 作者强调（通常情况下）(x.clone().getClass() == x.getClass()) == true这个规定太过于软弱。这里我理解了半天。为什么叫过于软弱，因为它不是强制要求的，因为clone指出了不通过构造器就创建对象，但是却允许了(x.clone().getClass() == x.getClass()) != true。举个例子：比如我有一个child类，他继承了他的父类，但是并没有重写clone方法，那么这个方法将最终调用父类的clone。但是很遗憾，父类的设计者并未考虑到这个问题，因为他约定clone的一些约束，允许上面的不等条件出现，所以他使用了构造方法来clone了对象的副本。那么当子类调用clone方法的时候，你会惊讶的发现居然返回的是父类的对象，甚至你无法通过强制类型转化将其转化过来。 为了避免上面的情况，保证子类通过调用super.clone()也返回自己的实例。我们的父类也应该调用自己的super.clone()（父类的父类的clone方法）。在这种层层传递下，所有的super.clone()最终都会调用Object.clone()方法，这样就能保证在整个类的层级结构中，所有的子类的clone()方法最终均会返回Object的对象，由于 Objcet.clone()返回的是对象的逐域拷贝(也就是对整块内存的复制)，所以最终我们只需要进行强制类型转化即可。 很遗憾的是，Cloneable接口并没有清楚的指出一个类实现这个接口应该承担什么责任。 浅克隆： 这里作者列举了一个Stack类的例子： 12345678910111213141516171819202122232425262728public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { this.elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // Eliminate obsolete reference return result; } // Ensure space for at least one more element. private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); }} 我们可以看到，Stack类持有Object数组的应用。当我们克隆这个对象的时候，理想情况下，Stack的elements也会跟随一起被克隆，然而很遗憾，克隆出来的的对象和原来的对象持有相同element对象的引用，也就是说，克隆的时候，只传递了引用。 深克隆： 其实就是针对上面问题的一个解决方案罢了。 对于对象持有的对象引用，我们应当递归(或迭代)地调用这些对象的clone方法。 1234567891011121314151617181920@Override public HashTable clone() { try { HashTable result = (HashTable) super.clone(); result.buckets = new Entry[buckets.length]; for (int i = 0; i &lt; buckets.length; i++) if (buckets[i] != null) result.buckets[i] = buckets[i].deepCopy(); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); }}Entry deepCopy() { Entry result = new Entry(key, value, next); for (Entry p = result; p.next != null; p = p.next) p.next = new Entry(p.next.key, p.next.value, p.next.next); return result;} 克隆的替代方案： 对于那些确定是不可变的类，最好不要实现clone方法，因为这没有意义。 使用拷贝构造器或者拷贝工厂 使用基于接口的拷贝构造器(转换构造器)或者拷贝工厂(转换工厂)。 14、考虑实现Comparable接口compareTo方法并没有在Object类中声明，它是Comparable接口中的唯一方法，其实这个是很好理解的，因为我们并不需要每一个对象都是可以比较大小的。 compareT方法 1int compareTo(T t) 可以看到，这个方法是泛型的，并且返回的结果是int类型。其值和比较的结果关系如下： 负数：＜ 0：= 正数：&gt; 好处： 通过实现Comparable接口，可以让类与所有依赖此接口的通用算法和集合实现来进行相互操作。并且几乎所有的JAVA平台类库中的所有值类都实现了这个接口。 要求： sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) == true (x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) == (x.compareTo(z)&gt;0) == true x.compareTo(y) == 0 —&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z)) (x.compareTo(y) == 0) == (x.equals(y)) 注意，与equals方法不同的是，equals方法有可能花月不同类型的对象，而compareTo遇到不同类型的对象的时候，会直接抛出异常。 注意： 不要使用两个值之间的差值来返回compareTo的结果，这种写法可能会导致整数的最大长度溢出。 使用compareTo方法的时候，应当避免使用 “&lt;”(小于)或”&gt;”(大于)。在具体的值进行比较的时候，应当使用静态的compare或者Comparator接口中的构建方法。 15、使类和成员的可访问性最小化一个良好设计的类应该隐藏它的所有实现细节，仅仅对外暴露API，这样会比较干净。其他的组件，通过API和他们进行交互，并且对他们的内部工作应当一无所知。这个概念被称为封装。 封装的优势： 将组成系统的组件分开，允许他们被独立的开发，测试，优化。 拥有不同功能的组件可以并行开发。 可访问性最小化原则：让每一个类或成员尽可能的不可访问，即尽可能的降低访问级别。 一个顶级类(.java文件中的直接定义的类)或接口的访问级别只能是 default或者public的。如果没有必要将其设置为pubilic，那么我们就应该将其设置为default的。 当我们把一个类设置为public的时候，那么它就拥有导出API的功能，在这种情况下，我们应该有义务维护这个类，让其保持着API的兼容性。当然如果是default的话就没有这个必要，因为它是包级私有的，并不拥有到处API的功能，仅仅是组件实现的一部分。 如果一个default修饰的顶级类只被一个类使用的话，那么我们应该考虑将这个类作为其使用者的私有静态嵌套类。 对于一个public修饰的类，我们在设计其成员的时候，应该尽可能的将其成员设置为私有的。 注意： 如果一个类存在一个是public且非final的实例属性，那么我们就放弃了限制这个实例的属性被修改的能力，并且当这个实例的属性被修改的时候，我们也并没有解决的方案。 即便是类中的实例属性是final的，也只能保证它引用的对象无法改变而无法保证它引用的对象的属性保持不变。 对所有的静态属性也是如此。我们通过public static final 来表示一个常量。但是，如果其引用的是一个对象，虽然对象的引用无法被修改，但是我们我发保证对象的属性保持不变。 所有的public static final 修饰的长度不为0的数组，我们也应当注意，因为它是可变的。 相关链接：EffectiveJava笔记[一]EffectiveJava笔记[二]","link":"/2019/07/24/EffectiveJava笔记3/"},{"title":"这是一篇非常详细的View事件分发机制的源码分析文章","text":"我不管你看不看得懂，反正只要我看得懂就行了 —— john pig 为了准备接下来的面试，这几天又在看《开发艺术探索》，老觉得View的事件流程看的不是很明白，索性干脆直接上源码刨根问底，肝了两天，终于是对View的事件流程有一个详细的了解。 本来打算像其他的大佬一样把源码拆开，结合图文描述关键方法的。但是发现这样做很难弄清整个流程的具体逻辑，脑子里可能就一个大致的流程图，也就逮住几个关键方法侃侃而谈。这样做或许可以快速了解，但是由于没有深入，始终不能留下深刻的印象。并且对于我自己来说，本来就对着整个流程了解不够清晰，一口气看完来写想必会忘记不少细节；而一边看一边写又容易分心，并且很容易纠结某一个细枝末节的东西而失去整体的框架。 好了，废话不多说。请慢慢 read the fucking code 吧 ViewGroup的dispatchTouchEvent()ViewGroup.java#dispatchTouchEvent() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363public boolean dispatchTouchEvent(MotionEvent ev) { //省略掉开头的一些看不懂的代码... //dispathcTouchEvent的返回值 //用于表示当前的View(ViewGroup是否消耗了此次点击事件) boolean handled = false; //一个安全策略，主要用于过滤屏保的时候的点击事件的分发 //如果被拦截了，那么dispatchTouchEvent直接返回false if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // ACTION_DOWN的时候，会将之前的状态清理 if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); // FLAG_DISALLOW_INTERCEPT会被重置为空 // mFirstTouchTarget在这个方法中被重置为空 resetTouchState(); } // 用于判断此ViewGroup是否拦截这个事件 // 两种类情况 // (1)、MotionEvent.ACTION_DOWN,即这是一次点击的事件(按下去,还未抬手) // (2)、mFirstTouchTarget != null：首先说明，这种情况一定不是ActionDown(不考虑多点) // 有可能是ACTION_MOVE 或者 ACTIION_UP // 同时也表示了此ViewGroup在最近的一次ACTION_DOWN事件 // 所导致的dispatchTouchEvent返回的结果是true。 // (因为如果是False的话,那么DecorView的mFirstTouchTarget是空的,后续的点击事件就不会通过 // DecorView的mFirstTouchTarget传递下来，那么这个View就一定不会收到除了ACTION_DOWN外 // 的所有的事件。 // 同时因为mFirstTouchTarget不为空，即说明了此View的dispatchTouchEvent返回true是因为 // 此parent有child消耗了这个ACTION_DOWN // // // 同时这里也反应了另外一个策略， // (在一个事件序列中)parent的dispatchTouchEvent一旦返回了true // 那么在后续的事件序列中: // (1)、dispatchTouchEvent一定不会被再次调用 // (2)、后续的所有TouchEvent一定会被这个parent拦截， // (3)、后续的所有TouchEvent均会触发这个parent的消耗 // (4)、这个parent的mFirstTouchTarget链表会被移除 // (5)、这个parent的所有子View一定不会接受到后面传来的事件 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { intercepted = true; } //表示此View是否被Cancel掉了 //cancel的消息来自于其parent //当在处于非ACTION_DOWN的事件序列中的某一个事件，且被其parent拦截了 //那么其parent仍然会调用此View的dispatchTouchEvent,但是传递过来的 //event是ACTION_CANCEL, 通知此View清空自己的mFirstTouchTarget final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; //一个引用，用来指向在ACTION_DOWN事件来的时候 //新加入到mFirstTouchTarget链表中的节点 //同时会用于一些在多点触控中的判断 TouchTarget newTouchTarget = null; //防止消耗了ACCTION_DOWN的child在添加到了 //mFirstTouchTarget之后再次被调用 //dispatchTouchEvent这个方法的一个标志 boolean alreadyDispatchedToNewTouchTarget = false; //注意：这里的代码块的执行和actionDown没有说明关系！！！ //actionMove 和 actionUp 均会进入这个代码块 //内部有一个单独的关于ActionDown的判断 if (!canceled &amp;&amp; !intercepted) { //省略部分(或许)无用(主要是看不懂)的代码 //用于找出能够消耗点击事件的子View //并通过调用子View的DispatchTouchEvent方法 //来判断子View是否会消耗会这个点击事件 //注意：遍历会一直持续到有子View返回了它将消耗此事件结束。 //也就是说，对于哪些Z轴在上但是并不打算消耗点击事件的子View //它们的dispatchTouchEvent均会被调用 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; final int childrenCount = mChildrenCount; //这里的newTouchTarget一定为null //单点的情况下mFirstTouchTarget一定为空 //因为前面的ActionDown把mFirstTouchTarget重置了 if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); //将所以的child按照Z轴的顺序，创建一个List //z值越大的在越上面 final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); //这里的cutomeOrder并不是说子View的顺序就是按照人为自定义的 // //这里有一个先前条件，就是preorderList == null //在内部代码里面我们可以看到，如果所有的child的Z均是0的话 //那么preorderList就是null，这种情况下子View会根据 //draw的顺序去拿 //这里我们推测，当用户设置了setChildrenDrawingOrderEnabled(true) //的时候，所有的子View的Z轴均是0 final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); //所有的子View构成的数组 final View[] children = mChildren; //遍历整个childList //其实不是childList,而是将child通过z轴的值进行排序的一个List //就是上面提到的preoderList // //然后从上至下寻找能够接受整个点击事件的child //再调用child的dispatchTouchEvent //判断child是否消耗这个点击事件 for (int i = childrenCount - 1; i &gt;= 0; i--) { //因为有上面的customer标志位，所以实际上遍历的子View的顺序 //并不一定是按照Z轴，也就是说在这个方法里才会真正拿到 //子View的位置，即确定子View的遍历顺序 //(1)、preorderList重前至后的顺序 //(2)、View的绘制顺序 //(3)、mChildren的逆序，及child被add的顺序 final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); //获取这个child final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); //这个方法会判断子View是否能接收到这个点击事件 //这里还没有调用子View的dispatchTouchEvent //如果子view不能够接受的话，就说明这个点击的点在子View的范围外 //直接continue // //同理，只有下面的代码块只有能够接受到点击事件的child才能够被执行 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } //注意：能接触到此代码块的child一定能够接受点击事件 //遍历整个mFirstTouchTarget,寻找child是否在mFirstTouchTarget //中出现过。 // //这里在单点的情况下一定是没有的,所以这个方法的针对的是多点的情景。 //可能是防止多点的时候多个ACTION_DOWN作用到了同一个View上 //导致被多次调用了dispatchTouchEvent的情况 //到目前 mFirstTouchTarget 还是null newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { newTouchTarget.pointerIdBits |= idBitsToAssign; break; } //调用dispatchTransformedTouchEvent // // 这里注意一下，上面传下来的child一定是非空且能够接受点击事件的 // //因为进入方法块的条件是mChildren.length &gt; 0, //且不能接受点击的被continue了 // //这里的主要作用是调用Child的dispatchToucEvent方法 // // 调用自己onTouchEvent(super.dispatchToucEvent())方法是在下面 // //这个判断条件进入了之 //也就是说dispatchTransformedTouchEvent返回了true就直接break了 //可能后面也有子View能够接受点击事件,但是均不会被调用 //dispatchTouchEvent方法了 // //如果返回了false,只有一种条件，有child能够接受这个点击事件，但是child不 //打算消耗它(比如说child实际也是一个ViewGroup) //所以这种情况下，继续遍历寻找其他能够接受点击事件的child，看他们 //是否打算消耗这个点击事件 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { mLastTouchDownTime = ev.getDownTime(); //进入了这个方法块其实就已经表示了child能够接受这个点击事件了 //这里需要遍历一波children，来标志最后一个被点击的child //注意，这里的Index是指的在chidren数组中的index if (preorderedList != null) { for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } //记录一下最后一次TouchDown的位置 //猜测和多点触控有关 mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //这个方法会将child添加到mFirstTouchTarget链表中 //这会使得newTouchTarget和mFirstTouchTarget都不为空 // //注意这里的break： //也就是说，只要有一个child消耗了点击事件，这个循环就已经退出了 //即：对于任何(单)点击事件来说，mFirtTouchTarget中只可能存在 //一个元素，就是消耗actionDown的那一个child newTouchTarget = addTouchTarget(child, idBitsToAssign); //这个标志位用于后面防止再调用一次dispatchTransformedTouchEvent alreadyDispatchedToNewTouchTarget = true; break; } } //preorderList已经没有用了,释放内存 if (preorderedList != null) preorderedList.clear(); } //考虑到这个代码块是处于ACTION_DOWN的前置条件的 //这里实在想不到newTouchTarget == null但是 mFirstTouchTarget 不是 null //的场景，猜测可能和多点触控有关，这里我们就先不管 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } //如果有子View消耗了点击事件的话，mFirstTouchTarget会指向消耗事件的child //此时child的dispatchTouchEvent方法已经被调用了 // //ViewGroup自身的super.dispatchTouchEvent方法是在这里被调用的 //即：ViewGroup自身的onTouchEvent是在这里被调用的 // //对于ViewGroup，如果其子View消耗了这个点击事件，那么它将不会被调用onTouchEvent //但是它仍然会对其上级ViewGroup表示它已经消耗了这个点击事件(尽管是它的child消耗的) if (mFirstTouchTarget == null) { // //mFirstTouchTarget 是空就说明这个ViewGroup的所有child均没有消耗这个点击事件 //强调：不是说child接受不到，只是说child没有消耗. //即: 能接受点击事件的child的dispatchTouchEvent方法,返回的是false // //注意，这里所说的消耗是dispatchTouchEvent(onTouchEvent)向上级返回的结果 //而默认情况下(对于ViewGroup来说)，这个方法的返回值是false //这里要排除一个情况，就是clickable的情况 //补充：如果view是clickable的话，就要单独考虑 // //以下为调用自己的super.dispatchTouchEvent --&gt; onTouchEvent handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // //遍历整个mFirstTouchTarget链表 //一般来说这里的链表应该只有一个元素，就是之前能够接受点击事件的元素 //在这个链表的遍历中，只要有一个child的onTouchEvent返回了true,那么此方法就会返回true // TouchTarget predecessor = null; // &lt;--指向链表的前驱 TouchTarget target = mFirstTouchTarget; // //注意这里是一个while，会被调用多次的 //下面会提到，如果parent打算拦截child的话，会将TouchTarget移除 //也就是说，parent打算拦截，整个接受传递事件的序列均会被移除 //(先不管resetCancelNextUpFlag 这个方法) while (target != null) { final TouchTarget next = target.next; // //可以看到，前面创建的newTarget是用来暂存那个消耗了点击事件的child的 //这个判断只会针对actionDown,因为在任何的非down的action,newtarget都是null if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { // //ActionDown的后续事件序列将会进入这个代码块 //因为newTouchTarget为空，并且mFirstTouchTarget非空 // //前面提到了onInterceptTouchEvent是在整个事件序列中均进行判断的 //也就是说在后续的事件序列中onInterceptTouchEvent仍然会被多次调用 //只要有一次onInterceptTouchEvent方法返回了true，那么后面的整个事件序列 //均会被整个ViewGroup所消耗了,并且在这一次事件中会把所有的能够接受事件的child //移除，也就是说，即使这个事件序列后面parent不拦截了(比如说滑动) //这些事件仍然不会被分发给这些child(因为mFirstTouchEvent已经被移除了) //注意，这里会调用child的dispatchTouchEvent //但是会给child传递一个cancel事件 // //!!!!!!注意一下这里的resetCancelNextUpFlag方法 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { //前面提到touchTarget是一个链表的结构 //如果一个点击事件被ViewGroup拦截了的话 //ViewGroup会把链表中的这个touchTarget节点移除掉 //如果是第一个节点，就直接把mFirstTouchTarget移除 if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } //被发送cancel的TouchTraget，直接被recycle了 //即被发送了cancel事件的子view会从TouchTarget链表中移除 target.recycle(); target = next; continue; } } predecessor = target; target = next; } } //三种情景 //(1)、接受到了Parent传来的cancelEvent //(2)、此次事件是ACTION_UP //(3)、此次事件是ACTION_HOVER_MOVE // //此ViewGroup会清空其mFirstTouchTarget //并且会把FLAG_DISALLOW_INTERCEPT也重置 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); // //看不懂。。。。。 } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } // //看不懂。。。 //大概就是通知该事件被忽略掉了 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled;} View的dispatchTouchEvent()相比ViewGroup，View的onTouchEvent方法就相对来说简单很多了。我们只需要注意一下这个方法对于onTouchEvent的判断逻辑就行了。 View.java#dispatchTouchEvent() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public boolean dispatchTouchEvent(MotionEvent event) { //省掉一些看不懂的代码 boolean result = false; //mInputEventConsistencyVerifier用于检测这个输入的 //事件序列是否完整和Log通知用户的 //比如说用户点击事件的ActionDown被此View消耗 //但是因为开发者在自定义ViewGroup中错误的拦截逻辑 //导致了ActionUP事件未传递到这里来 //那么这个类将会检测到这种问题，并且在Log中通知 if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } //如果是ACTION_DOWN的话，会尝试停止嵌套滚动 //由于本人对嵌套滚动的原理并不太熟悉 //但是点进去可以看到，里面其实就是把嵌套滚动的相关标志清除了 //这里可以联想ViewGroup的dispatchTouchEvent方法 //在ACTION_DOWN的时候，也会重置整个View的事件序列 final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { stopNestedScroll(); } //同ViewGroup一样，onFilterTouchEventForSecurity 是一个安全策略 //主要是用来拦截屏保下用户的误触 // //先宏观的看一下这个代码块 //(1)、几乎所有的判断逻辑都是返回的true //(2)、onTouchListener的onTouch方法在这里被调用 //(3)、onTouchEvent 方法在这里被调用 // //也就是说ViewGroup只有调用了super.onInterceptTouchEvent //才会调用onTouchEvent方法 // //这里有一个要注意的地方，就是第一、二个判断条件 //和第三个判断条件，也就是调用onTouchEvent的方法是互斥的 //也就是说，只要View设置onTouchListener并且返回了true //的话，View的onTouchEvent方法是不会被调用的 if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } //如果不进入安全策略才可能会进入这个代码块 //这个代码块其实没啥用，就是Log通知一下 //这个Event并没有被这个View消耗 //前面提到已经谈了InputEventConsistencyVerifier的功能 //这里就不在赘述 if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } //同ViewGroup一样，在ACTION_UP的时候 //View自身也会尝试清理View事件序列的状态 if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result;} OnTouchEvent()然后我们再来看一看View的onTouchEvent方法。我发现很多人的博客对于onTouchEvent的描述都是比较少的，确实也应该这样，因为onTouchEvent方法不像ViewGroup的dispatchTouchEvent那么复杂，并且相对来说对整个View的事件机制也没有这么重要(我的意思是逻辑比较固化 ， 不算是一个难点，一般来说了解一下流程就可以了)。 View.java#onTouchEvent() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322public boolean onTouchEvent(MotionEvent event) { //获取点击的x坐标和y坐标 final float x = event.getX(); final float y = event.getY(); //前面提到了viewFlag是用来存放View状态的一个标志位 final int viewFlags = mViewFlags; //获取点击事件的种类 final int action = event.getAction(); //判断这个View是否是可以点击的 //可以看到，实际上View是否可以点击是通过viewFlags的某一个标志位来获取到的 // //注意：这里无论是CLICKABLE 还是 LONG_CLICKABLE 均被视为可点击的 //不过Android实际上对于长按的检测和onLongClick的调用 //是在ACTION_DOWN的判断逻辑中而onClick是在ACTION_UP // //补充： //(1)、如果一个View同时设置了onLongClickListener和clickListener时 //如果onLongClick返回了false,那么mHasPerformedLongPress是为false的 //也就是说，在ACTION_UP的场景View还是会调用onClick //(2)、如果onLongClick返回了true,也就是说长按消耗了这个点击事件 //那么mHasPerformedLongPress就是true,这个时候onClick是不会执行的 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //如果这个View是不可触摸的话 //按道理就应该直接返回false了,因为disable的View不应该能够消耗这个事件 // //但是看下面的注释我们知道 //对于一个被disabled的View如果设置了clickable //逻辑判断它会消耗这个事件(虽然什么事情都没有做,只是返回true了而已) // if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; //clickable是False返回false //clickable是True返回true return clickable; } //这个Delegate是用来扩大一个View的点击范围的 //所以在这里我(们)就不研究它了 //只需要注意一下，只要有Delegate的话，此View //的onTouchEvent方法就会返回True if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //如果这个View是可以点击的或这个设置了TOOLTIP的话，就进入下面的代码块 //TOOLTIP是指这个View可以被长按弹出一个小小的提示 // //只要View是clickable的，那么它的onToucEvent就一定会返回true // if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: //privateFlag这里是非公开API的内容,这里我们不管 mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; //点进去我们可以看到，ACTION_UP的的时候 //View会把ToolTip隐藏,并且将TOOLTIP的callback移除 if ((viewFlags &amp; TOOLTIP) == TOOLTIP) { handleTooltipUp(); } //在只有设置了TOOLTIP的情况下才会进入这个代码块 //也就是说, 设置了TOOLTIP并不代表View可以点击 //同样,这里做了一堆把CallBack移除的操作 // //注意下面，直接就break了, 即后续的判断都不考虑 //也就是说，对于ToolTip，在ACTION_UP的时候 //所做的操作是清理状态和标志的 if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } //一个表示prepressed的标志位 //prepressed是一个不可描述的奇怪的标志位 //表示的是在ACRION_DOWN和pressed之间的状态 //大概就是如果按压的时间在115ms之内 //那么这个较短的按压不会被算作press //而是被称为prepress的状态 boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; // //注意这里的代码段是基于ACTION_UP的 //下面的代码段的场景描述的是在pressed状态或者prepressed //状态下用户手指抬起来了,即ACTION_UP的时候的场景 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // //注意： //对于View，只有满足clickable才能够获取到焦点， //但是这并不代表满足clickable就一定能获取到焦点 //即：clickable是获取焦点的必要条件 // //所以前面直接break也是有原因的(因为根本就进不来 //同理可知：能够进入下面这一部分的这一段代码 //View一定是能够被点击的 // //由于在ACTION_UP的时候， //View会响应一些用户交互，比如editText弹出键盘 //所以View会尝试获取focus // //注意： // (1)、isFocusable的意思是这个View可以获取焦点，而不是已经获取了 // (2)、对于触摸屏的情况，我们只需要考虑isFocusableInTouchMode， // 前者是针对的是键盘或者遥控器的场景 // (3)、requestFocus()会返回这个View是否成功的获取了焦点 boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } // //前面提到prepress是115ms之内的一个预判定的状态 //由于用户在很短的时间内手指离开了屏幕 //115ms的press判定还没有开始 //即：drawableHotspotChanged这个方法还未调用 //drawableHotspotChanged 会记录手指的位置 //用于后面涟漪动画播放的中心位置的选择 // //但是这里drawableHotspotChanged还未调用 //而这次ACTION_UP很有可能是一次点击事件 //而点击需要播放动画，所以这里强制执行一次setPressed //用于记录pressed的位置 if (prepressed) { setPressed(true, x, y); } //mHasPerformedLongPress是一个用于记录是否出现了longPress的标志位 //View的在ACTION_DOWN持续了一段时间后，就会把这个标志位设置为true //这种情况，从第一个ACTION_DOWN至ACTION_UP是不会被判断为tap事件的 // if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // //移除掉LongPress的CallBack //因为ACTION_UP就已经表示这个事件序列已经结束了 removeLongPressCallback(); //这里做一下解释： //view的点击事件和获取焦点(这个行为)是互斥的 //也就是说一个View能够获取焦点的话，那么它将优先获取焦点 //而不会触发点击事件，在上面的判断逻辑中，如果view能够 //获取焦点的话，就会调用requestFocus方法，并且把结果返回给 //focusTaken，获取成功了的话，下面的代码块就不会被执行。 // //不过这里需要留意，如果一个View已经获取了焦点的话， //focusTaken的返回结果是false，这里参考上面的判断逻辑 // //如果还是不能理解的话，可以结合一下editText设置了onClickListener //之后的行为，会发现点击第一次的时候是不会出发onClick的 if (!focusTaken) { // //mPerformClick是一个Runnable的的实现 //内部封装了mListenerInfo的onClick的方法 if (mPerformClick == null) { mPerformClick = new PerformClick(); } //通过handler将onClick方法丢到消息队列中执行 //如果post(就是将mPerformClick往小修队列丢)失败的话 //那么就立即执行performClickInternal方法 //OnClickListener的onClick方法是在 //performClickInternalf方法里面被调用的 if (!post(mPerformClick)) { performClickInternal(); } } } //在事件是ACTION_UP但是判定标志是prepress的状态的时候 //会将unSetPressState这个接口的实现丢到消息队列 //内部封装了setPress(false)方法，并且会把这个setPress(false) //通过dispatchSetPressed方法传递下去 if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } // //注意，这里的实际作用就是重置press的状态 //前面我们可以看到，View的press状态会在 //ACTION_DOWN的时候重新设置，所以在ACTION_UP //的时候需要将前面事件序列的press清理掉 // //补充一下这里为什么要对prepress进行一个判断 //考虑到用户有可能在115ms之内出现ACTION_UP //而通过下面的代码我们可以看到对于prepress的状态 //会115ms之后延迟执行setPress(true) //所以显然这里设置press为false的时候也需要115ms执行 if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; //这里留意一下press标志位和prepress标志位 // //(1)、当一个View是不在可滚动的容器中的话 //那么从用户的ACTION_DOWN一直到用户ACTION_UP //的整个事件序列中,pressed一直是true // //(2)、当一个View在一个滚动的容器中的话 //那么会在前115ms设置此View为prepress状态 //115ms之后才会被设置为pressed case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } //在ACTION_DOWN的时候把已经长按的标识重置了 //注意：这个表示是提供给onClick参考的 mHasPerformedLongPress = false; //如果是不是Clickable调用一次checkForLongClick //在内部检测是否是TOOLTIP的情况 //因为TOOLTIP本质上也是一种长按 //但是为了和View本身的长按不冲突 //所以被设置为了一种单独的情况进行考虑 if (!clickable) { checkForLongClick(0, x, y); break; } //这个一般情况下都是返回false, 所以我们不管它 //因为这个好像是用来处理鼠标的右键点击的 if (performButtonActionOnTouchDown(event)) { break; } //遍历View层级，判断是否是在一个能够滚动的容器中 boolean isInScrollingContainer = isInScrollingContainer(); //如果上面的标志返回是true的话， //下面的代码块会让View延迟处理长按的检测 //也就是说会在115ms之后才检测用户是否处于长按状态 //并且把现在的事件状态设置成prepressed if (isInScrollingContainer) { // //立即设置状态为prepress mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); // //可以看到，这里往消息对立里面丢了一个CheckForTap的Runnable //作用是在115ms后调用setPressed(true)再检测是否是长按 postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { //否则，直接设置Pressed, 并且检测长按 setPressed(true, x, y); checkForLongClick(0, x, y); } break; //ACTION_CANCEL比较好理解，就是parent拦截了 //传递下来的ACTION,同时向此View传递一个ACTION_CANCLE // //可以看到ACTION_CANCEL的判断逻辑里面 //主要是做一些资源的清理和标志的移除 //这里就不做过多的赘述了。 case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: // // 再一次看到了drawableHotspotChanged这个方法 // 这个很容易理解，因为View的点击动画的的播放位置 // 应该是在手指离开的位置的，而对于手指移动的场景 // ACTION_UP的位置就是最后一次ACTION_MOVE的位置 if (clickable) { drawableHotspotChanged(x, y); } //用于判断我们当前手指的移动有没有移除这个View的范围之外 //如果手指移除了范围之外的话，就将部分的资源清理(状态重置) //并且重新设置press为false if (!pointInView(x, y, mTouchSlop)) { removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; } break; } return true; } //默认是返回False的 return false;}","link":"/2019/09/16/ViewEvent/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Review","slug":"Review","link":"/tags/Review/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"SourceCode","slug":"SourceCode","link":"/tags/SourceCode/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"开发艺术探索","slug":"读书笔记/开发艺术探索","link":"/categories/读书笔记/开发艺术探索/"},{"name":"EffectiveJava","slug":"读书笔记/EffectiveJava","link":"/categories/读书笔记/EffectiveJava/"},{"name":"源码阅读","slug":"源码阅读","link":"/categories/源码阅读/"}]}