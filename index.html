<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Pigrange&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta property="og:type" content="website">
<meta property="og:title" content="Pigrange&#39;s Blog">
<meta property="og:url" content="https://pigrange.github.io/index.html">
<meta property="og:site_name" content="Pigrange&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://pigrange.github.io/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pigrange&#39;s Blog">
<meta name="twitter:image" content="https://pigrange.github.io/images/og_image.png">







<link rel="icon" href="/assets/img/logo.jpg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/assets/img/logo.jpg" alt="Pigrange&#39;s Blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item is-active" href="/">主页</a>
                
                <a class="navbar-item" href="/categories">分类</a>
                
                <a class="navbar-item" href="/archives">归档</a>
                
                <a class="navbar-item" href="/tags">标签</a>
                
                <a class="navbar-item" href="/about">关于我</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/29/线程和线程池/">线程和线程池<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-29T11:57:37.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-29</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-29T12:00:47.828Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-29</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 分钟 读完 (大约 1633 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p>对Android开发艺术探索线程和线程池章节内容的一些总结。</p>
<p>&lt;!-- more --&gt;</p>
<h3><strong>概述:</strong></h3>
<h4><strong>线程和进程：</strong></h4>
<ul>
<li>线程是CPU的最小执行单元，而进程是操作系统调度的最小单元。</li>
<li>线程本身是没有内存的概念，线程的建立和执行需要依托于进程提供的内存。</li>
<li>进程和进程之间是完全内存独立的，同一个进程中的线程共享进程提供的资源。</li>
</ul>
<h3><strong>主线程和子线程：</strong></h3>
<p>主线程：进程创建的时候会启动一个线程进行执行任务，这个线程就是主线程。</p>
<p>子线程：除了主线程外额外再创建的线程，用于执行一些耗时的任务，增强并发性以提升系统的响应速度。</p>
<h3><strong>Android中的线程：</strong></h3>
<h4>AsyncTask：</h4>
<ul>
<li>轻量级的异步任务类，不适合做特别耗时的后台任务。</li>
<li>内部是使用线程池和Handler进行封装的。</li>
<li>使用的时候需要继承AsyncTask类来手动实现任务处理的逻辑。</li>
<li>默认的构造方法回调线程是主线程，用户也可以指定其他的线程为回调线程。</li>
</ul>
<p>API如下：</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//在线程池中执行，用于执行异步任务。</span></span><br><span class="line"><span class="hljs-comment">//返回的结果会传递给onPostExecute方法</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-comment">//注意：这个方法可以接受可变长度的参数，并且会</span></span><br><span class="line"><span class="hljs-comment">//将这些参数分派成多个任务串行执行</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Value <span class="hljs-title">doInBackground</span><span class="hljs-params">(params...)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//如果用户在执行任务的时候需要不断的更新状态</span></span><br><span class="line"><span class="hljs-comment">//用户通过调用pushlishProgress将数据传给回调线程</span></span><br><span class="line"><span class="hljs-comment">//回调线程会调用这个方法处理更新状态的数据</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressUpdate</span><span class="hljs-params">(values)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>.onProgressUpdate(values);</span><br><span class="line">    <span class="hljs-comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//在回调线程中执行，处理doInBackground执行的结果</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostExecute</span><span class="hljs-params">(values)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>.onPostExecute(values);</span><br><span class="line">    <span class="hljs-comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AsyncTask的三个泛型参数：</p>
<ul>
<li>Params : 输入给Synctask执行的参数，比如网络请求中的URL</li>
<li>Progress : 实时反馈的数据，如果做进度条的话，那么用 int  或者 float 就行了</li>
<li>Result : 网络返回的数据，比如网络请求的话，就是Response</li>
</ul>
<h4>HandlerThread:</h4>
<p>Android提供的一种Thread的派生类，内部实现封装了MessageQueue和Looper。</p>
<h4>IntentService:</h4>
<p>一种特殊的Service , 继承了Service并且内部封装了Handler和HandlerThread，也就是说相较于Service，IntentService可以很方便的执行一些耗时的任务。</p>
<ul>
<li>第一次启动的时候，其onCreate方法会被调用(主线程中调用)，此时会初始化HandlerThread。</li>
<li>其他组件传递过来的Intent最终会调用onStartCommand方法(非HandlerThread运行)，而onStartCommand会调用其持有的Handler的sendMessage方法，其内部的Looper接受到消息后会回调IntentService内部的onHandleIntent方法</li>
<li>onHandleIntent被调用的时候，此方法是运行在HandlerThread上的，从而实现了IntentService耗时任务的执行。</li>
</ul>
<p><strong>停止IntentService</strong>: 调用stopSelf方法。此方法会直接导致IntentService的销毁，并且此后会回调IntentService的onDestory方法，此方法会调用Looper.quit方法，结束当前HandlerThread的执行。</p>
<h3>线程池：</h3>
<p>线程池的优势：</p>
<ul>
<li>线程的复用，避免了线程在频繁创建和销毁所带来的性能的开销</li>
<li>有效控制线程的最大并发数量，从而有效控制系统的并发性能</li>
<li>方便对线程的管理</li>
</ul>
<h4>ThreadPoolExecutor</h4>
<p>构造方法如下：</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>corePoolSize：线程池中核心线程的数量，默认情况下核心线程会一直存活以等待新的任务的到来。</li>
<li>maximumPoolSize：线程池中能容纳的最大线程的数量，当线程的数量达到这个值后，后续的任务会被阻塞。</li>
<li>keepAliveTime：非核心线程闲时的超时时长，超过这个时长，非核心线程就会被回收。
<ul>
<li>当线程池的allowCoreThreadTimeOut属性为true的时候，超时机制对核心线程有效。</li>
</ul>
</li>
<li>Unit ：keepAliveTime的单位。从TimeUnit中指定</li>
<li>workQueue：线程池中的任务队列。</li>
</ul>
<p>线程池的执行过程：</p>
<ul>
<li>当线程池中的线程数量未达到核心线程的数量的时候，那么当任务到来的时候，线程池会直接启动一个核心线程来执行任务。</li>
<li>当线程池中线程的数量到达核心线程数量或超过核心线程的数量的时候，任务会被插入到线程池中的任务队列中排队等待</li>
<li>如果任务队列已满，并且当前线程数量未达到线程数量的最大值，那么线程池会立即启动一个非核心线程来执行任务</li>
<li>如果达到了最大值的话，线程池就会拒绝这个任务，这个时候可以通过线程池的RejectedExecutionHandler来通知调用者。</li>
</ul>
<p>Async中线程池的配置规则：</p>
<ul>
<li>核心线程数为CPU数+1</li>
<li>线程池的最大线程数为CPU核心数 * 2 + 1</li>
<li>核心线程不存在超时机制，非核心线程的超时为1秒</li>
<li>任务队列的容量为128</li>
</ul>
<h4>Android中提供的基本线程池：</h4>
<p><strong>FixedThreadPool：</strong></p>
<ul>
<li>只有核心线程，并且核心线程不会被回收(除非此线程池被关闭了)</li>
<li>不存在工作线程，故也没有超时机制</li>
<li>任务队列的大小没有限制</li>
</ul>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> threadCount = <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-keyword">val</span> fixedThreadPool = Executors.newFixedThreadPool(threadCount)</span><br></pre></td></tr></table></figure></p>
<p><strong>CachedThreadPool：</strong></p>
<ul>
<li>只有非核心线程，没有核心线程</li>
<li>非核心线程的最大数量为Integer.MAX_VALUE</li>
<li>空闲线程的超时时间为60秒，超时后线程被回收</li>
<li>所有的任务被提交后会被立即执行</li>
</ul>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> cachedThreadPool = Executors.newCachedThreadPool()</span><br></pre></td></tr></table></figure></p>
<p><strong>ScheduledThreadPool：</strong></p>
<ul>
<li>核心线程的数量是固定的</li>
<li>非核心线程的数量没有限制</li>
<li>当非核心线程闲置的时候会被立即回收，没有超时机制</li>
<li>主要用于执行定时任务和具有固定周期的重复任务</li>
</ul>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> scheduledThreadPool = Executors.newCachedThreadPool()</span><br></pre></td></tr></table></figure></p>
<p><strong>SingleThreadExecutor：</strong></p>
<ul>
<li>内部只有一个核心线程</li>
<li>所有的任务在线程中顺序执行</li>
<li>单线程执行，任务之间不需要处理线程的同步问题</li>
</ul>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> singleThreadPool = Executors.newSingleThreadExecutor()</span><br></pre></td></tr></table></figure></p>

        </div>
        
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/29/Android消息机制/">Android消息机制<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-29T07:27:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-29</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-29T07:33:20.098Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-29</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 分钟 读完 (大约 3194 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p>之前沉迷源码无法自拔，这个系列咕咕咕了好久了，其实开发艺术探索这方面没有看的很详细，因为之前看过Handler相关的源码的，对消息机制自认为还算比较熟悉，所以就没有特别的按照书中的内容讲，而是结合了自己的一下想法分析了一波。</p>
<p>&lt;!-- more --&gt;</p>
<h3>Android消息机制：</h3>
<p>Android的消息机制：Handler的运行机制。</p>
<ul>
<li><strong>本质</strong>：MessageQueue和Looper协作运行的机制。</li>
</ul>
<p><strong>成员：</strong></p>
<ul>
<li>Hanlder: 消息机制的上层接口，用于在开发过程中很方便的进行线程之间的切换。
<ul>
<li>注意：更新UI仅仅是Handler的一个使用场景，这并不代表Handler就是用来更新UI的。</li>
</ul>
</li>
<li>MessageQueue : 由Message组成的单链表数据结构，本质是一种阻塞队列。</li>
<li>Looper :  消息事件的直接消费者。(因为实际上获取Meesage的是Looper，然后再由Looer分发给指定的Handler)</li>
<li>ThreadLoacl：对Thread的ThreadMaps的一层封装，让不同的线程能够通过很方便的方式存放不同的数据。</li>
</ul>
<p><strong>补充</strong></p>
<ul>
<li>Looper和MessageQueue两者构成了一个最基本的生产者消费者模型。</li>
<li>Handler 在整个消息机制中并不是核心，核心是有Looper和MeesageQueue构成的生产者消费者模型，给运行在主线程上的程序提供了事件驱动的基础。但是由于运行在主线程上的woker有很多种类别，所以Looper并不会真正的消耗事件，而是接收事件后统一分发给不同worker对应的Handler。
<ul>
<li>Looper是事件的直接消费者，它对事件的消费本质上是对事件的分发</li>
<li>Handler是各个worker程序的代理，是事件的真正消费者</li>
<li>Handler也可以不和运行的worker程序绑定，这种情况下，它只会用于线程切换。</li>
</ul>
</li>
</ul>
<p><strong>强调：</strong></p>
<p>这里谈一个概念问题，我觉得这个很有必要要说清楚，因为在深入理解的时候，容易死磕一些思想从而把最基本的原则忘记了。<strong>消息机制的设计目的：<strong>本质就是一种跨线程执行任务的解决方案。如果我们只看Looper和MessageQueue的话，那么它的设计就是一个典型的生产者消费者模型，但是有一个问题，就是我们对</strong>消费</strong>这个词的理解。因为Looper是这个模型的消费者，而这个场景又很特殊，因为Handler的引入导致Looper的作用被模糊化了，所以我们很难清晰的定义整个消息机制中各个组件的职能，想必这也是为什么大多数将消息机制的文章都不会提及生产者消费者这个模型。所以这里我描述Looper为事件的直接消费者，而Handler和其对应的组件才是真正事件的处理者，如果还是对Looper感觉模棱两可的话，那就记住一点，Looper对事件的接收是导致任务在线程中切换的直接原因。Looper消费了这个事件，那么任务就成功实现了线程间切换，而实现了线程的切换，也就是实现了任务的跨线程执行。</p>
<p>虽然这个观点实际上是有误的(因为本质上线程切换是共享内存实现的)，但是这样能让我们很好的理解Android的消息处理机制。</p>
<h3>Android的消息机制概述：</h3>
<p>Handler的直接作用(对于开发者) ：将一个任务切换到指定的线程中去执行。注意：这个能力是Looper提供的。</p>
<p>非主线程更新UI的问题：ViewRootImpl在requestLayout方法中会首先检查当前的线程是否是UI线程。如果不是UI线程的话，直接就抛异常了。</p>
<p>**注意：**UI线程在大多数情况下是等于主线程的，但是这个也不是绝对的，查看ViewRootImpl的实现我们可以看到ViewRootImpl所指向的mThread实际上是ViewRootImpl被创建的时运行的线程。亲测在UI线程中new 出来的View并通过WindowManager.addView实现的View是可以完全在子线程中正常运行的。</p>
<p>Android中Handler的主要作用：解决子线程中无法更新UI的问题。</p>
<p>单线程控制UI的原因：UI的改变操作不是原子性的，多线程并发控制UI容易出现同步问题。如果加锁解决的话，性能甚至不一定有单线程好，因为反而会有线程阻塞来降低效率。（这也是生产者模式相对于等待通知机制的一种优势，因为通过引入缓存机制，协调了生产者消费者之间任务速度不平衡的问题）</p>
<h4><strong>Handler的创建方式</strong>：</h4>
<p>先归纳一下，三种方式，两个作用。</p>
<h5><strong>切换线程：</strong></h5>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//绑定当前创建线程的Looper</span></span><br><span class="line"><span class="hljs-keyword">val</span> handler = Handler()</span><br><span class="line"><span class="hljs-comment">//或</span></span><br><span class="line"><span class="hljs-comment">//绑定指定的looper</span></span><br><span class="line"><span class="hljs-keyword">val</span> handler = Handler(looper)</span><br></pre></td></tr></table></figure></p>
<p>Handler和持有Handler的对象之间的耦合度是比较低的，因为Handler并不会持有外部对象的引用。这种情况下一般是通过Handler的post Runnable来实现切换线程运行方法实现的。</p>
<p>**补充：**这种情况是不会因为消息机制的原因导致内存泄漏的。因为和Activity(这里就用Activity做例子，下面一样)相关操作的代码一定是写在Activity里面的，那么我们就可以不必担心Activity的在销毁后还存在引用没有被GC的情况。所以这种方法的主要作用就是用来切换线程。</p>
<h5><strong>代理Activity接受异步的消息:</strong></h5>
<p>首先我们分析一下Hanlder的运行过程。前面说了，Looper的其实只会分发这个消息，并不会处理这个消息。那么消息由谁处理呢？没错就是那些运行在此线程中的工作对象(在Android通常是四大组件)，但是Looper并不知道这个消息的接受者是哪个工作对象，因为这个Message是Activity里的Hander发送的，所以Looper只会把这个消息返回给Handler，让Handler来决定如何处理这个事情。这里有两种情况：</p>
<ul>
<li>如果Hanlder从Message那里拿到的消息是一个Runnable，那么就是上面描述的切换线程。Handler直接执行这个Runnable ，并且之后的事情，就和他没有关系了。这种情况由于Handler并不持有Activity的引用。所以Handler和Activity解耦的。</li>
<li>如果Handler拿到的是消息，那么它就必须作为消息的传递者来通知Activity。那么这种情况下Handler一定是直接或间接的持有Activity的引用的。那么如何通知呢？很简单，直接访问Activity的数据或执行方法或者通过Activity传递过来的回调接口间接的访问Activity的数据或执行方法，但是它们本质是一样的，实现如下：</li>
</ul>
<p>实现1：</p>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> callback = <span class="hljs-keyword">object</span> : Handler.Callback &#123;</span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;</span><br><span class="line">        doSomeThing()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">val</span> handler = Handler(callback)</span><br></pre></td></tr></table></figure></p>
<p>实现2：</p>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> handler = <span class="hljs-keyword">object</span> : Handler() &#123;</span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>?)</span></span> &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>内存泄漏：</h4>
<p>**注意：**上面两种实现都有内存泄漏的风险。因为这里的Handler代理了Activity接受了消息，而它又直接或间接的持有Activity的引用，代理的方式使得Handler会被传递到其他执行耗时任务的对象里去，而这些对象正在别的线程里面执行耗时任务，那么如果这个时候Activity被终止了的话，由于Handler只持有Activity引用的关系，Activity不会被正常GC.</p>
<h3>Handler消息机制分析：</h3>
<h4>ThreadLoacl:</h4>
<p>线程内部的数据存储类，可以实现在不同的线程里面存储不同的信息。消息机制种主要用于存放Looper，**注意：**一个线程可以存放多个ThreadLocal，但是一个ThreadLoacl只能存放一个数据。</p>
<h5><strong>ThreadLocal的使用方式：</strong></h5>
<p>创建：</p>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> threadLocal = ThreadLocal&lt;Data&gt;()</span><br></pre></td></tr></table></figure></p>
<p>存数据：</p>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">data</span>)</span><br></pre></td></tr></table></figure></p>
<p>取数据：</p>
<p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.<span class="hljs-keyword">get</span>()</span><br></pre></td></tr></table></figure></p>
<h5>ThreadLoacl原理分析：</h5>
<p>不具体讲，康康get和set的实现就行了。</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//获取元素</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="hljs-keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//存放元素</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)</span><br><span class="line">        map.set(<span class="hljs-keyword">this</span>, value);</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadLocal实际上是面向用户的一层接口，和消息机制中Handler的地位相似，实际上数据是通过线程对象里面存放的名为ThreadLoaclMap的map进行存放的。所以保证不同线程不同数据的本质原因还是因为<code>Thread.currentThread()</code>在不同的线程调用下返回的结果是不相同的。</p>
<h3>消息队列的工作原理：</h3>
<p>前面我也说了消息队列本质就是一个生产者消费者模式，所以这里我并不打算从源码的角度分析Looper的具体实现和MessageQueue如何构成的阻塞队列，这里我用一个简单的例子跟随源码康康大致的运行流程，然后再强调几点需要注意的地方就行了。</p>
<h4>工作原理：</h4>
<h5>Handler 发送消息的过程：</h5>
<p>Handler#post</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">post</span><span class="hljs-params">(Runnable r)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getPostMessage方法主要是将传递进来的runnable封装成一个Message</p>
<p>Handler#getPostMessage</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">getPostMessage</span><span class="hljs-params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="hljs-keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Handler#sendMessageDelay</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageDelayed</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Handler#sendMessageAtTime</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageAtTime</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="hljs-keyword">if</span> (queue == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="hljs-keyword">this</span> + <span class="hljs-string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="hljs-string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Handler#enqueueMessage</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(MessageQueue queue, Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="hljs-keyword">this</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="hljs-keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//在这里讲消息放入消息队列</span></span><br><span class="line">    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5>Looper 获取消息的过程</h5>
<p>looper#loop</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="hljs-keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="hljs-comment">//...删掉一些代码</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> slowDeliveryDetected = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (; ; ) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="hljs-comment">// might block</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//这个target就是Handler</span></span><br><span class="line">            <span class="hljs-comment">//这里就实现了Looper将消息分发给Handler</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//...删掉一些代码</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，Looper.loop其实就是让Looper作为消费者去拿MessageQueue里面的message。通过queque.next()获取消息，注意<code>queue.next</code>方法会阻塞线程，并且一般情况下一定不会返回空。如果消息为空，那么looper直接返回，这个线程也就是失去了控制，直接运行到结束。</p>
<p><strong>补充一下:</strong> queue.next返回null是让Looper结束死循环的唯一方式。而结束Looper面向开发者的API是Looer的quit方法，一旦quit方法被调用，MessageQueue的quit方法会被执行，从而清空自己的所有消息，使得next返null。(Looper的quit方法应该只能通过别的线程调用吧)。</p>
<p>Handler#dispatchMessage</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//这里的message.callback就是传递进来的runable</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">//对应Handler的构造方法里面直接传CallBack的实现</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//对应Handler直接重写HandlerMessage的实现</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>补充：</h4>
<h5>MessageQueue如何阻塞：</h5>
<p>主要是两个native方法，我就简单描述一下，具体咋实现的我们不深究。</p>
<p>MessageQueue#next</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//这个方法会通过ptr的值和nextPollTimeoutMillis</span></span><br><span class="line">        <span class="hljs-comment">//的值来判断是否阻塞当前线程</span></span><br><span class="line">        <span class="hljs-comment">//我们可以把它当作待条件的wait方法</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="hljs-comment">//...省略其他的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MessageQueue#enqueueMessage</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//...这里省略掉将消息入队列的代码</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (needWake) &#123;</span><br><span class="line">            <span class="hljs-comment">//这个方法用于唤醒Ptr指向的线程</span></span><br><span class="line">            <span class="hljs-comment">//我们可以把它当作条件motify方法</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        </div>
        
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/28/从多线程到Handler/">从多线程到Handler<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-28T05:49:34.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-28</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-29T12:08:40.708Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-29</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/日常/">日常</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/日常/胡思乱想/">胡思乱想</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    26 分钟 读完 (大约 3890 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p>夜话，胡思乱想系列，未完待续。。。</p>
<p><em>我不管你看不看得懂，反正我也不知道自己当时是怎么想的。—— john pig</em></p>
<p>这篇文章我会分享自己对于多线程并发的一些理解，段落之间的联系可能不会很大，随便看就是了。另外就是这种存粹的想法真的非常难写哇。先补源码去了，开个坑，有时间就补一点。</p>
<p>&lt;!-- more --&gt;</p>
<h4>前言：</h4>
<p>本来正在筹备一篇关于Android Handler机制的的文章，但是对于Handler机制的设计原则，真的是越想越绕。</p>
<p>从最初的内存泄漏问题，想到了Hanlder的使用场景和HandlerThread的使用的必要性，再到Hander在非主线程使用的可行性的分析，再到结合生产者消费者模型，类比分析这两者的异同，以及各个组件的职责。结果发现，网上大多数的文章看的我一脸懵逼，很多将生产者消费者模型的文章都是对这种设计思想轻描淡写，然后奉上一堆示例代码。</p>
<p>所以本人打算撰写此文，以加深个人的这(类)设计思想的理解。</p>
<p>**注：**学术才浅，以下内容仅代表个人观点，所有有关与本文分析得出的结论仅供参考。如有不同观点，欢迎与我联系共同探讨。</p>
<h4>多线程和并发：</h4>
<p>首先我们来探讨一下为什么会有多线程的概念。注意，这里并不仅仅局限于JAVA，另外也强调一下，我们暂时忽略进程和线程的关系，单从应用代码的执行和CPU的关系进行相关的分析，并且假设我们现在的CPU只有一个核心。</p>
<p>多线程的主要作用的用于增加CPU的执行效率，但是这个执行效率的增加只能是通过缓解单线程下CPU傻乎乎的等待耗时I/O操作所实现的。而对于存粹的计算性的任务(TASK)来说，多线程是几乎没有优势的，或者说由于CPU切换上下文，线程的切换在某些时候反而会降低CPU的执行时间。</p>
<p>多线程在非IO的场景下也并不是没有好处，比如它可以减少多任务情况下其他任务的等待时间来提升应用的响应速度。因为CPU线程的不停切换，虽然整体拖慢了CPU的执行时间，但是对于一个排着队等待执行的任务序列来说，CPU的不断轮切换线程，使得这些等待的任务很快就能被CPU所执行，但是只有一小会儿。对于用户来说，宏观的体验就是这个应用它很快就响应了，但是它速度很慢。同样对于系统的使用者来说，他也会觉得这些任务是同时在运行的，我们就说这些任务是并发执行的。</p>
<p>所以实际上并发只是宏观上的并行，而在逻辑上仍然是串行的。</p>
<h4>线程间的通信：</h4>
<p>再看康康什么是通信：通信很好理解，就是传递信息，共享信息。那么线程间通信呢？也很好理解，就是在线程之间共享信息，传递信息。那么是谁传递信息呢？在线程中运行的代码块传递信息。</p>
<p>网上有不少文章实际上是有误导性的，因为它们描述线程间通信的方式的时候往往会变成描述线程通信的具体手段，但是这种手段是面向开发者的，是编程语言对开发者提供的一种实现方式，本身和线程间的通信并没有太多的什么关系。</p>
<p>这里我们暂时不考虑JMM的内存模型，假设所有的线程没有所谓的工作内存的概念，所有对数据的写入是直接发生在主存上面的。在这种条件下，我们就可以不去考虑volatile关键字的语义了，因为所有的变量都满足可见性。</p>
<p>那么在这种条件下，线程通信的方式就只有两种：</p>
<ul>
<li><strong>被动式：共享内存</strong></li>
<li><strong>主动式：写入数据</strong></li>
</ul>
<p>这里我不打算讲主动式，因为具体我也不是特别了解，不过可以提一点是它是通过管道以流的方式实现的。所以这里我们就谈共享内存的线程通信。</p>
<p><strong>为什么需要线程间进行通信：</strong></p>
<p>因为在许多场景下，我们为了提升系统的执行效率引入了多线程，但是多线程线程之间的任务并不是完全独立的，比如A线程用于线程，B线程用于网络请求，那么显然B线程很有可能是对A线程处理完成的数据是具有依赖的(因为可能会用来进行显示或者数值运算后显示)。然而，从CPU的执行来看，两个线程的执行是完全独立的，我们无法做到从线程或CPU的实现层面上让运行在两个不同线程上面的程序直接进行数据交互，于是便有了内存共享数据。</p>
<p><strong>内存共享数据：</strong></p>
<p>由于线程是进程中的执行单元，所以它们在执行时对数据或者对象的访问最终得到的内存地址是一样的，也就是说它们运行的时候内存是共享的。而这就成了线程间进行通信的前提，线程A中的Alice希望给线程B中的Bob发一个消息，很简单。Alice把消息放在某个内存里面，Bob在执行的时候，去看就行了。</p>
<p>是不是很熟悉？没错，在我们开发的时候，其实很多时候就无形的在使用线程间通信，或者说，我们在多线程的环境下，对某一个数据进行了修改，其实就已经进行了线程通信了，因为这个线程对数据的操控的结果已经对其他线程可见了，也就是说其他的线程已经收到发送信息线程所传达的信息了。</p>
<p><strong>原子性的线程通信与同步：</strong></p>
<p>线程间的同步策略，实际上是依赖于一些原子性的数据修改完成的，而数据修改本质就是线程通信，那么也就是说原子性的线程间通信为线程间的同步提供了实现上的可行性。这里我不打算讲原子性的具体语义，我们只需要记住原子操作是一旦发生就会执行完的，这个过程中是不会被其它的任务中断的。</p>
<p>比如说synchronized关键字：线程并不是真正持有锁的，而是线程通过原子操作的CAS将synchronized修饰的对象的对象头里面的锁的信息修改了。当其他的线程尝试去获取锁(修改数据)的时候，发现锁的信息已经被修改了，那么就是有线程持有了锁嘛，所以它才等待，等待持有锁的线程释放锁。</p>
<p>同样Lock的内部实现也是通过原子性的CAS操作去修改AQS里面的status关键字来通知其他线程已有线程持有这个锁，你们排队等待吧。</p>
<p><strong>同步与线程通信：</strong></p>
<p>JAVA里面实现同步的方式非常多，synchronized , Lock , wait/notify .....</p>
<p>那么同步到底是解决的是什么问题呢：并发执行的时候多个线程对数据修改导致的数据冲突的问题。举个例子，对于一个初始值i = 0, 线程A中的Alice , B中的Bob同时执行了i++ , 那么 i 的值是多少？这个显然是不确定的，因为i++不是原子性的，它实际上为三步：</p>
<ul>
<li>CPU读取 i 的值</li>
<li>CPU计算 i 的值</li>
<li>CPU写入 i 的值</li>
</ul>
<p>如果上述操作运气好的话，就是2。运气不好，在线程A计算 i 完成后，时间片不够，切换了线程，轮到线程B执行，那么在这种情况下得到的结果就是1。</p>
<p>回到之前提到的观点：多线程情况下对公共数据的修改其实就是在进行线程通信。也就是说，同步解决的问题，实际上就是多线程通信中数据冲突的问题。注意，这里的多线程通信一定不是原子性的，这个道理很简单，如果所有的通信都是原子性的，那么就不会存在数据冲突了，因为虽然宏观上线程是并发执行的，但是对于数据的修改本质还是串行执行的，而原子性又保证了线程在持有时间片的那段时间内，一定会将共享变量修改成它(这个修改数据的线程)想要的结果，换句话说，就是这个线程一定可以发出正确的消息。</p>
<p>那么回到这里的话题：同步策略解决了多线程的通信数据冲突的问题，同步策略的实现依赖于原子性的多线程通信。也就是说多线程通信数据冲突的解决本质上依赖于多线程中原子性的数据通信。</p>
<h4>线程的可控性和阻塞队列：</h4>
<p>了解过JAVA Thread类的同学都知道，线程类的构造方法接受一个Runnable接口(或者重新run方法)，通过调用线程的start让其执行，但是这个线程的执行是不可控的。可能有人就会反驳了，这明明是可控的呀，比如我可以通过Object.wait()让其阻塞，或者通过Thread.sleep让其睡眠。但是注意，这种情况下这个线程即便是又被唤醒了它也会继续执行它Runable中的代码。也就是说，线程在被初始化的那一刻，它的执行行为就被确定了，而在这种场景下，线程是昙花一现的。</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建一个线程执行简单任务的示例</span></span><br><span class="line">Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>为了不让线程执行结束，我们肯定需要寻找一些其他的解决方案，而最简单的方法，就是实现一个死循环。实习如下：</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">   		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;</span><br><span class="line">        	doSomething();            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，我们成功的拦截了线程，防止其执行到结束，并且从一开始，一直到进程结束，这个线程都会一直运行，也就是说，通过死循环这种方法，我们成功的捕获住了线程。但是这肯定不够，因为我们虽然捕获了线程，但是并不能让他运行别的任务，但是这也很简单，因为这个时候线程已经局部可控了，实现如下。</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Runnable&gt; mTasks = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;</span><br><span class="line">		<span class="hljs-keyword">if</span> (mTasks.isEmpty()) <span class="hljs-keyword">continue</span>;   </span><br><span class="line">		Runnable task = mTasks.remove();</span><br><span class="line">		task.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样我们的线程就完全被我们捕获并控制了，线程不断轮询mTask中的Runnable对象，如果有就取出来执行，如果没有的话，就continue，（注意，上述代码是纯在线程安全的，别学我这样写）。</p>
<p>但是这种实现还是又一个很大的问题，就是写死循环太吃CPU了，我们做了很多的没有必要的性能消耗，于是对于哪些并没有任务的操作，我们可以引入等待通知机制，来降低CPU没有意义的死循环。</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Runnable&gt; mTasks = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();</span><br><span class="line">Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">            Runnable task = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                task = mTasks.poll();</span><br><span class="line">                <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="hljs-keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            mTasks.add(r);</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这种情况我们就基本实现了对线程的捕获以及控制，不过好在JAVA给我们提供了阻塞队列BlockingQueue这一数据结构，上面的代码我们可以实现得更加清爽。</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;Runnable&gt; mTasks = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">            Runnable task;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                task = mTasks.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            mTasks.put(r);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>好了，经过上面的代码我们就成功的弄出来了一个可控制的线程了，那么回到我们的标题。线程的可控性与阻塞队列总是有密不可分的关系，我们甚至可以断言，线程的可控性就需要通过阻塞队列来实现，但是其实我想说的是，阻塞是一种优化策略，队列是一种缓存机制，捕获线程的根本条件是写在线程里面的死循环，而通过加入队列和等待通知机制实现的阻塞队列手段，是为了优化性能并解决同步问题的一种手段。</p>
<p>另外必须强调的一点，这里一直所说的死循环主要是是用于捕获线程的，不要和阻塞队列里面的死循环搞混了。因为这里是手动实现的阻塞队列，所以我干脆把获取task和执行task写在一起了。我知道稍微有一点经验的同学一定知道，阻塞队列在被唤醒后肯定会重新去拿元素，那么肯定得写在一个循环里面；同理，作为处理任务的线程，也应该需要有一个循环去依次拿去队列中的所有元素。但是其实这两个循环如果写在一起的话，是可以通过continue去掉一层的。我之所以这么写一个是增加位置内容的可读性，使文章便于理解，二是淡化阻塞队列这一整体数据结构的概念，让大家更能了解捕获住线程的核心，而不是去死磕阻塞队列的设计原理。</p>

        </div>
        
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/23/View-process-2/">View工作流程[二]：Measure布局<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-23T06:35:36.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-23</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-24T12:21:56.389Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-24</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/源码阅读/View工作流程/">View工作流程</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 分钟 读完 (大约 2323 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p><em>我不管你看不看得懂，反正这一次我也没有看懂</em> 😭 <em>—— john pig</em></p>
<p>Android太难了。我太南了。</p>
<p>&lt;!-- more --&gt;</p>
<p><code>ViewRootImpl#PerformTraversals()</code>
<code>ViewRootImpl#performLayout(lp, mWidth, mHeight)</code>
<code>DecorView#layout()</code></p>
<p><strong>写在前面：</strong></p>
<p>这真的是到目前看的最累的一次，我，真的是看不下去了(我指的是ViewRootImpt的performLayout方法)，太难了，debug跳过去调过来的，递归看着是真的恼火，所以对那里某一些源码的部分描述我就打算说一个大概了。真的是在这个上面熬了不少的时间，但是我特么真的是看不懂啊，递归过去递归过来我怎么知道递归到那里去了呢？</p>
<p>其他的我也不做过多的描述了，个人觉得这篇文章长度虽然不多，但是内容信息量挺大，建议一遍DEBUG一边看。另外这篇文章的注释已经写的很详细了，就不做过多的文字描述了，后面如果有空的话，会补一个ViewGroup的onLayout方法的解析，今天太累了，就先🕊了。</p>
<h4>performLayout</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewRootImpl#performLayout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performLayout</span><span class="hljs-params">(WindowManager.LayoutParams lp, <span class="hljs-keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                           <span class="hljs-keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这个标识符用于标识此View是否在进行Layout</span></span><br><span class="line">    <span class="hljs-comment">//因为下一步就是进行Layout了，所以这里将其设置为true</span></span><br><span class="line">    mInLayout = <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里的Host就是我们的decorView</span></span><br><span class="line">    <span class="hljs-keyword">final</span> View host = mView;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//调用host的layout方法，即在这里调用DecorView的layout方法</span></span><br><span class="line">    host.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//Lyout完后将其设置为false</span></span><br><span class="line">    mInLayout = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//判断是否有View在进行Layout的过程中调用了RequestLayout方法</span></span><br><span class="line">    <span class="hljs-keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">    <span class="hljs-keyword">if</span> (numViewsRequestingLayout &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//过滤一些已经被解决的child view</span></span><br><span class="line">        ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                                                                         <span class="hljs-keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//将这个标志位置为True，作为requestLayout的一个判断标识</span></span><br><span class="line">            <span class="hljs-comment">//下面我们会调用缓存的View的requestLayout方法</span></span><br><span class="line">            <span class="hljs-comment">//由于之前的ViewTree的整个Layout已经结束了</span></span><br><span class="line">            <span class="hljs-comment">//所以Force_Layout标识已经被置为了0</span></span><br><span class="line">            <span class="hljs-comment">//所以之后View调用requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//条件判断mParent.isLayoutRequested()会返回false</span></span><br><span class="line">            <span class="hljs-comment">//这会导致整个ViewTree向上递归requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//最终调用ViewRootImpl的requestLayout方法</span></span><br><span class="line">            <span class="hljs-comment">//但是ViewRootImpl的requestLayout会导致</span></span><br><span class="line">            <span class="hljs-comment">//其performTraversal的调用，也就是说会导致</span></span><br><span class="line">            <span class="hljs-comment">//PerfromLayout这个方法被递归调用</span></span><br><span class="line">            <span class="hljs-comment">//考虑到性能的问题，有很多逻辑是不需要的</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//所以这个标识的作用就是拦截ViewRootImpl接受layout的请求</span></span><br><span class="line">            <span class="hljs-comment">//通过在performLayout中的某些逻辑来解决。</span></span><br><span class="line">            mHandlingLayoutInLayoutRequest = <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//遍历整个numValidRequests, 对每一个view调用requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//这里的requestLayout的作用是将其父View链的FORCE_LAYOUT标志位</span></span><br><span class="line">            <span class="hljs-comment">//全部设置为1，但是并不会真正的在这里对其layout</span></span><br><span class="line">            <span class="hljs-keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                <span class="hljs-keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                view.requestLayout();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//对ViewTree进行测量，注意，我们之前看过measure的代码知道</span></span><br><span class="line">            <span class="hljs-comment">//这里只有被标志位FORCE_LAYOUT的View才会再次被测量</span></span><br><span class="line">            <span class="hljs-comment">//也就是上面我们request的那个View链</span></span><br><span class="line">            measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                             desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//将Layout标识置为True，标识即将进行Layout</span></span><br><span class="line">            mInLayout = <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//进行ViewTree的再次Layout</span></span><br><span class="line">            <span class="hljs-comment">//这里如果child再次调用了requestLayout的话</span></span><br><span class="line">            <span class="hljs-comment">//处理策略一样，只把当前调用requestLayout的View</span></span><br><span class="line">            <span class="hljs-comment">//加入到mLayoutRequesters中即可，不会影响parent</span></span><br><span class="line">            host.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//将mHandlingLayoutInLayoutRequest置为false</span></span><br><span class="line">            <span class="hljs-comment">//这个时候前面的Layout已经完成了</span></span><br><span class="line">            mHandlingLayoutInLayoutRequest = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//这里的代码是用来解决View出现无尽的递归调用requestLayout的</span></span><br><span class="line">            <span class="hljs-comment">//比如上述layout中child又调用了requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//注释我看的不是很懂，主要是理解不到那个奇怪的 noop'd 是什么意思</span></span><br><span class="line">            <span class="hljs-comment">//不过我们可以猜测，大概就是Android对于这个重复无意义的requestLayout有检测机制</span></span><br><span class="line">            <span class="hljs-comment">//这里就是将这些View送给相关的判断逻辑</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//猜测用runnable queue的原因：</span></span><br><span class="line">            <span class="hljs-comment">//防止performLayout太耗时以至于系统卡顿或者长时间未响应</span></span><br><span class="line">            <span class="hljs-comment">//也算是一种优化策略吧</span></span><br><span class="line">            <span class="hljs-comment">//</span></span><br><span class="line">            <span class="hljs-comment">//这里我有试过直接在View的onLayout里调用requestLayout</span></span><br><span class="line">            <span class="hljs-comment">//最终发现ViewRootImpl的performLayout大概会在调用了3次后</span></span><br><span class="line">            <span class="hljs-comment">//就不会再调用了，可见这种无效的方法系统是有检测机制的</span></span><br><span class="line">            <span class="hljs-comment">//但是由于本人的能力有限，所以不做过多描述</span></span><br><span class="line">            validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="hljs-keyword">true</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                getRunQueue().post(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="hljs-meta">@Override</span></span><br><span class="line">                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                        <span class="hljs-keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                            <span class="hljs-keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                            Log.w(<span class="hljs-string">"View"</span>, <span class="hljs-string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                  <span class="hljs-string">" during second layout pass: posting in next frame"</span>);</span><br><span class="line">                            view.requestLayout();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//最后把mInLayout 置为false</span></span><br><span class="line">mInLayout =<span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>Layout</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//View#layout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT只有在之前的measure方法</span></span><br><span class="line">    <span class="hljs-comment">//直接拿的缓存设置的measuredWidth和measuredHeight的时候才会使用</span></span><br><span class="line">    <span class="hljs-comment">//这里不做过多的描述</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//记录之前的四个顶点</span></span><br><span class="line">    <span class="hljs-keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="hljs-keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="hljs-keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="hljs-keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//根据View是否具有光学边界，调用不同类型的setFrame方法</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//强调：View的四个顶点就是在这里面被确定的</span></span><br><span class="line">    <span class="hljs-comment">//但是这里面设置的此View的四个顶点的位置</span></span><br><span class="line">    <span class="hljs-comment">//对于哪些包含有child的View，可能还需要设置child的位置</span></span><br><span class="line">    <span class="hljs-comment">//而对child四个顶点位置的确定，我们就写在onLayout里面</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//这里返回的值是新的四个顶点是否和之前的四个顶点一样</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">        setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里我们先不管后面的标志</span></span><br><span class="line">    <span class="hljs-comment">//但是可以这么记一下，就是只要View被调用了measure</span></span><br><span class="line">    <span class="hljs-comment">//那么后面的条件就一定成立</span></span><br><span class="line">    <span class="hljs-comment">//而这里的changed主要是用来解决View仅改变了位置的情况</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//View里面什么都没有，但是个人觉得来说其实是比较重要的方法</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//对于自定义ViewGroup来说，这个方法是用于确定其child的位置</span></span><br><span class="line">        <span class="hljs-comment">//唯二实现方法，当然也可以重写layout（难度较大）</span></span><br><span class="line">        <span class="hljs-comment">//这里传入的四个参数是，ViewGroup的最新的四个顶点的位置</span></span><br><span class="line">        <span class="hljs-comment">//和它希望通知child自己是否位置改变的一个标识</span></span><br><span class="line">        <span class="hljs-comment">//~~后面想怎么搞child的位置就是开发者自己的事情了</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//补充：不建议在onLayout方法里面通过手动调用setFrame来让View</span></span><br><span class="line">        <span class="hljs-comment">//基于某一个初始位置有一个偏移量,虽然这样View的位置确实没有问题</span></span><br><span class="line">        <span class="hljs-comment">//但是会导致后面listener监听的位置有误</span></span><br><span class="line">        <span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-comment">//个人觉得比较理想的实现是在View的构造方法里手动加一个margin</span></span><br><span class="line">        <span class="hljs-comment">//这样才能从根本上(从通知parent上)解决问题</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//移除PFLAG_LAYOUT_REQUIRED标识</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//回调一些Listener的onLayoutChange方法</span></span><br><span class="line">        <span class="hljs-comment">//所以这里也可以拿得到View的坐标，宽高等属性</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                (ArrayList&lt;OnLayoutChangeListener&gt;) li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="hljs-keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="hljs-keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//...删掉了大量和View焦点有关的代码</span></span><br><span class="line">    <span class="hljs-comment">//反正我又看不懂，放在那里凑字数吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>再探RequestLayout</h4>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ViewParent#requestLayout</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//首先，前面说过，这个方法在第一次performTraversal的时候一定不会被调用</span></span><br><span class="line">    <span class="hljs-comment">//这里说一下mViewRequestingLayout这个标识符</span></span><br><span class="line">    <span class="hljs-comment">//它用来标识整个ViewTree真正调用requestLayout的那个View</span></span><br><span class="line">    <span class="hljs-comment">//这里是true的话，就说明此次调用requestLayout的是整个</span></span><br><span class="line">    <span class="hljs-comment">//requestLayout事件链的罪魁祸首，需要对它进行一些特殊的处理</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//只要ViewRoot调用了layou方法，而child在layout中又调用了</span></span><br><span class="line">        <span class="hljs-comment">//requestLayout,那么这里的判断就是true，就会调用下面的</span></span><br><span class="line">        <span class="hljs-comment">//viewRoot.requestLayoutDuringLayout(this)方法</span></span><br><span class="line">        <span class="hljs-comment">//而这个方法的就是将这个view加入到mLayoutRequesters中的</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (viewRoot != <span class="hljs-keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="hljs-keyword">this</span>)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//因为上面有可能会return,这段语句和上面本来是没有关联的</span></span><br><span class="line">        <span class="hljs-comment">//但是如果上面return的话，可能会引起错误，所以就放下面</span></span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//将View的PFLAG_FORCE_LAYOUT置为1</span></span><br><span class="line">    <span class="hljs-comment">//将View的PFLAG_INVALIDATED置为1</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//INVALIDATED标识暂时还不清楚，不过猜测和View的重新绘制有关</span></span><br><span class="line">    <span class="hljs-comment">//FORCE_LAYOUT十分重要，它是这个View在后面的重新measure和layout</span></span><br><span class="line">    <span class="hljs-comment">//中是否真的需要被测量的定位的标识</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里的代码块是View递归向上传递requestLayout的关键</span></span><br><span class="line">    <span class="hljs-comment">//而这里的判断语句又是是否使得view向上传递事件的核心</span></span><br><span class="line">    <span class="hljs-comment">//</span></span><br><span class="line">    <span class="hljs-comment">//isLayoutRequested 方法会判断其parent的FORCE_LAYOUT是否是1</span></span><br><span class="line">    <span class="hljs-comment">//如果其PARENT是在进行layout的话，那么FORCE_LAYOUT将会是1</span></span><br><span class="line">    <span class="hljs-comment">//这个标志位会在onLayout之后被重置为0，但是对child的layout是在</span></span><br><span class="line">    <span class="hljs-comment">//onLayout中实现的，所以这个时候FORCE_LAYOUT仍然是1</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//这里很好理解，把罪魁祸首的标识取消了，不做多的解释</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>补一个requetLayout方法的流程图：</p>
<p><img src="https://github.com/pigrange/pigrange.github.io/blob/master/assets/img/view-process-2/requestLayout.png?raw=true" alt></p>

        </div>
        
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
            <a class="has-link-black-ter" href="/2019/09/22/寄夏予你/">寄夏予你<a>
                    
        </a></a></h1>
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-22T11:03:10.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-22</time>
                
                <time class="level-item has-text-grey is-hidden-mobile" datetime="2019-09-29T12:08:33.106Z"><i class="far fa-calendar-check">&nbsp;</i>2019-09-29</time>
                
                
                <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/日常/">日常</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/日常/随笔/">随笔</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    13 分钟 读完 (大约 1954 个字)
                </span>
                
                
            </div>
        </div>
        

        <div class="content">
            <p>这是一篇回忆暑期时间管理的文章，本来打算是用作综合实践课程用的，不过可能用不上了，干脆就收录到这里吧。</p>
<p>&lt;!-- more --&gt;</p>
<h3>TO-DO task is not a shcedule task</h3>
<p><img src="/assets/img/summer/1.jpg?raw=true" alt></p>
<p>你最终因为leetCode某道题卡了太久，导致下午至晚上一直在做，所以你后面的事情都没有做完. 你非常不情愿的给自己打上了11分的低分, 抱怨第一次尝试就没有及格.</p>
<p>你很快发现这个问题是显著又普遍的，因为大多数时间是无法确切的, 所以你难预测道明天会发生的突发事件.于是翻看了知乎,查阅了各种大佬的成功案例 , 发现原来是自己太不自律了, 明明todo-list都著名了不能超时做leetCode但是还是深陷其中不能自拔, 于是你在今天的todoList上把不要超时几个字写的更大,并在睡觉之前把这几个字又默念了几遍.</p>
<p>第二天,前面看书你都非常严格的遵守了, 但是唯一的问题是leetCode还是没有在限定的时间内想出解法 , 于是你非常不情愿的准备切换至下一个任务(尽管现在的问题还未得到解决)，并且尝试在本子上记录下现在自己的思路，保留一波现场.但是这样做并没有任何用.</p>
<p>到了第三天, 你尝试回到昨天的现场解决那个还没被填上的坑. 当你翻回昨天的那一页的时候 , 你朝着作业本上那一堆自己也看不懂的公式摇了摇头, 想了想今天有限的作业时间, 默默的将作业本翻到了下一页.</p>
<p>第四天,你大刀阔斧的开始休整自己的todo-list , 删掉了自己的运动 , 压缩了自己的阅读.再来一个弹性日程安排 , 把各种详细的task划分到一起 , 然后 , 你的todo-list 变成了这样.<img src="/assets/img/summer/2.jpg?raw=true" alt></p>
<p>然后,很快你就发现了新的问题 ,  你发现你和平时做着同样的事情 ,  todo-list并没有给你带来任何作用. 因为对于一个又不玩游戏, 假期闲的要死的你来说, 你的日常就是这样的. 不仅如此, 你也再也无法对今天的任务进行评估和打分,除了吃饭的两分稳稳到手外, 其他都是大大的问号. 于是你开始回忆你昨天做了哪些事情, 然而你发现 , 你似乎确实做了很多事情 , 但是始终有一种空虚感 , 因为说不清楚你到底干了什么...</p>
<p>另外,你开始逐渐意识到,你在一些琐事上面花了非常多的时间:</p>
<p>比如你花了55分钟吃饭，中午花了1个半小时睡觉，但是你睡午觉的大多数时间是用来躺在床上玩手机的, 又比如, 你明明是早上7点就起床了, 本来计划8点抵达图书馆, 但是当你到达图书馆的时候, 你手机上面的时间8 后面 已经四十好几了.</p>
<p>你告诉自己, 我应该严格管理我的时间分配 , 让我的每一段时间都过的有价值.</p>
<p>转眼道到了开学，你把你的todo-list改成了这样 (详细估算各种事情了时间的花费, 计算出了明天大致的空闲时间,并给自己提供了一些时间来解决意外情况 , 同时将你的一天化为了很多时间段 , 并且不对详细的时间段指明确切的任务)</p>
<p><img src="/assets/img/summer/3.jpg?raw=true" alt></p>
<p><em>即使是忙碌的周四,我们也有至少7个半小时的时间用于自有安排</em></p>
<p>忙碌的一天终于结束了, 但是你却丝毫没有一丝惬意 , 你觉得你早上一大早跑去图书馆却在那一小时无所事事, 因为才刚开学, 虽然有课 但是 却没有作业, 于是你在早上那一个小时简单的看了一下go语言的官方文档 , 但是到了晚上你质问自己为什么要去看现在并用不到的东西 , 你便开始后悔 , 为什么我那一个小时不用来记一记单词.</p>
<p>照着这份todo-list 你坚持了几天 感觉每天都过的非常的充实. 但是 , 很快你又发现了新的问题: <strong>效率</strong> , 你恍然大悟 , 你似乎明白了为什么感觉每天做了很多事情却似乎又觉得没有什么收获 , 你似乎也明白了为什么暑假天天做这么多事情却还是每天觉得很空虚.</p>
<p>你从操作系统系统老师那里得知了并发切换CPU状态会消耗资源.你学以致用 , 发现 , 你每天这样频繁的切换自己的任务不就是处于一个高并发的状态吗?</p>
<p>于是你又回想起了你暑假的某一个下午...</p>
<h3>Focus on one thing</h3>
<p>8月的某一天上午 , 你在图书馆 , simply repeat what you did yesterday. 突然接到了家住郫县亲戚的电话. 于是你心想给自己放个假也不错, 就背着电脑驱车前往.</p>
<p>但是亲戚家里实在是太无聊了, 你便拿出了电脑, 继续看 &lt;&lt;java多线程核心技术&gt;&gt;. 很快你看书犯困的老毛病就又犯了, 于是你打算小憩一会.</p>
<p>2个小时过去了...</p>
<p>你睁眼一看 , 已经下午三点了, 我天 , 怎么睡了这么久? 你慌了, 觉得自己虚度了光阴.</p>
<p>于是你非常懊悔, 关掉了手机 , 掏出了ipad , 打开了电脑. 定位到了pdf第53页, 一遍做笔记一边啃.</p>
<p>5个小时过去了...</p>
<p>你离开了亲戚家回到了学校 . 你又打开了电脑, 掏出ipad , 继续啃&lt;&lt;java多线程核心技术&gt;&gt;...</p>
<p>3个小时过去了...</p>
<p>你长舒一口气 , 终于把第三章看完了.</p>
<p>什么! 把第三章都看完了! 你才缓过神来. 你注意了一下书的目录 , 你居然看到了第199页, 你感觉难以置信 , 又看了看你的ipad , 发现你做了31页的笔记!</p>
<h3>Core task and Non-core task</h3>
<p>你回到了现实. 意志坚定, 思考片刻 , 参照java的线程池 , 给自己设计了两个todo-list, 一个core-todo-list , 用于缓存要做长期要做且要做很久任务, 一个non-core-todo-list 用于缓存短期要做且能短时间就昨晚的任务.</p>
<p><img src="/assets/img/summer/4.jpg?raw=true" alt></p>
<p><img src="/assets/img/summer/5.jpg?raw=true" alt></p>
<p>回到现在,屏幕前的你终于在第1777个字处结束了自己的回忆. 你思考了一下,觉得这个文案写的还算可以,打算将他交给你的组长审阅. 但是跳跃的思维又让你想到了昨天, 你为了准备后面实习的面试 , 从昨天早上到深夜11点都在写一篇技术博客.</p>
<p>你感叹那篇仅仅一小时就能读完的7477字的源码分析竟然写了整整一天, 你也感慨自己居然就用了一天就把它写出来了.</p>
<p>你又满意了打开了自己的blog , 对着那篇文章浏览了一遍, 你觉的无比充实 .对于读者, 那7477个字可能显得普通还缺乏文采甚至略微晦涩, 但是对于你来说,  那是无尽的财富, 因为你已不再迷失方向.</p>
<p>-----不愿透露姓名但乐于分享自己经历的吃瓜群众</p>

        </div>
        
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/page/0/">上一页</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/page/2/">下一页</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/2/">2</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/3/">3</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <figure class="image is-128x128 has-mb-6">
                            <img class="is-rounded" src="/assets/img/favicon.jpg" alt="pigrange">
                        </figure>
                    
                    
                    <p class="is-size-4 is-block">
                        pigrange
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        JohnPig
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>ChengDu China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        15
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        9
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        8
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/pigrange" target="_blank">
                关注我</a>
        </div>
        
        
    </div>
</div>
    
        

<div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="http://gityuan.com/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">袁神gityuan</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">gityuan.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://blog.piasy.com/index.html" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Piasy</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">blog.piasy.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.gcssloop.com/#blog" target="_blank">
                    <span class="level-left">
                        <span class="level-item">gcsloop</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.gcssloop.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.androidperformance.com/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">高爷Cracker</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.androidperformance.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://dp2px.com/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">dp2px</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">dp2px.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>


    
        
<div class="card widget is-hidden-mobile">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/tags/JAVA/" style="font-size: 13.33px;">JAVA</a> <a href="/tags/Review/" style="font-size: 16.67px;">Review</a> <a href="/tags/SourceCode/" style="font-size: 13.33px;">SourceCode</a> <a href="/tags/you/" style="font-size: 10px;">you</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/总结归纳/" style="font-size: 10px;">总结归纳</a>
    </div>
</div>

    
        
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/09/29/线程和线程池/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/ExploreAndroid.png" alt="线程和线程池">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-29T11:57:37.000Z">2019-09-29</time></div>
                    <a href="/2019/09/29/线程和线程池/" class="has-link-black-ter is-size-6">线程和线程池</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a> / <a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/29/Android消息机制/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/ExploreAndroid.png" alt="Android消息机制">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-29T07:27:00.000Z">2019-09-29</time></div>
                    <a href="/2019/09/29/Android消息机制/" class="has-link-black-ter is-size-6">Android消息机制</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a> / <a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/28/从多线程到Handler/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/img/handler/Handler.jpg" alt="从多线程到Handler">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-28T05:49:34.000Z">2019-09-28</time></div>
                    <a href="/2019/09/28/从多线程到Handler/" class="has-link-black-ter is-size-6">从多线程到Handler</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/日常/">日常</a> / <a class="has-link-grey -link" href="/categories/日常/胡思乱想/">胡思乱想</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/23/View-process-2/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/SourceCode.jpg" alt="View工作流程[二]：Measure布局">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-23T06:35:36.000Z">2019-09-23</time></div>
                    <a href="/2019/09/23/View-process-2/" class="has-link-black-ter is-size-6">View工作流程[二]：Measure布局</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a> / <a class="has-link-grey -link" href="/categories/源码阅读/View工作流程/">View工作流程</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/22/寄夏予你/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/you.png" alt="寄夏予你">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-22T11:03:10.000Z">2019-09-22</time></div>
                    <a href="/2019/09/22/寄夏予你/" class="has-link-black-ter is-size-6">寄夏予你</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/日常/">日常</a> / <a class="has-link-grey -link" href="/categories/日常/随笔/">随笔</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget is-hidden-mobile">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">11</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/09/29/线程和线程池/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/ExploreAndroid.png" alt="线程和线程池">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-29T11:57:37.000Z">2019-09-29</time></div>
                    <a href="/2019/09/29/线程和线程池/" class="has-link-black-ter is-size-6">线程和线程池</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a> / <a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/29/Android消息机制/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/ExploreAndroid.png" alt="Android消息机制">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-29T07:27:00.000Z">2019-09-29</time></div>
                    <a href="/2019/09/29/Android消息机制/" class="has-link-black-ter is-size-6">Android消息机制</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/读书笔记/">读书笔记</a> / <a class="has-link-grey -link" href="/categories/读书笔记/开发艺术探索/">开发艺术探索</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/28/从多线程到Handler/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/img/handler/Handler.jpg" alt="从多线程到Handler">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-28T05:49:34.000Z">2019-09-28</time></div>
                    <a href="/2019/09/28/从多线程到Handler/" class="has-link-black-ter is-size-6">从多线程到Handler</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/日常/">日常</a> / <a class="has-link-grey -link" href="/categories/日常/胡思乱想/">胡思乱想</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/23/View-process-2/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/SourceCode.jpg" alt="View工作流程[二]：Measure布局">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-23T06:35:36.000Z">2019-09-23</time></div>
                    <a href="/2019/09/23/View-process-2/" class="has-link-black-ter is-size-6">View工作流程[二]：Measure布局</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/源码阅读/">源码阅读</a> / <a class="has-link-grey -link" href="/categories/源码阅读/View工作流程/">View工作流程</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/09/22/寄夏予你/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/assets/gallery/thumbnails/you.png" alt="寄夏予你">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-09-22T11:03:10.000Z">2019-09-22</time></div>
                    <a href="/2019/09/22/寄夏予你/" class="has-link-black-ter is-size-6">寄夏予你</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/日常/">日常</a> / <a class="has-link-grey -link" href="/categories/日常/随笔/">随笔</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget is-hidden-mobile">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">九月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">11</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                    
                    <img src="/assets/img/logo.jpg" alt="Pigrange&#39;s Blog" height="28" style="margin-left: 0.5em">
                    
                </a>
                <p class="is-size-7" style="padding-bottom: 0.5em">
                    <span id="timeDate" class="is-size-7"></span>
                    <span id="times" class="is-size-7"></span>
                </p>
                <p class="is-size-7">
                    &copy; 2019 John Pig&nbsp;
                    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                    
                </p>
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                <script>
                    var now = new Date();
                    function createtime() {
                        var grt = new Date("7/24/2019 16:00:00");//此处修改你的建站时间或者网站上线时间 
                        now.setTime(now.getTime() + 250);
                        days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                        if (String(hnum).length == 1) { hnum = "0" + hnum; } minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
                        mnum = Math.floor(minutes); if (String(mnum).length == 1) { mnum = "0" + mnum; }
                        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                        snum = Math.round(seconds); if (String(snum).length == 1) { snum = "0" + snum; }
                        document.getElementById("timeDate").innerHTML = "&nbsp;&nbsp" + "本站已安全运行 " + dnum + " 天 ";
                        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                    }
                    setInterval("createtime()", 250);
                </script>
            </div>
            <div class="level-end">
                
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"mobile":{"show":false},"model":{"scale":0.7,"jsonPath":"/live2dw/assets/hijiki.model.json"},"log":false});</script></body>
</html>